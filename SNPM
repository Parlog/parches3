diff -x .* -ruPN minix2/etc/system.conf minix/etc/system.conf
--- minix2/etc/system.conf	Tue May 24 18:40:25 2016
+++ minix/etc/system.conf	Tue May 24 18:45:59 2016
@@ -1,724 +1,752 @@
-#
-# Boot system services in the boot image
-#
-
-service rs
-{
-	uid     0;
-	ipc	ALL;		# ALL ipc targets allowed
-	system	ALL;		# ALL kernel calls allowed
-	vm			# Extra VM calls allowed:
-		RS_SET_PRIV	# 37
-		RS_UPDATE	# 41
-		RS_MEMCTL	# 42
-		PROCCTL
-		;
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr        SELF;	# Signal manager is SELF
-	scheduler   KERNEL;	# Scheduler is KERNEL
-	priority	 4;	# priority queue 4
-	quantum	       500;	# default server quantum
-};
-
-service ds
-{
-	uid     0;
-	ipc	ALL_SYS;	# All system ipc targets allowed
-	system	ALL;		# ALL kernel calls allowed
-	vm	BASIC;		# Only basic VM calls allowed
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler   KERNEL;	# Scheduler is KERNEL
-	priority	 4;	# priority queue 4
-	quantum	       500;	# default server quantum
-};
-
-service vm
-{
-	uid     0;
-	ipc	ALL;		# ALL ipc targets allowed
-	system	ALL;		# ALL kernel calls allowed
-	vm	NONE;		# No VM calls allowed
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler   KERNEL;	# Scheduler is KERNEL
-	priority	 2;	# priority queue 2
-	quantum	       500;	# default server quantum
-};
-
-service pm
-{
-	uid     0;
-	ipc	ALL;		# ALL ipc targets allowed
-	system	ALL;		# ALL kernel calls allowed
-	vm			# Extra VM calls allowed:
-		EXIT		# 00
-		FORK		# 01
-		EXEC_NEWMEM	# 03
-		WILLEXIT	# 05
-		NOTIFY_SIG	# 39
-		;
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler   KERNEL;	# Scheduler is KERNEL
-	priority	 4;	# priority queue 4
-	quantum	       500;	# default server quantum
-};
-
-service sched
-{
-	uid     0;
-	ipc	ALL_SYS;	# All system ipc targets allowed
-	system	ALL;		# ALL kernel calls allowed
-	vm	BASIC;		# Only basic VM calls allowed
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler   KERNEL;	# Scheduler is KERNEL
-	priority	 4;	# priority queue 4
-	quantum	       500;	# default server quantum
-};
-
-service vfs
-{
-	uid     0;
-	ipc	ALL;		# ALL ipc targets allowed
-	system			# Extra kernel calls allowed:
-		KILL		# 06
-		UMAP		# 14
-		VIRCOPY		# 15
-		MEMSET
-		;
-	vm	PROCCTL
-		VFS_MMAP
-		VFS_REPLY
-		;
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler   KERNEL;	# Scheduler is KERNEL
-	priority	 5;	# priority queue 5
-	quantum	       500;	# default server quantum
-};
-
-service mfs
-{
-	ipc	ALL_SYS;	# All system ipc targets allowed
-	system	BASIC;		# Only basic kernel calls allowed
-	vm	MAPCACHEPAGE SETCACHEPAGE CLEARCACHE;
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler    sched;	# Scheduler is sched
-	priority	 5;	# priority queue 5
-	quantum	       500;	# default server quantum
-};
-
-service ntfs-3g
-{
-	uid	SELF;		# Use uid of user starting service
-	ipc	ALL_SYS;	# All system ipc targets allowed
-	system	BASIC;		# Only basic kernel calls allowed
-	vm	BASIC;		# Only basic VM calls allowed
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler    sched;	# Scheduler is sched
-	priority	 5;	# priority queue 5
-	quantum	       500;	# default server quantum
-};
-
-service ext2
-{
-	ipc	ALL_SYS;	# All system ipc targets allowed
-	system	BASIC;		# Only basic kernel calls allowed
-	vm	MAPCACHEPAGE SETCACHEPAGE CLEARCACHE;
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler    sched;	# Scheduler is sched
-	priority	 5;	# priority queue 5
-	quantum	       500;	# default server quantum
-};
-
-service pfs
-{
-	ipc	ALL_SYS;	# All system ipc targets allowed
-	system	BASIC;		# Only basic kernel calls allowed
-	vm	MAPCACHEPAGE SETCACHEPAGE CLEARCACHE;
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler    sched;	# Scheduler is sched
-	priority	 5;	# priority queue 5
-	quantum	       500;	# default server quantum
-};
-
-service tty
-{
-	uid     0;
-	ipc	ALL_SYS;	# All system ipc targets allowed
-	system			# Extra kernel calls allowed:
-		KILL		# 06
-		UMAP		# 14
-		VIRCOPY		# 15
-		PHYSCOPY	# 16
-		IRQCTL		# 19
-		INT86		# 20
-		DEVIO		# 21
-		SDEVIO		# 22
-		VDEVIO		# 23
-		ABORT		# 27
-		IOPENABLE	# 28
-		READBIOS	# 35
-		;
-	vm	BASIC;		# Only basic VM calls allowed
-	io	ALL;		# ALL I/O ranges allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler   KERNEL;	# Scheduler is KERNEL (prevents console stalls)
-	priority	 1;	# priority queue 1
-	quantum	        50;	# default driver quantum
-};
-
-service memory
-{
-	uid     0;
-	ipc	ALL_SYS;	# All system ipc targets allowed
-	system			# Extra kernel calls allowed:
-		UMAP		# 14
-		VIRCOPY		# 15
-		PHYSCOPY	# 16
-		IRQCTL		# 19
-		INT86		# 20
-		DEVIO		# 21
-		SDEVIO		# 22
-		VDEVIO		# 23
-		IOPENABLE	# 28
-		;
-	vm	BASIC;		# Only basic VM calls allowed
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQ allowed
-	sigmgr          rs;	# Signal manager is RS
-	scheduler   KERNEL;	# Scheduler is KERNEL
-	priority	 3;	# priority queue 3
-	quantum	        50;	# default driver quantum
-};
-
-service log
-{
-	ipc		SYSTEM vfs rs vm;
-	priority	2;
-};
-
-service init
-{
-	uid     0;
-	ipc			# ipc targets allowed:
-		pm vfs rs vm
-		;
-	system	NONE;		# No kernel calls allowed
-	vm	BASIC;		# Only basic VM calls allowed
-	io	NONE;		# No I/O range allowed
-	irq	NONE;		# No IRQs allowed
-	sigmgr          pm;	# Signal manager is PM
-};
-
-#
-# Dynamically started system services
-#
-
-service floppy
-{
-	irq	6;
-	io	3f0:8
-		0:10	# DMA controller
-		81	# Also DMA
-		;
-	system
-		UMAP		# 14
-		IRQCTL		# 19
-		DEVIO		# 21
-		VDEVIO		# 23
-		;
-};
-
-service dp8390
-{
-	system
-		IRQCTL		# 19
-		DEVIO		# 21
-		SDEVIO		# 22
-	;
-	pci device	10ec:8029;
-	uid	0;
-};
-
-service dpeth
-{
-	system
-		IRQCTL		# 19
-		DEVIO		# 21
-		SDEVIO		# 22
-	;
-	uid	0;
-};
-
-service inet
-{
-	uid 0;
-};
-
-service lwip
-{
-	uid 0;
-};
-
-service random
-{
-};
-
-service readclock.drv
-{
-	ipc	ALL;
-	io	70:2;
-	system
-		PRIVCTL		# 4
-		UMAP		# 14
-		VIRCOPY		# 15
-		DEVIO		# 21
-		READBIOS	# 35
-	;
-	uid 0;
-};
-
-service is
-{
-	vm
-		INFO
-	;
-	uid 0;
-};
-
-service acpi
-{
-	io	ALL;
-	system
-		PRIVCTL		#  4
-		DEVIO		# 21
-	;
-	uid 0;
-};
-
-service pci
-{
-	io	cf8:8		# PCI bus controller
-		4d0:2		# PIIX
-	;
-	system
-		PRIVCTL		#  4
-		DEVIO		# 21
-	;
-	uid 0;
-};
-
-service ahci
-{
-	system
-		UMAP		# 14
-		VUMAP		# 18
-		IRQCTL		# 19
-	;
-	pci class
-		1/6/1		# Mass storage / SATA / AHCI
-	;
-};
-
-service virtio_blk
-{
-	system
-		UMAP
-		VUMAP
-		IRQCTL
-		DEVIO
-	;
-
-	pci device	1af4:1001;
-};
-
-service at_wini
-{
-	io	1f0:8		# Controller 0
-		3f6		# Also controller 0
-		170:8		# Controller 1
-		376		# Also controller 1
-	;
-	irq
-		14		# Controller 0
-		15		# Controller 1
-	;
-	system
-		UMAP		# 14
-		IRQCTL		# 19
-		DEVIO		# 21
-		SDEVIO		# 22
-		VDEVIO		# 23
-	;
-	pci class		# Match these PCI classes:
-		1/1			# Mass storage / IDE
-	;
-	pci device		# In addition, match these devices:
-		1106:3149		# VIA VT6420 RAID (1/4)
-		1095:3512/1095:6512	# Silicon Image SATA RAID (1/4)
-		1095:3114/1095:3114	# Silicon Image SATA RAID (1/80)
-	;
-};
-
-service procfs
-{
-	system
-		VIRCOPY		# 15
-	;
-	vm
-		INFO
-	;
-	uid	0;
-};
-
-service isofs
-{
-	system
-		UMAP            # 14
-		;
-	uid	0;
-};
-
-service hgfs
-{
-	ipc
-		SYSTEM pm vfs rs vm
-	;
-};
-
-service vbfs
-{
-	ipc
-		SYSTEM pm vfs rs ds vm vbox
-	;
-};
-
-service printer
-{
-       io      378:4           # LPT1
-               278:4           # LPT2
-       ;
-       irq
-               7               # PRINTER_IRQ
-       ;
-       system
-		KILL            #  6
-		UMAP            # 14
-		IRQCTL          # 19
-		DEVIO           # 21
-		VDEVIO          # 23
-		READBIOS	# 35
-       ;
-};
-
-service orinoco
-{
-	system
-		PRIVCTL		#  4
-		UMAP		# 14
-		IRQCTL		# 19
-		DEVIO		# 21
-		VM_MAP		# 30
-	;
-	pci device	1260:3873;
-	pci device	1186:1300;
-	uid	0;
-};
-
-service es1370
-{
-	system
-		UMAP		# 14
-		IRQCTL          # 19
-		DEVIO           # 21
-	;
-	pci device 1274:5000;
-};
-
-service es1371
-{
-	system
-		UMAP            # 14
-		IRQCTL          # 19
-		DEVIO           # 21
-	;
-	pci device 1274:1371;
-};
-
-service ti1225
-{
-	system
-		IRQCTL		# 19
-	;
-	pci device	104c:ac1c;
-};
-
-service amddev
-{
-	pci device	1022:1103;
-	system
-		UMAP_REMOTE	# 17
-	;
-	vm
-		ADDDMA		# 12
-		DELDMA		# 13
-		GETDMA		# 14
-	;
-	uid	0;
-};
-
-service osscore
-{
-	system
-		PRIVCTL		#  4
-		UMAP		# 14
-		IRQCTL		# 19
-		DEVIO		# 21
-		SDEVIO		# 22
-	;
-	pci class	
-		4/1		# Multimedia / Audio device
-	;
-	ipc
-		SYSTEM pm rs tty ds vfs vm
-		pci inet lwip amddev 
-		;
-	uid     0;
-};
-
-service filter
-{
-	ipc
-		SYSTEM pm vfs rs ds vm
-		at_wini
-	;
-	control
-		at_wini
-	;
-};
-
-service input
-{
-        ipc		SYSTEM pm vfs rs ds tty vm;
-        priority	1;
-};
-
-
-service pckbd
-{
-	system
-			IRQCTL		# 19
-			DEVIO		# 21
-	;
-	io      	60:8;		# Keyboard, keyboard command/status
-	irq
-			1		# Keyboard
-			12		# Auxiliary input (mouse)
-	;
-	ipc		SYSTEM pm rs ds vm input;
-	priority	1;
-};
-
-service hello
-{
-        system
-                IRQCTL          # 19
-                DEVIO           # 21
-        ;
-        ipc
-                SYSTEM pm rs tty ds vm vfs
-                pci inet lwip amddev
-                ;
-    uid 0;
-};
-
-
-service devman
-{
-	uid 0;
-};
-
-service mmc
-{
-	system
-		PRIVCTL		#  4
-		IRQCTL          # 19
-	;
-	# Interrupts allowed
-	irq	
-		64
-		83
-	;		# IRQs allowed
-	priority	 4;	# priority queue 4
-};
-
-service fb 
-{
-	system
-		UMAP		# 14
-                DEVIO           # 21
-		PRIVCTL		#  4
-        ;
-	ipc
-                SYSTEM pm rs ds vm vfs cat24c256 tda19988
-	;
-};
-
-service gpio
-{
-	system
-		PRIVCTL		#  4
-		IRQCTL          # 19
-		PADCONF		# 57
-	;
-	irq	
-		29	# GPIO module 1 (dm37xx)
-		30	# GPIO module 2 (dm37xx)
-		31	# GPIO module 3 (dm37xx)
-		32	# GPIO module 4 (dm37xx) / module 2a (am335x)
-		33	# GPIO module 5 (dm37xx) / module 2b (am335x)
-		34	# GPIO module 6 (dm37xx)
-		62	# GPIO module 3a (am335x)
-		63	# GPIO module 3b (am335x)
-		96	# GPIO module 0a (am335x)
-		97	# GPIO module 0b (am335x)
-		98	# GPIO module 1a (am335x)
-		99	# GPIO module 1b (am335x)
-	;		
-
-};
-
-service i2c
-{
-	system
-		PRIVCTL		#  4
-		IRQCTL          # 19
-		PADCONF		# 57
-	;
-	irq
-		# DM37XX (BeagleBoard-xM)
-		56	# I2C module 1
-		57	# I2C module 2
-		61	# I2C module 3
-		# AM335X (BeagleBone)
-		70	# I2C module 1
-		71	# I2C module 2
-		30	# I2C module 3
-	;
-	ipc SYSTEM RS DS;
-};
-
-service cat24c256
-{
-	ipc SYSTEM RS DS i2c;
-};
-
-service tda19988
-{
-	ipc SYSTEM RS DS i2c;
-};
-
-service tps65217
-{
-	uid 0;		# needed for doing reboot()
-	system IRQCTL PRIVCTL;
-	irq 7;		# NNMI pin on BeagleBone / BeagleBone Black
-	ipc SYSTEM RS DS PM i2c;
-};
-
-service tps65950
-{
-	ipc SYSTEM RS DS i2c readclock.drv;
-};
-
-service tsl2550
-{
-	ipc SYSTEM RS DS i2c;
-};
-
-service sht21
-{
-	ipc SYSTEM RS DS i2c;
-};
-
-service bmp085
-{
-	ipc SYSTEM RS DS i2c;
-};
-
-service vbox
-{
-	system
-		UMAP		# 14
-		VUMAP		# 18
-		IRQCTL          # 19
-		DEVIO		# 21
-	;
-	pci device	80ee:cafe;
-	ipc
-		SYSTEM
-		PM
-		RS
-		VM
-		pci
-	;
-	uid	0;
-};
-
-service fbd
-{
-	ipc
-		SYSTEM vfs rs ds vm
-		ahci
-		at_wini
-	;
-};
-
-service vnd
-{
-	ipc
-		SYSTEM vfs rs vm
-	;
-	uid	0;	# only for copyfd(2)
-};
-
-service uds
-{
-	ipc
-		SYSTEM vfs rs vm
-	;
-	uid	0;	# only for checkperms(2) and copyfd(2)
-};
-
-service pty
-{
-	system
-		KILL		# 06
-	;
-	ipc
-		SYSTEM vfs rs vm
-	;
-};
-
-service edfictl
-{
-        ipc ALL;
-};
+#
+# Boot system services in the boot image
+#
+
+service rs
+{
+	uid     0;
+	ipc	ALL;		# ALL ipc targets allowed
+	system	ALL;		# ALL kernel calls allowed
+	vm			# Extra VM calls allowed:
+		RS_SET_PRIV	# 37
+		RS_UPDATE	# 41
+		RS_MEMCTL	# 42
+		PROCCTL
+		;
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr        SELF;	# Signal manager is SELF
+	scheduler   KERNEL;	# Scheduler is KERNEL
+	priority	 4;	# priority queue 4
+	quantum	       500;	# default server quantum
+};
+
+service ds
+{
+	uid     0;
+	ipc	ALL_SYS;	# All system ipc targets allowed
+	system	ALL;		# ALL kernel calls allowed
+	vm	BASIC;		# Only basic VM calls allowed
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler   KERNEL;	# Scheduler is KERNEL
+	priority	 4;	# priority queue 4
+	quantum	       500;	# default server quantum
+};
+
+service vm
+{
+	uid     0;
+	ipc	ALL;		# ALL ipc targets allowed
+	system	ALL;		# ALL kernel calls allowed
+	vm	NONE;		# No VM calls allowed
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler   KERNEL;	# Scheduler is KERNEL
+	priority	 2;	# priority queue 2
+	quantum	       500;	# default server quantum
+};
+
+service pm
+{
+	uid     0;
+	ipc	ALL;		# ALL ipc targets allowed
+	system	ALL;		# ALL kernel calls allowed
+	vm			# Extra VM calls allowed:
+		EXIT		# 00
+		FORK		# 01
+		EXEC_NEWMEM	# 03
+		WILLEXIT	# 05
+		NOTIFY_SIG	# 39
+		;
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler   KERNEL;	# Scheduler is KERNEL
+	priority	 4;	# priority queue 4
+	quantum	       500;	# default server quantum
+};
+
+service sched
+{
+	uid     0;
+	ipc	ALL_SYS;	# All system ipc targets allowed
+	system	ALL;		# ALL kernel calls allowed
+	vm	BASIC;		# Only basic VM calls allowed
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler   KERNEL;	# Scheduler is KERNEL
+	priority	 4;	# priority queue 4
+	quantum	       200;	# default server quantum
+};
+
+service sched_rr
+{
+	uid     0;
+	ipc	ALL_SYS;	# All system ipc targets allowed
+	system	ALL;		# ALL kernel calls allowed
+	vm	BASIC;		# Only basic VM calls allowed
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler   KERNEL;	# Scheduler is KERNEL
+	priority	 4;	# priority queue 4
+	quantum	       200;	# default server quantum
+};
+
+service sched_fcfs
+{
+	uid     0;
+	ipc	ALL_SYS;	# All system ipc targets allowed
+	system	ALL;		# ALL kernel calls allowed
+	vm	BASIC;		# Only basic VM calls allowed
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler   KERNEL;	# Scheduler is KERNEL
+	priority	 4;	# priority queue 4
+	quantum	       200;	# default server quantum
+};
+
+service vfs
+{
+	uid     0;
+	ipc	ALL;		# ALL ipc targets allowed
+	system			# Extra kernel calls allowed:
+		KILL		# 06
+		UMAP		# 14
+		VIRCOPY		# 15
+		MEMSET
+		;
+	vm	PROCCTL
+		VFS_MMAP
+		VFS_REPLY
+		;
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler   KERNEL;	# Scheduler is KERNEL
+	priority	 5;	# priority queue 5
+	quantum	       500;	# default server quantum
+};
+
+service mfs
+{
+	ipc	ALL_SYS;	# All system ipc targets allowed
+	system	BASIC;		# Only basic kernel calls allowed
+	vm	MAPCACHEPAGE SETCACHEPAGE CLEARCACHE;
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler    sched;	# Scheduler is sched
+	priority	 5;	# priority queue 5
+	quantum	       500;	# default server quantum
+};
+
+service ntfs-3g
+{
+	uid	SELF;		# Use uid of user starting service
+	ipc	ALL_SYS;	# All system ipc targets allowed
+	system	BASIC;		# Only basic kernel calls allowed
+	vm	BASIC;		# Only basic VM calls allowed
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler    sched;	# Scheduler is sched
+	priority	 5;	# priority queue 5
+	quantum	       500;	# default server quantum
+};
+
+service ext2
+{
+	ipc	ALL_SYS;	# All system ipc targets allowed
+	system	BASIC;		# Only basic kernel calls allowed
+	vm	MAPCACHEPAGE SETCACHEPAGE CLEARCACHE;
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler    sched;	# Scheduler is sched
+	priority	 5;	# priority queue 5
+	quantum	       500;	# default server quantum
+};
+
+service pfs
+{
+	ipc	ALL_SYS;	# All system ipc targets allowed
+	system	BASIC;		# Only basic kernel calls allowed
+	vm	MAPCACHEPAGE SETCACHEPAGE CLEARCACHE;
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler    sched;	# Scheduler is sched
+	priority	 5;	# priority queue 5
+	quantum	       500;	# default server quantum
+};
+
+service tty
+{
+	uid     0;
+	ipc	ALL_SYS;	# All system ipc targets allowed
+	system			# Extra kernel calls allowed:
+		KILL		# 06
+		UMAP		# 14
+		VIRCOPY		# 15
+		PHYSCOPY	# 16
+		IRQCTL		# 19
+		INT86		# 20
+		DEVIO		# 21
+		SDEVIO		# 22
+		VDEVIO		# 23
+		ABORT		# 27
+		IOPENABLE	# 28
+		READBIOS	# 35
+		;
+	vm	BASIC;		# Only basic VM calls allowed
+	io	ALL;		# ALL I/O ranges allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler   KERNEL;	# Scheduler is KERNEL (prevents console stalls)
+	priority	 1;	# priority queue 1
+	quantum	        50;	# default driver quantum
+};
+
+service memory
+{
+	uid     0;
+	ipc	ALL_SYS;	# All system ipc targets allowed
+	system			# Extra kernel calls allowed:
+		UMAP		# 14
+		VIRCOPY		# 15
+		PHYSCOPY	# 16
+		IRQCTL		# 19
+		INT86		# 20
+		DEVIO		# 21
+		SDEVIO		# 22
+		VDEVIO		# 23
+		IOPENABLE	# 28
+		;
+	vm	BASIC;		# Only basic VM calls allowed
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQ allowed
+	sigmgr          rs;	# Signal manager is RS
+	scheduler   KERNEL;	# Scheduler is KERNEL
+	priority	 3;	# priority queue 3
+	quantum	        50;	# default driver quantum
+};
+
+service log
+{
+	ipc		SYSTEM vfs rs vm;
+	priority	2;
+};
+
+service init
+{
+	uid     0;
+	ipc			# ipc targets allowed:
+		pm vfs rs vm
+		;
+	system	NONE;		# No kernel calls allowed
+	vm	BASIC;		# Only basic VM calls allowed
+	io	NONE;		# No I/O range allowed
+	irq	NONE;		# No IRQs allowed
+	sigmgr          pm;	# Signal manager is PM
+};
+
+#
+# Dynamically started system services
+#
+
+service floppy
+{
+	irq	6;
+	io	3f0:8
+		0:10	# DMA controller
+		81	# Also DMA
+		;
+	system
+		UMAP		# 14
+		IRQCTL		# 19
+		DEVIO		# 21
+		VDEVIO		# 23
+		;
+};
+
+service dp8390
+{
+	system
+		IRQCTL		# 19
+		DEVIO		# 21
+		SDEVIO		# 22
+	;
+	pci device	10ec:8029;
+	uid	0;
+};
+
+service dpeth
+{
+	system
+		IRQCTL		# 19
+		DEVIO		# 21
+		SDEVIO		# 22
+	;
+	uid	0;
+};
+
+service inet
+{
+	uid 0;
+};
+
+service lwip
+{
+	uid 0;
+};
+
+service random
+{
+};
+
+service readclock.drv
+{
+	ipc	ALL;
+	io	70:2;
+	system
+		PRIVCTL		# 4
+		UMAP		# 14
+		VIRCOPY		# 15
+		DEVIO		# 21
+		READBIOS	# 35
+	;
+	uid 0;
+};
+
+service is
+{
+	vm
+		INFO
+	;
+	uid 0;
+};
+
+service acpi
+{
+	io	ALL;
+	system
+		PRIVCTL		#  4
+		DEVIO		# 21
+	;
+	uid 0;
+};
+
+service pci
+{
+	io	cf8:8		# PCI bus controller
+		4d0:2		# PIIX
+	;
+	system
+		PRIVCTL		#  4
+		DEVIO		# 21
+	;
+	uid 0;
+};
+
+service ahci
+{
+	system
+		UMAP		# 14
+		VUMAP		# 18
+		IRQCTL		# 19
+	;
+	pci class
+		1/6/1		# Mass storage / SATA / AHCI
+	;
+};
+
+service virtio_blk
+{
+	system
+		UMAP
+		VUMAP
+		IRQCTL
+		DEVIO
+	;
+
+	pci device	1af4:1001;
+};
+
+service at_wini
+{
+	io	1f0:8		# Controller 0
+		3f6		# Also controller 0
+		170:8		# Controller 1
+		376		# Also controller 1
+	;
+	irq
+		14		# Controller 0
+		15		# Controller 1
+	;
+	system
+		UMAP		# 14
+		IRQCTL		# 19
+		DEVIO		# 21
+		SDEVIO		# 22
+		VDEVIO		# 23
+	;
+	pci class		# Match these PCI classes:
+		1/1			# Mass storage / IDE
+	;
+	pci device		# In addition, match these devices:
+		1106:3149		# VIA VT6420 RAID (1/4)
+		1095:3512/1095:6512	# Silicon Image SATA RAID (1/4)
+		1095:3114/1095:3114	# Silicon Image SATA RAID (1/80)
+	;
+};
+
+service procfs
+{
+	system
+		VIRCOPY		# 15
+	;
+	vm
+		INFO
+	;
+	uid	0;
+};
+
+service isofs
+{
+	system
+		UMAP            # 14
+		;
+	uid	0;
+};
+
+service hgfs
+{
+	ipc
+		SYSTEM pm vfs rs vm
+	;
+};
+
+service vbfs
+{
+	ipc
+		SYSTEM pm vfs rs ds vm vbox
+	;
+};
+
+service printer
+{
+       io      378:4           # LPT1
+               278:4           # LPT2
+       ;
+       irq
+               7               # PRINTER_IRQ
+       ;
+       system
+		KILL            #  6
+		UMAP            # 14
+		IRQCTL          # 19
+		DEVIO           # 21
+		VDEVIO          # 23
+		READBIOS	# 35
+       ;
+};
+
+service orinoco
+{
+	system
+		PRIVCTL		#  4
+		UMAP		# 14
+		IRQCTL		# 19
+		DEVIO		# 21
+		VM_MAP		# 30
+	;
+	pci device	1260:3873;
+	pci device	1186:1300;
+	uid	0;
+};
+
+service es1370
+{
+	system
+		UMAP		# 14
+		IRQCTL          # 19
+		DEVIO           # 21
+	;
+	pci device 1274:5000;
+};
+
+service es1371
+{
+	system
+		UMAP            # 14
+		IRQCTL          # 19
+		DEVIO           # 21
+	;
+	pci device 1274:1371;
+};
+
+service ti1225
+{
+	system
+		IRQCTL		# 19
+	;
+	pci device	104c:ac1c;
+};
+
+service amddev
+{
+	pci device	1022:1103;
+	system
+		UMAP_REMOTE	# 17
+	;
+	vm
+		ADDDMA		# 12
+		DELDMA		# 13
+		GETDMA		# 14
+	;
+	uid	0;
+};
+
+service osscore
+{
+	system
+		PRIVCTL		#  4
+		UMAP		# 14
+		IRQCTL		# 19
+		DEVIO		# 21
+		SDEVIO		# 22
+	;
+	pci class	
+		4/1		# Multimedia / Audio device
+	;
+	ipc
+		SYSTEM pm rs tty ds vfs vm
+		pci inet lwip amddev 
+		;
+	uid     0;
+};
+
+service filter
+{
+	ipc
+		SYSTEM pm vfs rs ds vm
+		at_wini
+	;
+	control
+		at_wini
+	;
+};
+
+service input
+{
+        ipc		SYSTEM pm vfs rs ds tty vm;
+        priority	1;
+};
+
+
+service pckbd
+{
+	system
+			IRQCTL		# 19
+			DEVIO		# 21
+	;
+	io      	60:8;		# Keyboard, keyboard command/status
+	irq
+			1		# Keyboard
+			12		# Auxiliary input (mouse)
+	;
+	ipc		SYSTEM pm rs ds vm input;
+	priority	1;
+};
+
+service hello
+{
+        system
+                IRQCTL          # 19
+                DEVIO           # 21
+        ;
+        ipc
+                SYSTEM pm rs tty ds vm vfs
+                pci inet lwip amddev
+                ;
+    uid 0;
+};
+
+
+service devman
+{
+	uid 0;
+};
+
+service mmc
+{
+	system
+		PRIVCTL		#  4
+		IRQCTL          # 19
+	;
+	# Interrupts allowed
+	irq	
+		64
+		83
+	;		# IRQs allowed
+	priority	 4;	# priority queue 4
+};
+
+service fb 
+{
+	system
+		UMAP		# 14
+                DEVIO           # 21
+		PRIVCTL		#  4
+        ;
+	ipc
+                SYSTEM pm rs ds vm vfs cat24c256 tda19988
+	;
+};
+
+service gpio
+{
+	system
+		PRIVCTL		#  4
+		IRQCTL          # 19
+		PADCONF		# 57
+	;
+	irq	
+		29	# GPIO module 1 (dm37xx)
+		30	# GPIO module 2 (dm37xx)
+		31	# GPIO module 3 (dm37xx)
+		32	# GPIO module 4 (dm37xx) / module 2a (am335x)
+		33	# GPIO module 5 (dm37xx) / module 2b (am335x)
+		34	# GPIO module 6 (dm37xx)
+		62	# GPIO module 3a (am335x)
+		63	# GPIO module 3b (am335x)
+		96	# GPIO module 0a (am335x)
+		97	# GPIO module 0b (am335x)
+		98	# GPIO module 1a (am335x)
+		99	# GPIO module 1b (am335x)
+	;		
+
+};
+
+service i2c
+{
+	system
+		PRIVCTL		#  4
+		IRQCTL          # 19
+		PADCONF		# 57
+	;
+	irq
+		# DM37XX (BeagleBoard-xM)
+		56	# I2C module 1
+		57	# I2C module 2
+		61	# I2C module 3
+		# AM335X (BeagleBone)
+		70	# I2C module 1
+		71	# I2C module 2
+		30	# I2C module 3
+	;
+	ipc SYSTEM RS DS;
+};
+
+service cat24c256
+{
+	ipc SYSTEM RS DS i2c;
+};
+
+service tda19988
+{
+	ipc SYSTEM RS DS i2c;
+};
+
+service tps65217
+{
+	uid 0;		# needed for doing reboot()
+	system IRQCTL PRIVCTL;
+	irq 7;		# NNMI pin on BeagleBone / BeagleBone Black
+	ipc SYSTEM RS DS PM i2c;
+};
+
+service tps65950
+{
+	ipc SYSTEM RS DS i2c readclock.drv;
+};
+
+service tsl2550
+{
+	ipc SYSTEM RS DS i2c;
+};
+
+service sht21
+{
+	ipc SYSTEM RS DS i2c;
+};
+
+service bmp085
+{
+	ipc SYSTEM RS DS i2c;
+};
+
+service vbox
+{
+	system
+		UMAP		# 14
+		VUMAP		# 18
+		IRQCTL          # 19
+		DEVIO		# 21
+	;
+	pci device	80ee:cafe;
+	ipc
+		SYSTEM
+		PM
+		RS
+		VM
+		pci
+	;
+	uid	0;
+};
+
+service fbd
+{
+	ipc
+		SYSTEM vfs rs ds vm
+		ahci
+		at_wini
+	;
+};
+
+service vnd
+{
+	ipc
+		SYSTEM vfs rs vm
+	;
+	uid	0;	# only for copyfd(2)
+};
+
+service uds
+{
+	ipc
+		SYSTEM vfs rs vm
+	;
+	uid	0;	# only for checkperms(2) and copyfd(2)
+};
+
+service pty
+{
+	system
+		KILL		# 06
+	;
+	ipc
+		SYSTEM vfs rs vm
+	;
+};
+
+service edfictl
+{
+        ipc ALL;
+};
diff -x .* -ruPN minix2/minix/include/minix/com.h minix/minix/include/minix/com.h
--- minix2/minix/include/minix/com.h	Tue May 24 18:41:15 2016
+++ minix/minix/include/minix/com.h	Tue May 24 18:46:23 2016
@@ -1,972 +1,998 @@
-/* This file defines constants for use in message communication (mostly)
- * between system processes.
- *
- * A number of protocol message request and response types are defined. For
- * debugging purposes, each protocol is assigned its own unique number range.
- * The following such message type ranges have been allocated:
- *
- *     0x00 -   0xFF	Process Manager (PM) requests (see callnr.h)
- *    0x100 -  0x1FF	Virtual File System (VFS) requests (see callnr.h)
- *    0x200 -  0x2FF	Data link layer requests and responses
- *    0x300 -  0x3FF	Bus controller requests and responses
- *    0x400 -  0x4FF	Character device requests and responses
- *    0x500 -  0x5FF	Block device requests and responses
- *    0x600 -  0x6FF	Kernel calls
- *    0x700 -  0x7FF	Reincarnation Server (RS) requests
- *    0x800 -  0x8FF	Data Store (DS) requests
- *    0x900 -  0x9FF	Requests from PM to VFS, and responses
- *    0xA00 -  0xAFF	Requests from VFS to file systems (see vfsif.h)
- *    0xB00 -  0xBFF	Transaction IDs from VFS to file systems (see vfsif.h)
- *    0xC00 -  0xCFF	Virtual Memory (VM) requests
- *    0xD00 -  0xDFF	IPC server requests
- *    0xE00 -  0xEFF	Common system messages (e.g. system signals)
- *    0xF00 -  0xFFF	Scheduling messages
- *   0x1000 - 0x10FF	Notify messages
- *   0x1100 - 0x11FF	USB  
- *   0x1200 - 0x12FF	Devman
- *   0x1300 - 0x13FF	TTY requests
- *   0x1400 - 0x14FF	Real Time Clock requests and responses
- *   0x1500 - 0x15FF	Input server messages
- *   0x1600 - 0x16FF	VirtualBox (VBOX) requests (see vboxif.h)
- *
- * Zero and negative values are widely used for OK and error responses.
- */
-
-#ifndef _MINIX_COM_H
-#define _MINIX_COM_H 
-
-/*===========================================================================*
- *            	Process numbers of processes in the system image	     *
- *===========================================================================*/
-
-/* Kernel tasks. These all run in the same address space. */
-#define ASYNCM	((endpoint_t) -5) /* notifies about finished async sends */
-#define IDLE    ((endpoint_t) -4) /* runs when no one else can run */
-#define CLOCK  	((endpoint_t) -3) /* alarms and other clock functions */
-#define SYSTEM  ((endpoint_t) -2) /* request system functionality */
-#define KERNEL  ((endpoint_t) -1) /* pseudo-process for IPC and scheduling */
-#define HARDWARE     KERNEL	/* for hardware interrupt handlers */
-
-/* Number of tasks. Note that NR_PROCS is defined in <minix/config.h>. */
-#define MAX_NR_TASKS	1023
-#define NR_TASKS	  5 
-
-/* User-space processes, that is, device drivers, servers, and INIT. */
-#define PM_PROC_NR   ((endpoint_t) 0)	/* process manager */
-#define VFS_PROC_NR  ((endpoint_t) 1)	/* file system */
-#define RS_PROC_NR   ((endpoint_t) 2)  	/* reincarnation server */
-#define MEM_PROC_NR  ((endpoint_t) 3)  	/* memory driver (RAM disk, null, etc.) */
-#define SCHED_PROC_NR ((endpoint_t) 4)	/* scheduler */
-#define TTY_PROC_NR  ((endpoint_t) 5)	/* terminal (TTY) driver */
-#define DS_PROC_NR   ((endpoint_t) 6)   /* data store server */
-#define MFS_PROC_NR  ((endpoint_t) 7)   /* minix root filesystem */
-#define VM_PROC_NR   ((endpoint_t) 8)   /* memory server */
-#define PFS_PROC_NR  ((endpoint_t) 9)  /* pipe filesystem */
-#define LAST_SPECIAL_PROC_NR	10	/* An untyped version for
-                                           computation in macros.*/
-#define INIT_PROC_NR ((endpoint_t) LAST_SPECIAL_PROC_NR)  /* init
-                                                        -- goes multiuser */
-#define NR_BOOT_MODULES (INIT_PROC_NR+1)
-
-/* Root system process and root user process. */
-#define ROOT_SYS_PROC_NR  RS_PROC_NR
-#define ROOT_USR_PROC_NR  INIT_PROC_NR
-
-/*===========================================================================*
- *                	   Kernel notification types                         *
- *===========================================================================*/
-
-/* Kernel notification types. In principle, these can be sent to any process,
- * so make sure that these types do not interfere with other message types.
- * Notifications are prioritized because of the way they are unhold() and
- * blocking notifications are delivered. The lowest numbers go first. The
- * offset are used for the per-process notification bit maps. 
- */
-#define NOTIFY_MESSAGE		  0x1000
-/* FIXME the old is_notify(a) should be replaced by is_ipc_notify(status). */
-#define is_ipc_notify(ipc_status) (IPC_STATUS_CALL(ipc_status) == NOTIFY)
-#define is_notify(a)		  ((unsigned) ((a) - NOTIFY_MESSAGE) < 0x100)
-#define is_ipc_asynch(ipc_status) \
-    (is_ipc_notify(ipc_status) || IPC_STATUS_CALL(ipc_status) == SENDA)
-
-/*===========================================================================*
- *                Messages for BUS controller drivers 			     *
- *===========================================================================*/
-#define BUSC_RQ_BASE	0x300	/* base for request types */
-#define BUSC_RS_BASE	0x380	/* base for response types */
-
-#define BUSC_PCI_INIT		(BUSC_RQ_BASE + 0)	/* First message to
-							 * PCI driver
-							 */
-#define BUSC_PCI_FIRST_DEV	(BUSC_RQ_BASE + 1)	/* Get index (and
-							 * vid/did) of the
-							 * first PCI device
-							 */
-#define BUSC_PCI_NEXT_DEV	(BUSC_RQ_BASE + 2)	/* Get index (and
-							 * vid/did) of the
-							 * next PCI device
-							 */
-#define BUSC_PCI_FIND_DEV	(BUSC_RQ_BASE + 3)	/* Get index of a
-							 * PCI device based on
-							 * bus/dev/function
-							 */
-#define BUSC_PCI_IDS		(BUSC_RQ_BASE + 4)	/* Get vid/did from an
-							 * index
-							 */
-#define BUSC_PCI_RESERVE	(BUSC_RQ_BASE + 7)	/* Reserve a PCI dev */
-#define BUSC_PCI_ATTR_R8	(BUSC_RQ_BASE + 8)	/* Read 8-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_ATTR_R16	(BUSC_RQ_BASE + 9)	/* Read 16-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_ATTR_R32	(BUSC_RQ_BASE + 10)	/* Read 32-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_ATTR_W8	(BUSC_RQ_BASE + 11)	/* Write 8-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_ATTR_W16	(BUSC_RQ_BASE + 12)	/* Write 16-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_ATTR_W32	(BUSC_RQ_BASE + 13)	/* Write 32-bit
-							 * attribute value
-							 */
-#define BUSC_PCI_RESCAN		(BUSC_RQ_BASE + 14)	/* Rescan bus */
-#define BUSC_PCI_DEV_NAME_S	(BUSC_RQ_BASE + 15)	/* Get the name of a
-							 * PCI device
-							 * (safecopy)
-							 */
-#define BUSC_PCI_SLOT_NAME_S	(BUSC_RQ_BASE + 16)	/* Get the name of a
-							 * PCI slot (safecopy)
-							 */
-#define BUSC_PCI_SET_ACL	(BUSC_RQ_BASE + 17)	/* Set the ACL for a
-							 * driver (safecopy)
-							 */
-#define BUSC_PCI_DEL_ACL	(BUSC_RQ_BASE + 18)	/* Delete the ACL of a
-							 * driver 
-							 */
-#define BUSC_PCI_GET_BAR	(BUSC_RQ_BASE + 19)	/* Get Base Address
-							 * Register properties
-							 */
-#define IOMMU_MAP		(BUSC_RQ_BASE + 32)	/* Ask IOMMU to map
-							 * a segment of memory
-							 */
-
-#define BUSC_I2C_RESERVE	(BUSC_RQ_BASE + 64)	/* reserve i2c device */
-#define BUSC_I2C_EXEC		(BUSC_RQ_BASE + 65)	/* perform i2c action */
-
-/*===========================================================================*
- *                  	   Messages for networking layer		     *
- *===========================================================================*/
-
-/* Base type for data link layer requests and responses. */
-#define DL_RQ_BASE	0x200		
-#define DL_RS_BASE	0x280		
-
-#define IS_DL_RQ(type) (((type) & ~0x7f) == DL_RQ_BASE)
-#define IS_DL_RS(type) (((type) & ~0x7f) == DL_RS_BASE)
-
-/* Message types for data link layer requests. */
-#define DL_CONF		(DL_RQ_BASE + 0)
-#define DL_GETSTAT_S	(DL_RQ_BASE + 1)
-#define DL_WRITEV_S	(DL_RQ_BASE + 2)
-#define DL_READV_S	(DL_RQ_BASE + 3)
-
-/* Message type for data link layer replies. */
-#define DL_CONF_REPLY	(DL_RS_BASE + 0)
-#define DL_STAT_REPLY	(DL_RS_BASE + 1)
-#define DL_TASK_REPLY	(DL_RS_BASE + 2)
-
-/* Bits in 'flags' field of DL replies. */
-#  define DL_NOFLAGS		0x00
-#  define DL_PACK_SEND		0x01
-#  define DL_PACK_RECV		0x02
-
-/* Bits in 'DL_MODE' field of DL requests. */
-#  define DL_NOMODE		0x0
-#  define DL_PROMISC_REQ	0x1
-#  define DL_MULTI_REQ		0x2
-#  define DL_BROAD_REQ		0x4
-
-/*===========================================================================*
- *                  SYSTASK request types and field names                    *
- *===========================================================================*/
-
-/* System library calls are dispatched via a call vector, so be careful when 
- * modifying the system call numbers. The numbers here determine which call
- * is made from the call vector.
- */ 
-#define KERNEL_CALL	0x600	/* base for kernel calls to SYSTEM */ 
-
-#  define SYS_FORK       (KERNEL_CALL + 0)	/* sys_fork() */
-#  define SYS_EXEC       (KERNEL_CALL + 1)	/* sys_exec() */
-#  define SYS_CLEAR	 (KERNEL_CALL + 2)	/* sys_clear() */
-#  define SYS_SCHEDULE 	 (KERNEL_CALL + 3)	/* sys_schedule() */
-#  define SYS_PRIVCTL    (KERNEL_CALL + 4)	/* sys_privctl() */
-#  define SYS_TRACE      (KERNEL_CALL + 5)	/* sys_trace() */
-#  define SYS_KILL       (KERNEL_CALL + 6)	/* sys_kill() */
-
-#  define SYS_GETKSIG    (KERNEL_CALL + 7)	/* sys_getsig() */
-#  define SYS_ENDKSIG    (KERNEL_CALL + 8)	/* sys_endsig() */
-#  define SYS_SIGSEND    (KERNEL_CALL + 9)	/* sys_sigsend() */
-#  define SYS_SIGRETURN  (KERNEL_CALL + 10)	/* sys_sigreturn() */
-
-#  define SYS_MEMSET     (KERNEL_CALL + 13)	/* sys_memset() */
-
-#  define SYS_UMAP       (KERNEL_CALL + 14)	/* sys_umap() */
-#  define SYS_VIRCOPY    (KERNEL_CALL + 15)	/* sys_vircopy() */
-#  define SYS_PHYSCOPY   (KERNEL_CALL + 16) 	/* sys_physcopy() */
-#  define SYS_UMAP_REMOTE (KERNEL_CALL + 17)	/* sys_umap_remote() */
-#  define SYS_VUMAP      (KERNEL_CALL + 18)	/* sys_vumap() */
-
-#  define SYS_IRQCTL     (KERNEL_CALL + 19)	/* sys_irqctl() */
-#  define SYS_INT86      (KERNEL_CALL + 20)	/* sys_int86() */
-#  define SYS_DEVIO      (KERNEL_CALL + 21)	/* sys_devio() */
-#  define SYS_SDEVIO     (KERNEL_CALL + 22)	/* sys_sdevio() */
-#  define SYS_VDEVIO     (KERNEL_CALL + 23)	/* sys_vdevio() */
-
-#  define SYS_SETALARM	 (KERNEL_CALL + 24)	/* sys_setalarm() */
-#  define SYS_TIMES	 (KERNEL_CALL + 25)	/* sys_times() */
-#  define SYS_GETINFO    (KERNEL_CALL + 26) 	/* sys_getinfo() */
-#  define SYS_ABORT      (KERNEL_CALL + 27)	/* sys_abort() */
-#  define SYS_IOPENABLE  (KERNEL_CALL + 28)	/* sys_enable_iop() */
-#  define SYS_SAFECOPYFROM (KERNEL_CALL + 31)	/* sys_safecopyfrom() */
-#  define SYS_SAFECOPYTO   (KERNEL_CALL + 32)	/* sys_safecopyto() */
-#  define SYS_VSAFECOPY  (KERNEL_CALL + 33)	/* sys_vsafecopy() */
-#  define SYS_SETGRANT   (KERNEL_CALL + 34)	/* sys_setgrant() */
-#  define SYS_READBIOS   (KERNEL_CALL + 35)	/* sys_readbios() */
-
-#  define SYS_SPROF      (KERNEL_CALL + 36)     /* sys_sprof() */ 
-#  define SYS_CPROF      (KERNEL_CALL + 37)     /* sys_cprof() */
-#  define SYS_PROFBUF    (KERNEL_CALL + 38)     /* sys_profbuf() */
-
-#  define SYS_STIME      (KERNEL_CALL + 39)	/* sys_stime() */
-#  define SYS_SETTIME    (KERNEL_CALL + 40)	/* sys_settime() */
-
-#  define SYS_VMCTL      (KERNEL_CALL + 43)	/* sys_vmctl() */
-
-#  define SYS_DIAGCTL    (KERNEL_CALL + 44)	/* sys_diagctl() */
-
-#  define SYS_VTIMER     (KERNEL_CALL + 45)	/* sys_vtimer() */
-#  define SYS_RUNCTL     (KERNEL_CALL + 46)	/* sys_runctl() */
-#  define SYS_GETMCONTEXT (KERNEL_CALL + 50)    /* sys_getmcontext() */
-#  define SYS_SETMCONTEXT (KERNEL_CALL + 51)    /* sys_setmcontext() */
-
-#  define SYS_UPDATE	 (KERNEL_CALL + 52)	/* sys_update() */
-#  define SYS_EXIT	 (KERNEL_CALL + 53)	/* sys_exit() */
-
-#  define SYS_SCHEDCTL (KERNEL_CALL + 54)	/* sys_schedctl() */
-#  define SYS_STATECTL (KERNEL_CALL + 55)	/* sys_statectl() */
-
-#  define SYS_SAFEMEMSET (KERNEL_CALL + 56)	/* sys_safememset() */
-
-#  define SYS_PADCONF (KERNEL_CALL + 57)	/* sys_padconf() */
-
-/* Total */
-#define NR_SYS_CALLS	58	/* number of kernel calls */
-
-#define SYS_CALL_MASK_SIZE BITMAP_CHUNKS(NR_SYS_CALLS)
-
-/* Basic kernel calls allowed to every system process. */
-#define SYS_BASIC_CALLS \
-    SYS_EXIT, SYS_SAFECOPYFROM, SYS_SAFECOPYTO, SYS_VSAFECOPY, SYS_GETINFO, \
-    SYS_TIMES, SYS_SETALARM, SYS_SETGRANT, \
-    SYS_PROFBUF, SYS_DIAGCTL, SYS_STATECTL, SYS_SAFEMEMSET
-
-/* Field names for SYS_DEVIO, SYS_VDEVIO, SYS_SDEVIO. */
-#   define _DIO_INPUT		0x001
-#   define _DIO_OUTPUT		0x002
-#   define _DIO_DIRMASK		0x00f
-#   define _DIO_BYTE		0x010
-#   define _DIO_WORD		0x020
-#   define _DIO_LONG		0x030
-#   define _DIO_TYPEMASK	0x0f0
-#   define _DIO_SAFE		0x100
-#   define _DIO_SAFEMASK	0xf00
-#   define DIO_INPUT_BYTE	    (_DIO_INPUT|_DIO_BYTE)
-#   define DIO_INPUT_WORD	    (_DIO_INPUT|_DIO_WORD)
-#   define DIO_INPUT_LONG	    (_DIO_INPUT|_DIO_LONG)
-#   define DIO_OUTPUT_BYTE	    (_DIO_OUTPUT|_DIO_BYTE)
-#   define DIO_OUTPUT_WORD	    (_DIO_OUTPUT|_DIO_WORD)
-#   define DIO_OUTPUT_LONG	    (_DIO_OUTPUT|_DIO_LONG)
-#   define DIO_SAFE_INPUT_BYTE      (_DIO_INPUT|_DIO_BYTE|_DIO_SAFE)
-#   define DIO_SAFE_INPUT_WORD      (_DIO_INPUT|_DIO_WORD|_DIO_SAFE)
-#   define DIO_SAFE_INPUT_LONG      (_DIO_INPUT|_DIO_LONG|_DIO_SAFE)
-#   define DIO_SAFE_OUTPUT_BYTE     (_DIO_OUTPUT|_DIO_BYTE|_DIO_SAFE)
-#   define DIO_SAFE_OUTPUT_WORD     (_DIO_OUTPUT|_DIO_WORD|_DIO_SAFE)
-#   define DIO_SAFE_OUTPUT_LONG     (_DIO_OUTPUT|_DIO_LONG|_DIO_SAFE)
-
-/* Field names for SYS_IRQCTL. */
-#  define IRQ_SETPOLICY     1	/* manage a slot of the IRQ table */
-#  define IRQ_RMPOLICY      2	/* remove a slot of the IRQ table */
-#  define IRQ_ENABLE        3	/* enable interrupts */
-#  define IRQ_DISABLE       4	/* disable interrupts */
-#  define IRQ_REENABLE  0x001	/* reenable IRQ line after interrupt */
-#  define IRQ_BYTE      0x100	/* byte values */      
-#  define IRQ_WORD      0x200	/* word values */
-#  define IRQ_LONG      0x400	/* long values */
-
-#define CP_FLAG_TRY	0x01	/* do not transparently map */
-
-/* Field names for SYS_GETINFO. */
-#   define GET_KINFO	   0	/* get kernel information structure */
-#   define GET_IMAGE	   1	/* get system image table */
-#   define GET_PROCTAB	   2	/* get kernel process table */
-#   define GET_RANDOMNESS  3	/* get randomness buffer */
-#   define GET_MONPARAMS   4	/* get monitor parameters */
-#   define GET_KENV	   5	/* get kernel environment string */
-#   define GET_IRQHOOKS	   6	/* get the IRQ table */
-#   define GET_PRIVTAB	   8	/* get kernel privileges table */
-#   define GET_KADDRESSES  9	/* get various kernel addresses */
-#   define GET_SCHEDINFO  10	/* get scheduling queues */
-#   define GET_PROC 	  11	/* get process slot if given process */
-#   define GET_MACHINE 	  12	/* get machine information */
-#   define GET_LOCKTIMING 13	/* get lock()/unlock() latency timing */
-#   define GET_BIOSBUFFER 14	/* get a buffer for BIOS calls */
-#   define GET_LOADINFO   15	/* get load average information */
-#   define GET_IRQACTIDS  16	/* get the IRQ masks */
-#   define GET_PRIV	  17	/* get privilege structure */
-#   define GET_HZ	  18	/* get HZ value */
-#   define GET_WHOAMI	  19	/* get own name, endpoint, and privileges */
-#   define GET_RANDOMNESS_BIN 20 /* get one randomness bin */
-#   define GET_IDLETSC	  21	/* get cumulative idle time stamp counter */
-#   define GET_CPUINFO    23    /* get information about cpus */
-#   define GET_REGS	  24	/* get general process registers */
-#   define GET_RUSAGE	  25	/* get resource usage */
-
-/* Subfunctions for SYS_PRIVCTL */
-#define SYS_PRIV_ALLOW		1	/* Allow process to run */
-#define SYS_PRIV_DISALLOW	2	/* Disallow process to run */
-#define SYS_PRIV_SET_SYS	3	/* Set a system privilege structure */
-#define SYS_PRIV_SET_USER	4	/* Set a user privilege structure */
-#define SYS_PRIV_ADD_IO 	5	/* Add I/O range (struct io_range) */
-#define SYS_PRIV_ADD_MEM	6	/* Add memory range (struct mem_range)
-					 */
-#define SYS_PRIV_ADD_IRQ	7	/* Add IRQ */
-#define SYS_PRIV_QUERY_MEM	8	/* Verify memory privilege. */
-#define SYS_PRIV_UPDATE_SYS	9	/* Update a sys privilege structure. */
-#define SYS_PRIV_YIELD	       10	/* Allow process to run and suspend */
-
-/* Constants for exec. FIXME: these do not belong here. */
-#define PMEF_AUXVECTORS	20
-#define PMEF_EXECNAMELEN1 PATH_MAX
-
-/* Flags for PR_FORK_FLAGS. */
-#define PFF_VMINHIBIT	0x01	/* Don't schedule until release by VM. */
-
-/* SYS_SAFEMEMSET */
-#define SMS_DST		m2_i1	/* dst endpoint */
-#define SMS_GID		m2_i3	/* grant id */
-#define SMS_OFFSET	m2_l1	/* offset within grant */
-#define SMS_BYTES	m2_l2	/* bytes from offset */
-#define SMS_PATTERN	m2_i2	/* memset() pattern */
-
-/* Field names for SYS_VMCTL. */
-#define SVMCTL_WHO	m1_i1
-#define SVMCTL_PARAM	m1_i2	/* All SYS_VMCTL requests. */
-#define SVMCTL_VALUE	m1_i3
-#define	SVMCTL_MRG_TARGET	m2_i1	/* MEMREQ_GET reply: target process */
-#define	SVMCTL_MRG_ADDR		m2_i2	/* MEMREQ_GET reply: address */
-#define	SVMCTL_MRG_LENGTH	m2_i3	/* MEMREQ_GET reply: length */
-#define	SVMCTL_MRG_FLAG		m2_s1	/* MEMREQ_GET reply: flag */
-#define	SVMCTL_MRG_EP2		m2_l1	/* MEMREQ_GET reply: source process */
-#define	SVMCTL_MRG_ADDR2	m2_l2	/* MEMREQ_GET reply: source address */
-#define SVMCTL_MRG_REQUESTOR	m2_p1	/* MEMREQ_GET reply: requestor */
-#define SVMCTL_MAP_VIR_ADDR	m1_p1
-#define SVMCTL_PTROOT		m1_i3
-#define SVMCTL_PTROOT_V		m1_p1
-
-/* Reply message for VMCTL_KERN_PHYSMAP */
-#define SVMCTL_MAP_FLAGS	m2_i1	/* VMMF_* */
-#define SVMCTL_MAP_PHYS_ADDR	m2_l1
-#define SVMCTL_MAP_PHYS_LEN	m2_l2
-
-#define VMMF_UNCACHED		(1L << 0)
-#define VMMF_USER		(1L << 1)
-#define VMMF_WRITE		(1L << 2)
-#define VMMF_GLO		(1L << 3)
-
-/* Values for SVMCTL_PARAM. */
-#define VMCTL_CLEAR_PAGEFAULT	12
-#define VMCTL_GET_PDBR		13
-#define VMCTL_MEMREQ_GET 	14
-#define VMCTL_MEMREQ_REPLY	15
-#define VMCTL_NOPAGEZERO	18
-#define VMCTL_I386_KERNELLIMIT	19
-#define VMCTL_I386_INVLPG	25
-#define VMCTL_FLUSHTLB		26
-#define VMCTL_KERN_PHYSMAP	27
-#define VMCTL_KERN_MAP_REPLY	28
-#define VMCTL_SETADDRSPACE	29
-#define VMCTL_VMINHIBIT_SET	30
-#define VMCTL_VMINHIBIT_CLEAR	31
-#define VMCTL_CLEARMAPCACHE	32
-#define VMCTL_BOOTINHIBIT_CLEAR	33
-
-/* Codes and field names for SYS_DIAGCTL. */
-#define DIAGCTL_CODE_DIAG	1	/* Print diagnostics. */
-#define DIAGCTL_CODE_STACKTRACE	2	/* Print process stack. */
-#define DIAGCTL_CODE_REGISTER	3	/* Register for diagnostic signals */
-#define DIAGCTL_CODE_UNREGISTER	4	/* Unregister for diagnostic signals */
-#define DIAG_BUFSIZE	(80*25)
-
-/* Field names for SYS_VTIMER. */
-#define VT_WHICH	m2_i1	/* which timer to set/retrieve */
-#  define VT_VIRTUAL        1	/* the ITIMER_VIRTUAL timer */
-#  define VT_PROF           2	/* the ITIMER_PROF timer */
-#define VT_SET		m2_i2	/* 1 for setting a timer, 0 retrieval only */
-#define VT_VALUE	m2_l1	/* new/previous value of the timer */
-#define VT_ENDPT	m2_l2	/* process to set/retrieve the timer for */
-
-/* Field names for SYS_RUNCTL. */
-#define RC_ENDPT	m1_i1	/* which process to stop or resume */
-#define RC_ACTION	m1_i2	/* set or clear stop flag */
-#  define RC_STOP           0	/* stop the process */
-#  define RC_RESUME         1	/* clear the stop flag */
-#define RC_FLAGS	m1_i3	/* request flags */
-#  define RC_DELAY          1	/* delay stop if process is sending */
-
-/* Field names for SYS_UPDATE. */
-#define SYS_UPD_SRC_ENDPT	m1_i1	/* source endpoint */
-#define SYS_UPD_DST_ENDPT	m1_i2	/* destination endpoint */
-
-/* Subfunctions for SYS_STATECTL */
-#define SYS_STATE_CLEAR_IPC_REFS    1	/* clear IPC references */
-
-/* Subfunctions for SYS_SCHEDCTL */
-#  define SCHEDCTL_FLAG_KERNEL	1	/* mark kernel scheduler and remove 
-					 * RTS_NO_QUANTUM; otherwise caller is 
-					 * marked scheduler 
-					 */
-
-/* Field names for SYS_PADCONF */
-#define PADCONF_PADCONF		m2_i1	/* pad to configure */
-#define PADCONF_MASK		m2_i2	/* mask to apply */
-#define PADCONF_VALUE		m2_i3	/* value to write */
-
-/*===========================================================================*
- *                Messages for the Reincarnation Server 		     *
- *===========================================================================*/
-
-#define RS_RQ_BASE		0x700
-
-#define RS_UP		(RS_RQ_BASE + 0)	/* start system service */
-#define RS_DOWN		(RS_RQ_BASE + 1)	/* stop system service */
-#define RS_REFRESH	(RS_RQ_BASE + 2)	/* refresh system service */
-#define RS_RESTART	(RS_RQ_BASE + 3)	/* restart system service */
-#define RS_SHUTDOWN	(RS_RQ_BASE + 4)	/* alert about shutdown */
-#define RS_UPDATE	(RS_RQ_BASE + 5)	/* update system service */
-#define RS_CLONE	(RS_RQ_BASE + 6)	/* clone system service */
-#define RS_EDIT		(RS_RQ_BASE + 7)	/* edit system service */
-
-#define RS_LOOKUP	(RS_RQ_BASE + 8)	/* lookup server name */
-
-#define RS_GETSYSINFO	(RS_RQ_BASE + 9)	/* get system information */
-
-#define RS_INIT 	(RS_RQ_BASE + 20)	/* service init message */
-#define RS_LU_PREPARE	(RS_RQ_BASE + 21)	/* prepare to update message */
-
-/*===========================================================================*
- *                Messages for the Data Store Server			     *
- *===========================================================================*/
-
-#define DS_RQ_BASE		0x800
-
-#define DS_PUBLISH	(DS_RQ_BASE + 0)	/* publish data */
-#define DS_RETRIEVE	(DS_RQ_BASE + 1)	/* retrieve data by name */
-#define DS_SUBSCRIBE	(DS_RQ_BASE + 2)	/* subscribe to data updates */
-#define DS_CHECK	(DS_RQ_BASE + 3)	/* retrieve updated data */
-#define DS_DELETE	(DS_RQ_BASE + 4)	/* delete data */
-#define DS_SNAPSHOT	(DS_RQ_BASE + 5)	/* take a snapshot */
-#define DS_RETRIEVE_LABEL  (DS_RQ_BASE + 6)	/* retrieve label's name */
-#define DS_GETSYSINFO	(DS_RQ_BASE + 7)	/* get system information */
-
-/*===========================================================================*
- *                Messages used between PM and VFS			     *
- *===========================================================================*/
-
-#define VFS_PM_RQ_BASE	0x900
-#define VFS_PM_RS_BASE	0x980
-
-#define IS_VFS_PM_RQ(type) (((type) & ~0x7f) == VFS_PM_RQ_BASE)
-#define IS_VFS_PM_RS(type) (((type) & ~0x7f) == VFS_PM_RS_BASE)
-
-/* Requests from PM to VFS. */
-#define VFS_PM_INIT	(VFS_PM_RQ_BASE + 0)	/* Process table exchange */
-#define VFS_PM_SETUID	(VFS_PM_RQ_BASE + 1)	/* Set new user ID */
-#define VFS_PM_SETGID	(VFS_PM_RQ_BASE + 2)	/* Set group ID */
-#define VFS_PM_SETSID	(VFS_PM_RQ_BASE + 3)	/* Set session leader */
-#define VFS_PM_EXIT	(VFS_PM_RQ_BASE + 4)	/* Process exits */
-#define VFS_PM_DUMPCORE	(VFS_PM_RQ_BASE + 5)	/* Process is to dump core */
-#define VFS_PM_EXEC	(VFS_PM_RQ_BASE + 6)	/* Forwarded exec call */
-#define VFS_PM_FORK	(VFS_PM_RQ_BASE + 7)	/* Newly forked process */
-#define VFS_PM_SRV_FORK	(VFS_PM_RQ_BASE + 8)	/* fork for system services */
-#define VFS_PM_UNPAUSE	(VFS_PM_RQ_BASE + 9)	/* Interrupt process call */
-#define VFS_PM_REBOOT	(VFS_PM_RQ_BASE + 10)	/* System reboot */
-#define VFS_PM_SETGROUPS	(VFS_PM_RQ_BASE + 11)	/* Set groups */
-
-/* Replies from VFS to PM */
-#define VFS_PM_SETUID_REPLY	(VFS_PM_RS_BASE + 1)
-#define VFS_PM_SETGID_REPLY	(VFS_PM_RS_BASE + 2)
-#define VFS_PM_SETSID_REPLY	(VFS_PM_RS_BASE + 3)
-#define VFS_PM_EXIT_REPLY	(VFS_PM_RS_BASE + 4)
-#define VFS_PM_CORE_REPLY	(VFS_PM_RS_BASE + 5)
-#define VFS_PM_EXEC_REPLY	(VFS_PM_RS_BASE + 6)
-#define VFS_PM_FORK_REPLY	(VFS_PM_RS_BASE + 7)
-#define VFS_PM_SRV_FORK_REPLY	(VFS_PM_RS_BASE + 8)
-#define VFS_PM_UNPAUSE_REPLY	(VFS_PM_RS_BASE + 9)
-#define VFS_PM_REBOOT_REPLY	(VFS_PM_RS_BASE + 10)
-#define VFS_PM_SETGROUPS_REPLY	(VFS_PM_RS_BASE + 11)
-
-/* Standard parameters for all requests and replies, except PM_REBOOT */
-#  define VFS_PM_ENDPT		m7_i1	/* process endpoint */
-
-/* Additional parameters for PM_INIT */
-#  define VFS_PM_SLOT		m7_i2	/* process slot number */
-#  define VFS_PM_PID		m7_i3	/* process pid */
-
-/* Additional parameters for PM_SETUID and PM_SETGID */
-#  define VFS_PM_EID		m7_i2	/* effective user/group id */
-#  define VFS_PM_RID		m7_i3	/* real user/group id */
-
-/* Additional parameter for PM_SETGROUPS */
-#  define VFS_PM_GROUP_NO	m7_i2	/* number of groups */
-#  define VFS_PM_GROUP_ADDR	m7_p1	/* struct holding group data */
-
-/* Additional parameters for PM_EXEC */
-#  define VFS_PM_PATH		m7_p1	/* executable */
-#  define VFS_PM_PATH_LEN	m7_i2	/* length of path including
-					 * terminating null character
-					 */
-#  define VFS_PM_FRAME		m7_p2	/* arguments and environment */
-#  define VFS_PM_FRAME_LEN	m7_i3	/* size of frame */
-#  define VFS_PM_PS_STR		m7_i5	/* ps_strings pointer */
-
-/* Additional parameters for PM_EXEC_REPLY and PM_CORE_REPLY */
-#  define VFS_PM_STATUS		m7_i2	/* OK or failure */
-#  define VFS_PM_PC		m7_p1	/* program counter */
-#  define VFS_PM_NEWSP		m7_p2	/* possibly-changed stack ptr */
-#  define VFS_PM_NEWPS_STR	m7_i5	/* possibly-changed ps_strings ptr */
-
-/* Additional parameters for PM_FORK and PM_SRV_FORK */
-#  define VFS_PM_PENDPT		m7_i2	/* parent process endpoint */
-#  define VFS_PM_CPID		m7_i3	/* child pid */
-#  define VFS_PM_REUID		m7_i4	/* real and effective uid */
-#  define VFS_PM_REGID		m7_i5	/* real and effective gid */
-
-/* Additional parameters for PM_DUMPCORE */
-#  define VFS_PM_TERM_SIG	m7_i2	/* process's termination signal */
-
-/*===========================================================================*
- *                Messages used from VFS to file servers		     *
- *===========================================================================*/
-
-#define FS_BASE		0xA00		/* Requests sent by VFS to filesystem
-					 * implementations. See <minix/vfsif.h>
-					 */
-
-/*===========================================================================*
- *                Common requests and miscellaneous field names		     *
- *===========================================================================*/
-
-#define COMMON_RQ_BASE		0xE00
-
-/* Field names for system signals (sent by a signal manager). */
-#define SIGS_SIGNAL_RECEIVED (COMMON_RQ_BASE+0)
-
-/* Common request to all processes: gcov data. */
-#define COMMON_REQ_GCOV_DATA (COMMON_RQ_BASE+1)
-
-/* Common fault injection ctl request to all processes. */
-#define COMMON_REQ_FI_CTL (COMMON_RQ_BASE+2)
-
-/*===========================================================================*
- *                Messages for VM server				     *
- *===========================================================================*/
-#define VM_RQ_BASE		0xC00
-
-/* Calls from PM */
-#define VM_EXIT			(VM_RQ_BASE+0)
-#	define VME_ENDPOINT		m1_i1
-#define VM_FORK			(VM_RQ_BASE+1)
-#	define VMF_ENDPOINT		m1_i1
-#	define VMF_SLOTNO		m1_i2
-#	define VMF_CHILD_ENDPOINT	m1_i3	/* result */
-#define VM_BRK			(VM_RQ_BASE+2)
-#define VM_EXEC_NEWMEM		(VM_RQ_BASE+3)
-#	define VMEN_ENDPOINT		m1_i1
-#	define VMEN_ARGSPTR		m1_p1
-#	define VMEN_ARGSSIZE		m1_i2
-#	define VMEN_FLAGS		m1_i3	/* result */
-#	define VMEN_STACK_TOP		m1_p2	/* result */
-#define VM_WILLEXIT		(VM_RQ_BASE+5)
-#	define VMWE_ENDPOINT		m1_i1
-
-/* General calls. */
-#define VM_MMAP			(VM_RQ_BASE+10)
-
-#define VM_MUNMAP		(VM_RQ_BASE+17)
-#	define VMUM_ADDR		m_mmap.addr
-#	define VMUM_LEN			m_mmap.len
-
-/* to VM: inform VM about a region of memory that is used for
- * bus-master DMA
- */
-#define VM_ADDDMA	(VM_RQ_BASE+12)
-#	define VMAD_EP			m2_i1
-#	define VMAD_START		m2_l1
-#	define VMAD_SIZE		m2_l2
-
-/* to VM: inform VM that a region of memory that is no longer
- * used for bus-master DMA
- */
-#define VM_DELDMA       (VM_RQ_BASE+13)
-#	define VMDD_EP			m2_i1
-#	define VMDD_START		m2_l1
-#	define VMDD_SIZE		m2_l2
-
-/* to VM: ask VM for a region of memory that should not
- * be used for bus-master DMA any longer
- */
-#define VM_GETDMA       (VM_RQ_BASE+14)
-#	define VMGD_PROCP		m2_i1
-#	define VMGD_BASEP		m2_l1
-#	define VMGD_SIZEP		m2_l2
-
-#define VM_MAP_PHYS		(VM_RQ_BASE+15)
-
-#define VM_UNMAP_PHYS		(VM_RQ_BASE+16)
-
-/* To VM: map in cache block by FS */
-#define VM_MAPCACHEPAGE		(VM_RQ_BASE+26)
-
-/* To VM: identify cache block in FS */
-#define VM_SETCACHEPAGE		(VM_RQ_BASE+27)
-
-/* To VM: clear all cache blocks for a device */
-#define VM_CLEARCACHE		(VM_RQ_BASE+28)
-
-/* To VFS: fields for request from VM. */
-#	define VFS_VMCALL_REQ		m10_i1
-#	define VFS_VMCALL_FD		m10_i2
-#	define VFS_VMCALL_REQID		m10_i3
-#	define VFS_VMCALL_ENDPOINT	m10_i4
-#	define VFS_VMCALL_OFFSET	m10_ull1
-#	define VFS_VMCALL_LENGTH	m10_l3
-
-/* Request codes to from VM to VFS */
-#define VMVFSREQ_FDLOOKUP		101
-#define VMVFSREQ_FDCLOSE		102
-#define VMVFSREQ_FDIO			103
-
-/* Calls from VFS. */
-#define VM_VFS_REPLY		(VM_RQ_BASE+30)
-#	define VMV_ENDPOINT		m10_i1
-#	define VMV_RESULT		m10_i2
-#	define VMV_REQID		m10_i3
-#	define VMV_DEV			m10_i4
-#	define VMV_INO			m10_l1
-#	define VMV_FD			m10_l2
-#	define VMV_SIZE_PAGES		m10_l3
-
-#define VM_REMAP		(VM_RQ_BASE+33)
-
-#define VM_SHM_UNMAP		(VM_RQ_BASE+34)
-
-#define VM_GETPHYS		(VM_RQ_BASE+35)
-
-#define VM_GETREF		(VM_RQ_BASE+36)
-
-#define VM_RS_SET_PRIV		(VM_RQ_BASE+37)
-#	define VM_RS_NR			m2_i1
-#	define VM_RS_BUF		m2_l1
-#	define VM_RS_SYS		m2_i2
-
-#define VM_QUERY_EXIT		(VM_RQ_BASE+38)
-
-#define VM_NOTIFY_SIG		(VM_RQ_BASE+39)
-#	define VM_NOTIFY_SIG_ENDPOINT	m1_i1
-#	define VM_NOTIFY_SIG_IPC	m1_i2
-
-#define VM_INFO			(VM_RQ_BASE+40)
-
-/* VM_INFO 'what' values. */
-#define VMIW_STATS			1
-#define VMIW_USAGE			2
-#define VMIW_REGION			3
-
-#define VM_RS_UPDATE		(VM_RQ_BASE+41)
-
-#define VM_RS_MEMCTL		(VM_RQ_BASE+42)
-#	define VM_RS_CTL_ENDPT		m1_i1
-#	define VM_RS_CTL_REQ		m1_i2
-#		define VM_RS_MEM_PIN	    0	/* pin memory */
-#		define VM_RS_MEM_MAKE_VM    1	/* make VM instance */
-
-#define VM_WATCH_EXIT		(VM_RQ_BASE+43)
-
-#define VM_REMAP_RO		(VM_RQ_BASE+44)
-/* same args as VM_REMAP */
-
-#define VM_PROCCTL		(VM_RQ_BASE+45)
-#define VMPCTL_PARAM		m9_l1
-#define VMPCTL_WHO		m9_l2
-#define VMPCTL_M1		m9_l3
-#define VMPCTL_LEN		m9_l4
-#define VMPCTL_FLAGS		m9_l5
-
-#define VMPPARAM_CLEAR		1	/* values for VMPCTL_PARAM */
-#define VMPPARAM_HANDLEMEM	2
-
-#define VM_VFS_MMAP             (VM_RQ_BASE+46)
-
-#define VM_GETRUSAGE		(VM_RQ_BASE+47)
-
-/* Total. */
-#define NR_VM_CALLS				48
-#define VM_CALL_MASK_SIZE			BITMAP_CHUNKS(NR_VM_CALLS)
-
-/* not handled as a normal VM call, thus at the end of the reserved rage */
-#define VM_PAGEFAULT		(VM_RQ_BASE+0xff)
-#	define VPF_ADDR		m1_i1
-#	define VPF_FLAGS	m1_i2
-
-/* Basic vm calls allowed to every process. */
-#define VM_BASIC_CALLS \
-    VM_BRK, VM_MMAP, VM_MUNMAP, VM_MAP_PHYS, VM_UNMAP_PHYS, VM_INFO, \
-    VM_GETRUSAGE
-
-/*===========================================================================*
- *                Messages for IPC server				     *
- *===========================================================================*/
-#define IPC_BASE	0xD00
-
-/* Shared Memory */
-#define IPC_SHMGET	(IPC_BASE+1)
-#define IPC_SHMAT	(IPC_BASE+2)
-#define IPC_SHMDT	(IPC_BASE+3)
-#define IPC_SHMCTL	(IPC_BASE+4)
-
-/* Semaphore */
-#define IPC_SEMGET	(IPC_BASE+5)
-#define IPC_SEMCTL	(IPC_BASE+6)
-#define IPC_SEMOP	(IPC_BASE+7)
-
-/*===========================================================================*
- *                Messages for Scheduling				     *
- *===========================================================================*/
-#define SCHEDULING_BASE	0xF00
-
-#define SCHEDULING_NO_QUANTUM	(SCHEDULING_BASE+1)
-#define SCHEDULING_START	(SCHEDULING_BASE+2)
-#define SCHEDULING_STOP		(SCHEDULING_BASE+3)
-#define SCHEDULING_SET_NICE	(SCHEDULING_BASE+4)
-#define SCHEDULING_INHERIT	(SCHEDULING_BASE+5)
-
-/*===========================================================================*
- *              Messages for USB                                             *
- *===========================================================================*/
-
-#define USB_BASE 0x1100
-
-/* those are from driver to USBD */
-#define USB_RQ_INIT          (USB_BASE +  0) /* First message to HCD driver */
-#define USB_RQ_DEINIT        (USB_BASE +  1) /* Quit the session */
-#define USB_RQ_SEND_URB      (USB_BASE +  2) /* Send URB */
-#define USB_RQ_CANCEL_URB    (USB_BASE +  3) /* Cancel URB */
-#define USB_RQ_SEND_INFO     (USB_BASE +  4) /* Sends various information */
-#define USB_REPLY            (USB_BASE +  5)
-
-
-/* those are from USBD to driver */
-#define USB_COMPLETE_URB    (USB_BASE +  6)
-#define USB_ANNOUCE_DEV     (USB_BASE +  7) /* Announce a new USB Device */
-#define USB_WITHDRAW_DEV    (USB_BASE +  8) /* Withdraw a allready anncounced
-                                              USB device*/
-#   define USB_GRANT_ID     m4_l1
-#   define USB_GRANT_SIZE   m4_l2
-
-#   define USB_URB_ID       m4_l1
-#   define USB_RESULT       m4_l2
-#   define USB_DEV_ID       m4_l1
-#   define USB_DRIVER_EP    m4_l2
-#   define USB_INTERFACES   m4_l3
-#   define USB_RB_INIT_NAME m3_ca1
-
-#   define USB_INFO_TYPE    m4_l1
-#   define USB_INFO_VALUE   m4_l2
-
-/*===========================================================================*
- *              Messages for DeviceManager (s/t like SysFS)                  *
- *===========================================================================*/
-
-#define DEVMAN_BASE 0x1200
-
-#define DEVMAN_ADD_DEV     (DEVMAN_BASE + 0)
-#define DEVMAN_DEL_DEV     (DEVMAN_BASE + 1)
-#define DEVMAN_ADD_BUS     (DEVMAN_BASE + 2)
-#define DEVMAN_DEL_BUS     (DEVMAN_BASE + 3)
-#define DEVMAN_ADD_DEVFILE (DEVMAN_BASE + 4)
-#define DEVMAN_DEL_DEVFILE (DEVMAN_BASE + 5)
-
-#define DEVMAN_REQUEST     (DEVMAN_BASE + 6)
-#define DEVMAN_REPLY       (DEVMAN_BASE + 7)
-
-#define DEVMAN_BIND        (DEVMAN_BASE + 8)
-#define DEVMAN_UNBIND      (DEVMAN_BASE + 9)
-
-#   define DEVMAN_GRANT_ID       m4_l1
-#   define DEVMAN_GRANT_SIZE     m4_l2
-
-#   define DEVMAN_ENDPOINT       m4_l3
-#   define DEVMAN_DEVICE_ID      m4_l2
-#   define DEVMAN_RESULT         m4_l1
-
-/*===========================================================================*
- *			Messages for TTY				     *
- *===========================================================================*/
-
-#define TTY_RQ_BASE 0x1300
-
-#define TTY_FKEY_CONTROL	(TTY_RQ_BASE + 1) /* control an F-key at TTY */
-#  define    FKEY_MAP		10	/* observe function key */
-#  define    FKEY_UNMAP		11	/* stop observing function key */
-#  define    FKEY_EVENTS	12	/* request open key presses */
-
-#define TTY_INPUT_UP		(TTY_RQ_BASE + 2) /* input server is up */
-#define TTY_INPUT_EVENT		(TTY_RQ_BASE + 3) /* relayed input event */
-
-/*===========================================================================*
- *			Messages for input server and drivers		     *
- *===========================================================================*/
-
-/* The input protocol has no real replies. All messages are one-way. */
-#define INPUT_RQ_BASE 0x1500	/* from TTY to server, or server to driver */
-#define INPUT_RS_BASE 0x1580	/* from input driver to input server */
-
-#define INPUT_CONF		(INPUT_RQ_BASE + 0)	/* configure driver */
-#define INPUT_SETLEDS		(INPUT_RQ_BASE + 1)	/* set keyboard LEDs */
-
-#define INPUT_EVENT		(INPUT_RS_BASE + 0)	/* send input event */
-
-/*===========================================================================*
- *			VFS-FS TRANSACTION IDs				     *
- *===========================================================================*/
-
-#define VFS_TRANSACTION_BASE 0xB00
-
-#define VFS_TRANSID	(VFS_TRANSACTION_BASE + 1)
-#define IS_VFS_FS_TRANSID(type) (((type) & ~0xff) == VFS_TRANSACTION_BASE)
-
-/*===========================================================================*
- *			Messages for character devices			     *
- *===========================================================================*/
-
-/* Base type for character device requests and responses. */
-#define CDEV_RQ_BASE	0x400
-#define CDEV_RS_BASE	0x480
-
-#define IS_CDEV_RQ(type) (((type) & ~0x7f) == CDEV_RQ_BASE)
-#define IS_CDEV_RS(type) (((type) & ~0x7f) == CDEV_RS_BASE)
-
-/* Message types for character device requests. */
-#define CDEV_OPEN	(CDEV_RQ_BASE + 0)	/* open a minor device */
-#define CDEV_CLOSE	(CDEV_RQ_BASE + 1)	/* close a minor device */
-#define CDEV_READ	(CDEV_RQ_BASE + 2)	/* read into a buffer */
-#define CDEV_WRITE	(CDEV_RQ_BASE + 3)	/* write from a buffer */
-#define CDEV_IOCTL	(CDEV_RQ_BASE + 4)	/* I/O control operation */
-#define CDEV_CANCEL	(CDEV_RQ_BASE + 5)	/* cancel suspended request */
-#define CDEV_SELECT	(CDEV_RQ_BASE + 6)	/* test for ready operations */
-
-/* Message types for character device responses. */
-#define CDEV_REPLY	(CDEV_RS_BASE + 0)	/* general reply code */
-#define CDEV_SEL1_REPLY	(CDEV_RS_BASE + 1)	/* immediate select reply */
-#define CDEV_SEL2_REPLY	(CDEV_RS_BASE + 2)	/* select notification reply */
-
-/* Bits in 'CDEV_ACCESS' field of block device open requests. */
-#  define CDEV_R_BIT		0x01	/* open with read access */
-#  define CDEV_W_BIT		0x02	/* open with write access */
-#  define CDEV_NOCTTY		0x04	/* not to become the controlling TTY */
-
-/* Bits in 'CDEV_FLAGS' field of block device transfer requests. */
-#  define CDEV_NOFLAGS		0x00	/* no flags are set */
-#  define CDEV_NONBLOCK		0x01	/* do not suspend I/O request */
-
-/* Bits in 'CDEV_OPS', 'CDEV_STATUS' fields of block device select messages. */
-#  define CDEV_OP_RD		0x01	/* selected for read operation */
-#  define CDEV_OP_WR		0x02	/* selected for write operation */
-#  define CDEV_OP_ERR		0x04	/* selected for error operation */
-#  define CDEV_NOTIFY		0x08	/* notification requested */
-
-/* Bits in 'CDEV_STATUS' field of block device open responses. */
-#  define CDEV_CLONED		0x20000000	/* device is cloned */
-#  define CDEV_CTTY		0x40000000	/* device is controlling TTY */
-
-/*===========================================================================*
- *			Messages for block devices			     *
- *===========================================================================*/
-
-/* Base type for block device requests and responses. */
-#define BDEV_RQ_BASE	0x500
-#define BDEV_RS_BASE	0x580
-
-#define IS_BDEV_RQ(type) (((type) & ~0x7f) == BDEV_RQ_BASE)
-#define IS_BDEV_RS(type) (((type) & ~0x7f) == BDEV_RS_BASE)
-
-/* Message types for block device requests. */
-#define BDEV_OPEN	(BDEV_RQ_BASE + 0)	/* open a minor device */
-#define BDEV_CLOSE	(BDEV_RQ_BASE + 1)	/* close a minor device */
-#define BDEV_READ	(BDEV_RQ_BASE + 2)	/* read into a buffer */
-#define BDEV_WRITE	(BDEV_RQ_BASE + 3)	/* write from a buffer */
-#define BDEV_GATHER	(BDEV_RQ_BASE + 4)	/* read into a vector */
-#define BDEV_SCATTER	(BDEV_RQ_BASE + 5)	/* write from a vector */
-#define BDEV_IOCTL	(BDEV_RQ_BASE + 6)	/* I/O control operation */
-
-/* Message types for block device responses. */
-#define BDEV_REPLY	(BDEV_RS_BASE + 0)	/* general reply code */
-
-/* Bits in 'BDEV_ACCESS' field of block device open requests. */
-#  define BDEV_R_BIT		0x01	/* open with read access */
-#  define BDEV_W_BIT		0x02	/* open with write access */
-
-/* Bits in 'BDEV_FLAGS' field of block device transfer requests. */
-#  define BDEV_NOFLAGS		0x00	/* no flags are set */
-#  define BDEV_FORCEWRITE	0x01	/* force write to disk immediately */
-#  define BDEV_NOPAGE		0x02	/* eeprom: don't send page address */
-
-/*===========================================================================*
- *			Messages for Real Time Clocks			     *
- *===========================================================================*/
-
-/* Base type for real time clock requests and responses. */
-#define RTCDEV_RQ_BASE	0x1400
-#define RTCDEV_RS_BASE	0x1480
-
-#define IS_RTCDEV_RQ(type) (((type) & ~0x7f) == RTCDEV_RQ_BASE)
-#define IS_RTCDEV_RS(type) (((type) & ~0x7f) == RTCDEV_RS_BASE)
-
-/* Message types for real time clock requests. */
-#define RTCDEV_GET_TIME	(RTCDEV_RQ_BASE + 0)	/* get time from hw clock */
-#define RTCDEV_SET_TIME	(RTCDEV_RQ_BASE + 1)	/* set time in hw clock */
-#define RTCDEV_PWR_OFF	(RTCDEV_RQ_BASE + 2)	/* set time to cut the power */
-
-/* Same as GET/SET above but using grants */
-#define RTCDEV_GET_TIME_G (RTCDEV_RQ_BASE + 3)	/* get time from hw clock */
-#define RTCDEV_SET_TIME_G (RTCDEV_RQ_BASE + 4)	/* set time in hw clock */
-
-/* Message types for real time clock responses. */
-#define RTCDEV_REPLY	(RTCDEV_RS_BASE + 0)	/* general reply code */
-
-/* Bits in 'lc_readclock_rtcdev.flags' field of real time clock requests. */
-#define RTCDEV_NOFLAGS	0x00	/* no flags are set */
-#define RTCDEV_Y2KBUG	0x01	/* Interpret 1980 as 2000 for RTC w/Y2K bug */
-#define RTCDEV_CMOSREG	0x02	/* Also set the CMOS clock register bits. */
-
-/*===========================================================================*
- *		Internal codes used by several services			     *
- *===========================================================================*/
-
-#define SUSPEND 	 -998 	/* status to suspend caller, reply later */
-
-#endif /* !_MINIX_COM_H */
+/* This file defines constants for use in message communication (mostly)
+ * between system processes.
+ *
+ * A number of protocol message request and response types are defined. For
+ * debugging purposes, each protocol is assigned its own unique number range.
+ * The following such message type ranges have been allocated:
+ *
+ *     0x00 -   0xFF	Process Manager (PM) requests (see callnr.h)
+ *    0x100 -  0x1FF	Virtual File System (VFS) requests (see callnr.h)
+ *    0x200 -  0x2FF	Data link layer requests and responses
+ *    0x300 -  0x3FF	Bus controller requests and responses
+ *    0x400 -  0x4FF	Character device requests and responses
+ *    0x500 -  0x5FF	Block device requests and responses
+ *    0x600 -  0x6FF	Kernel calls
+ *    0x700 -  0x7FF	Reincarnation Server (RS) requests
+ *    0x800 -  0x8FF	Data Store (DS) requests
+ *    0x900 -  0x9FF	Requests from PM to VFS, and responses
+ *    0xA00 -  0xAFF	Requests from VFS to file systems (see vfsif.h)
+ *    0xB00 -  0xBFF	Transaction IDs from VFS to file systems (see vfsif.h)
+ *    0xC00 -  0xCFF	Virtual Memory (VM) requests
+ *    0xD00 -  0xDFF	IPC server requests
+ *    0xE00 -  0xEFF	Common system messages (e.g. system signals)
+ *    0xF00 -  0xFFF	Scheduling messages
+ *   0x1000 - 0x10FF	Notify messages
+ *   0x1100 - 0x11FF	USB  
+ *   0x1200 - 0x12FF	Devman
+ *   0x1300 - 0x13FF	TTY requests
+ *   0x1400 - 0x14FF	Real Time Clock requests and responses
+ *   0x1500 - 0x15FF	Input server messages
+ *   0x1600 - 0x16FF	VirtualBox (VBOX) requests (see vboxif.h)
+ 	 0x1700 - 0x17ff    sched_rr
+ 	 0x1800 - 0x18ff    sched_fcfs
+ *
+ * Zero and negative values are widely used for OK and error responses.
+ */
+
+#ifndef _MINIX_COM_H
+#define _MINIX_COM_H 
+
+/*===========================================================================*
+ *            	Process numbers of processes in the system image	     *
+ *===========================================================================*/
+
+/* Kernel tasks. These all run in the same address space. */
+#define ASYNCM	((endpoint_t) -5) /* notifies about finished async sends */
+#define IDLE    ((endpoint_t) -4) /* runs when no one else can run */
+#define CLOCK  	((endpoint_t) -3) /* alarms and other clock functions */
+#define SYSTEM  ((endpoint_t) -2) /* request system functionality */
+#define KERNEL  ((endpoint_t) -1) /* pseudo-process for IPC and scheduling */
+#define HARDWARE     KERNEL	/* for hardware interrupt handlers */
+
+/* Number of tasks. Note that NR_PROCS is defined in <minix/config.h>. */
+#define MAX_NR_TASKS	1023
+#define NR_TASKS	  5 
+
+/* User-space processes, that is, device drivers, servers, and INIT. */
+#define PM_PROC_NR   ((endpoint_t) 0)	/* process manager */
+#define VFS_PROC_NR  ((endpoint_t) 1)	/* file system */
+#define RS_PROC_NR   ((endpoint_t) 2)  	/* reincarnation server */
+#define MEM_PROC_NR  ((endpoint_t) 3)  	/* memory driver (RAM disk, null, etc.) */
+#define SCHED_PROC_NR ((endpoint_t) 4)	/* scheduler */
+#define TTY_PROC_NR  ((endpoint_t) 5)	/* terminal (TTY) driver */
+#define DS_PROC_NR   ((endpoint_t) 6)   /* data store server */
+#define MFS_PROC_NR  ((endpoint_t) 7)   /* minix root filesystem */
+#define VM_PROC_NR   ((endpoint_t) 8)   /* memory server */
+#define PFS_PROC_NR  ((endpoint_t) 9)  /* pipe filesystem */
+#define SCHED_RR_PROC_NR ((endpoint_t) 10)	/* scheduler */
+#define SCHED_FCFS_PROC_NR ((endpoint_t) 11)	/* scheduler */
+#define LAST_SPECIAL_PROC_NR	12	/* An untyped version for
+         	                                 computation in macros.*/
+#define INIT_PROC_NR ((endpoint_t) LAST_SPECIAL_PROC_NR)  /* init
+                                                        -- goes multiuser */
+#define NR_BOOT_MODULES (INIT_PROC_NR+1)
+
+/* Root system process and root user process. */
+#define ROOT_SYS_PROC_NR  RS_PROC_NR
+#define ROOT_USR_PROC_NR  INIT_PROC_NR
+
+/*===========================================================================*
+ *                	   Kernel notification types                         *
+ *===========================================================================*/
+
+/* Kernel notification types. In principle, these can be sent to any process,
+ * so make sure that these types do not interfere with other message types.
+ * Notifications are prioritized because of the way they are unhold() and
+ * blocking notifications are delivered. The lowest numbers go first. The
+ * offset are used for the per-process notification bit maps. 
+ */
+#define NOTIFY_MESSAGE		  0x1000
+/* FIXME the old is_notify(a) should be replaced by is_ipc_notify(status). */
+#define is_ipc_notify(ipc_status) (IPC_STATUS_CALL(ipc_status) == NOTIFY)
+#define is_notify(a)		  ((unsigned) ((a) - NOTIFY_MESSAGE) < 0x100)
+#define is_ipc_asynch(ipc_status) \
+    (is_ipc_notify(ipc_status) || IPC_STATUS_CALL(ipc_status) == SENDA)
+
+/*===========================================================================*
+ *                Messages for BUS controller drivers 			     *
+ *===========================================================================*/
+#define BUSC_RQ_BASE	0x300	/* base for request types */
+#define BUSC_RS_BASE	0x380	/* base for response types */
+
+#define BUSC_PCI_INIT		(BUSC_RQ_BASE + 0)	/* First message to
+							 * PCI driver
+							 */
+#define BUSC_PCI_FIRST_DEV	(BUSC_RQ_BASE + 1)	/* Get index (and
+							 * vid/did) of the
+							 * first PCI device
+							 */
+#define BUSC_PCI_NEXT_DEV	(BUSC_RQ_BASE + 2)	/* Get index (and
+							 * vid/did) of the
+							 * next PCI device
+							 */
+#define BUSC_PCI_FIND_DEV	(BUSC_RQ_BASE + 3)	/* Get index of a
+							 * PCI device based on
+							 * bus/dev/function
+							 */
+#define BUSC_PCI_IDS		(BUSC_RQ_BASE + 4)	/* Get vid/did from an
+							 * index
+							 */
+#define BUSC_PCI_RESERVE	(BUSC_RQ_BASE + 7)	/* Reserve a PCI dev */
+#define BUSC_PCI_ATTR_R8	(BUSC_RQ_BASE + 8)	/* Read 8-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_R16	(BUSC_RQ_BASE + 9)	/* Read 16-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_R32	(BUSC_RQ_BASE + 10)	/* Read 32-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W8	(BUSC_RQ_BASE + 11)	/* Write 8-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W16	(BUSC_RQ_BASE + 12)	/* Write 16-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W32	(BUSC_RQ_BASE + 13)	/* Write 32-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_RESCAN		(BUSC_RQ_BASE + 14)	/* Rescan bus */
+#define BUSC_PCI_DEV_NAME_S	(BUSC_RQ_BASE + 15)	/* Get the name of a
+							 * PCI device
+							 * (safecopy)
+							 */
+#define BUSC_PCI_SLOT_NAME_S	(BUSC_RQ_BASE + 16)	/* Get the name of a
+							 * PCI slot (safecopy)
+							 */
+#define BUSC_PCI_SET_ACL	(BUSC_RQ_BASE + 17)	/* Set the ACL for a
+							 * driver (safecopy)
+							 */
+#define BUSC_PCI_DEL_ACL	(BUSC_RQ_BASE + 18)	/* Delete the ACL of a
+							 * driver 
+							 */
+#define BUSC_PCI_GET_BAR	(BUSC_RQ_BASE + 19)	/* Get Base Address
+							 * Register properties
+							 */
+#define IOMMU_MAP		(BUSC_RQ_BASE + 32)	/* Ask IOMMU to map
+							 * a segment of memory
+							 */
+
+#define BUSC_I2C_RESERVE	(BUSC_RQ_BASE + 64)	/* reserve i2c device */
+#define BUSC_I2C_EXEC		(BUSC_RQ_BASE + 65)	/* perform i2c action */
+
+/*===========================================================================*
+ *                  	   Messages for networking layer		     *
+ *===========================================================================*/
+
+/* Base type for data link layer requests and responses. */
+#define DL_RQ_BASE	0x200		
+#define DL_RS_BASE	0x280		
+
+#define IS_DL_RQ(type) (((type) & ~0x7f) == DL_RQ_BASE)
+#define IS_DL_RS(type) (((type) & ~0x7f) == DL_RS_BASE)
+
+/* Message types for data link layer requests. */
+#define DL_CONF		(DL_RQ_BASE + 0)
+#define DL_GETSTAT_S	(DL_RQ_BASE + 1)
+#define DL_WRITEV_S	(DL_RQ_BASE + 2)
+#define DL_READV_S	(DL_RQ_BASE + 3)
+
+/* Message type for data link layer replies. */
+#define DL_CONF_REPLY	(DL_RS_BASE + 0)
+#define DL_STAT_REPLY	(DL_RS_BASE + 1)
+#define DL_TASK_REPLY	(DL_RS_BASE + 2)
+
+/* Bits in 'flags' field of DL replies. */
+#  define DL_NOFLAGS		0x00
+#  define DL_PACK_SEND		0x01
+#  define DL_PACK_RECV		0x02
+
+/* Bits in 'DL_MODE' field of DL requests. */
+#  define DL_NOMODE		0x0
+#  define DL_PROMISC_REQ	0x1
+#  define DL_MULTI_REQ		0x2
+#  define DL_BROAD_REQ		0x4
+
+/*===========================================================================*
+ *                  SYSTASK request types and field names                    *
+ *===========================================================================*/
+
+/* System library calls are dispatched via a call vector, so be careful when 
+ * modifying the system call numbers. The numbers here determine which call
+ * is made from the call vector.
+ */ 
+#define KERNEL_CALL	0x600	/* base for kernel calls to SYSTEM */ 
+
+#  define SYS_FORK       (KERNEL_CALL + 0)	/* sys_fork() */
+#  define SYS_EXEC       (KERNEL_CALL + 1)	/* sys_exec() */
+#  define SYS_CLEAR	 (KERNEL_CALL + 2)	/* sys_clear() */
+#  define SYS_SCHEDULE 	 (KERNEL_CALL + 3)	/* sys_schedule() */
+#  define SYS_PRIVCTL    (KERNEL_CALL + 4)	/* sys_privctl() */
+#  define SYS_TRACE      (KERNEL_CALL + 5)	/* sys_trace() */
+#  define SYS_KILL       (KERNEL_CALL + 6)	/* sys_kill() */
+
+#  define SYS_GETKSIG    (KERNEL_CALL + 7)	/* sys_getsig() */
+#  define SYS_ENDKSIG    (KERNEL_CALL + 8)	/* sys_endsig() */
+#  define SYS_SIGSEND    (KERNEL_CALL + 9)	/* sys_sigsend() */
+#  define SYS_SIGRETURN  (KERNEL_CALL + 10)	/* sys_sigreturn() */
+
+#  define SYS_MEMSET     (KERNEL_CALL + 13)	/* sys_memset() */
+
+#  define SYS_UMAP       (KERNEL_CALL + 14)	/* sys_umap() */
+#  define SYS_VIRCOPY    (KERNEL_CALL + 15)	/* sys_vircopy() */
+#  define SYS_PHYSCOPY   (KERNEL_CALL + 16) 	/* sys_physcopy() */
+#  define SYS_UMAP_REMOTE (KERNEL_CALL + 17)	/* sys_umap_remote() */
+#  define SYS_VUMAP      (KERNEL_CALL + 18)	/* sys_vumap() */
+
+#  define SYS_IRQCTL     (KERNEL_CALL + 19)	/* sys_irqctl() */
+#  define SYS_INT86      (KERNEL_CALL + 20)	/* sys_int86() */
+#  define SYS_DEVIO      (KERNEL_CALL + 21)	/* sys_devio() */
+#  define SYS_SDEVIO     (KERNEL_CALL + 22)	/* sys_sdevio() */
+#  define SYS_VDEVIO     (KERNEL_CALL + 23)	/* sys_vdevio() */
+
+#  define SYS_SETALARM	 (KERNEL_CALL + 24)	/* sys_setalarm() */
+#  define SYS_TIMES	 (KERNEL_CALL + 25)	/* sys_times() */
+#  define SYS_GETINFO    (KERNEL_CALL + 26) 	/* sys_getinfo() */
+#  define SYS_ABORT      (KERNEL_CALL + 27)	/* sys_abort() */
+#  define SYS_IOPENABLE  (KERNEL_CALL + 28)	/* sys_enable_iop() */
+#  define SYS_SAFECOPYFROM (KERNEL_CALL + 31)	/* sys_safecopyfrom() */
+#  define SYS_SAFECOPYTO   (KERNEL_CALL + 32)	/* sys_safecopyto() */
+#  define SYS_VSAFECOPY  (KERNEL_CALL + 33)	/* sys_vsafecopy() */
+#  define SYS_SETGRANT   (KERNEL_CALL + 34)	/* sys_setgrant() */
+#  define SYS_READBIOS   (KERNEL_CALL + 35)	/* sys_readbios() */
+
+#  define SYS_SPROF      (KERNEL_CALL + 36)     /* sys_sprof() */ 
+#  define SYS_CPROF      (KERNEL_CALL + 37)     /* sys_cprof() */
+#  define SYS_PROFBUF    (KERNEL_CALL + 38)     /* sys_profbuf() */
+
+#  define SYS_STIME      (KERNEL_CALL + 39)	/* sys_stime() */
+#  define SYS_SETTIME    (KERNEL_CALL + 40)	/* sys_settime() */
+
+#  define SYS_VMCTL      (KERNEL_CALL + 43)	/* sys_vmctl() */
+
+#  define SYS_DIAGCTL    (KERNEL_CALL + 44)	/* sys_diagctl() */
+
+#  define SYS_VTIMER     (KERNEL_CALL + 45)	/* sys_vtimer() */
+#  define SYS_RUNCTL     (KERNEL_CALL + 46)	/* sys_runctl() */
+#  define SYS_GETMCONTEXT (KERNEL_CALL + 50)    /* sys_getmcontext() */
+#  define SYS_SETMCONTEXT (KERNEL_CALL + 51)    /* sys_setmcontext() */
+
+#  define SYS_UPDATE	 (KERNEL_CALL + 52)	/* sys_update() */
+#  define SYS_EXIT	 (KERNEL_CALL + 53)	/* sys_exit() */
+
+#  define SYS_SCHEDCTL (KERNEL_CALL + 54)	/* sys_schedctl() */
+#  define SYS_STATECTL (KERNEL_CALL + 55)	/* sys_statectl() */
+
+#  define SYS_SAFEMEMSET (KERNEL_CALL + 56)	/* sys_safememset() */
+
+#  define SYS_PADCONF (KERNEL_CALL + 57)	/* sys_padconf() */
+
+/* Total */
+#define NR_SYS_CALLS	58	/* number of kernel calls */
+
+#define SYS_CALL_MASK_SIZE BITMAP_CHUNKS(NR_SYS_CALLS)
+
+/* Basic kernel calls allowed to every system process. */
+#define SYS_BASIC_CALLS \
+    SYS_EXIT, SYS_SAFECOPYFROM, SYS_SAFECOPYTO, SYS_VSAFECOPY, SYS_GETINFO, \
+    SYS_TIMES, SYS_SETALARM, SYS_SETGRANT, \
+    SYS_PROFBUF, SYS_DIAGCTL, SYS_STATECTL, SYS_SAFEMEMSET
+
+/* Field names for SYS_DEVIO, SYS_VDEVIO, SYS_SDEVIO. */
+#   define _DIO_INPUT		0x001
+#   define _DIO_OUTPUT		0x002
+#   define _DIO_DIRMASK		0x00f
+#   define _DIO_BYTE		0x010
+#   define _DIO_WORD		0x020
+#   define _DIO_LONG		0x030
+#   define _DIO_TYPEMASK	0x0f0
+#   define _DIO_SAFE		0x100
+#   define _DIO_SAFEMASK	0xf00
+#   define DIO_INPUT_BYTE	    (_DIO_INPUT|_DIO_BYTE)
+#   define DIO_INPUT_WORD	    (_DIO_INPUT|_DIO_WORD)
+#   define DIO_INPUT_LONG	    (_DIO_INPUT|_DIO_LONG)
+#   define DIO_OUTPUT_BYTE	    (_DIO_OUTPUT|_DIO_BYTE)
+#   define DIO_OUTPUT_WORD	    (_DIO_OUTPUT|_DIO_WORD)
+#   define DIO_OUTPUT_LONG	    (_DIO_OUTPUT|_DIO_LONG)
+#   define DIO_SAFE_INPUT_BYTE      (_DIO_INPUT|_DIO_BYTE|_DIO_SAFE)
+#   define DIO_SAFE_INPUT_WORD      (_DIO_INPUT|_DIO_WORD|_DIO_SAFE)
+#   define DIO_SAFE_INPUT_LONG      (_DIO_INPUT|_DIO_LONG|_DIO_SAFE)
+#   define DIO_SAFE_OUTPUT_BYTE     (_DIO_OUTPUT|_DIO_BYTE|_DIO_SAFE)
+#   define DIO_SAFE_OUTPUT_WORD     (_DIO_OUTPUT|_DIO_WORD|_DIO_SAFE)
+#   define DIO_SAFE_OUTPUT_LONG     (_DIO_OUTPUT|_DIO_LONG|_DIO_SAFE)
+
+/* Field names for SYS_IRQCTL. */
+#  define IRQ_SETPOLICY     1	/* manage a slot of the IRQ table */
+#  define IRQ_RMPOLICY      2	/* remove a slot of the IRQ table */
+#  define IRQ_ENABLE        3	/* enable interrupts */
+#  define IRQ_DISABLE       4	/* disable interrupts */
+#  define IRQ_REENABLE  0x001	/* reenable IRQ line after interrupt */
+#  define IRQ_BYTE      0x100	/* byte values */      
+#  define IRQ_WORD      0x200	/* word values */
+#  define IRQ_LONG      0x400	/* long values */
+
+#define CP_FLAG_TRY	0x01	/* do not transparently map */
+
+/* Field names for SYS_GETINFO. */
+#   define GET_KINFO	   0	/* get kernel information structure */
+#   define GET_IMAGE	   1	/* get system image table */
+#   define GET_PROCTAB	   2	/* get kernel process table */
+#   define GET_RANDOMNESS  3	/* get randomness buffer */
+#   define GET_MONPARAMS   4	/* get monitor parameters */
+#   define GET_KENV	   5	/* get kernel environment string */
+#   define GET_IRQHOOKS	   6	/* get the IRQ table */
+#   define GET_PRIVTAB	   8	/* get kernel privileges table */
+#   define GET_KADDRESSES  9	/* get various kernel addresses */
+#   define GET_SCHEDINFO  10	/* get scheduling queues */
+#   define GET_PROC 	  11	/* get process slot if given process */
+#   define GET_MACHINE 	  12	/* get machine information */
+#   define GET_LOCKTIMING 13	/* get lock()/unlock() latency timing */
+#   define GET_BIOSBUFFER 14	/* get a buffer for BIOS calls */
+#   define GET_LOADINFO   15	/* get load average information */
+#   define GET_IRQACTIDS  16	/* get the IRQ masks */
+#   define GET_PRIV	  17	/* get privilege structure */
+#   define GET_HZ	  18	/* get HZ value */
+#   define GET_WHOAMI	  19	/* get own name, endpoint, and privileges */
+#   define GET_RANDOMNESS_BIN 20 /* get one randomness bin */
+#   define GET_IDLETSC	  21	/* get cumulative idle time stamp counter */
+#   define GET_CPUINFO    23    /* get information about cpus */
+#   define GET_REGS	  24	/* get general process registers */
+#   define GET_RUSAGE	  25	/* get resource usage */
+
+/* Subfunctions for SYS_PRIVCTL */
+#define SYS_PRIV_ALLOW		1	/* Allow process to run */
+#define SYS_PRIV_DISALLOW	2	/* Disallow process to run */
+#define SYS_PRIV_SET_SYS	3	/* Set a system privilege structure */
+#define SYS_PRIV_SET_USER	4	/* Set a user privilege structure */
+#define SYS_PRIV_ADD_IO 	5	/* Add I/O range (struct io_range) */
+#define SYS_PRIV_ADD_MEM	6	/* Add memory range (struct mem_range)
+					 */
+#define SYS_PRIV_ADD_IRQ	7	/* Add IRQ */
+#define SYS_PRIV_QUERY_MEM	8	/* Verify memory privilege. */
+#define SYS_PRIV_UPDATE_SYS	9	/* Update a sys privilege structure. */
+#define SYS_PRIV_YIELD	       10	/* Allow process to run and suspend */
+
+/* Constants for exec. FIXME: these do not belong here. */
+#define PMEF_AUXVECTORS	20
+#define PMEF_EXECNAMELEN1 PATH_MAX
+
+/* Flags for PR_FORK_FLAGS. */
+#define PFF_VMINHIBIT	0x01	/* Don't schedule until release by VM. */
+
+/* SYS_SAFEMEMSET */
+#define SMS_DST		m2_i1	/* dst endpoint */
+#define SMS_GID		m2_i3	/* grant id */
+#define SMS_OFFSET	m2_l1	/* offset within grant */
+#define SMS_BYTES	m2_l2	/* bytes from offset */
+#define SMS_PATTERN	m2_i2	/* memset() pattern */
+
+/* Field names for SYS_VMCTL. */
+#define SVMCTL_WHO	m1_i1
+#define SVMCTL_PARAM	m1_i2	/* All SYS_VMCTL requests. */
+#define SVMCTL_VALUE	m1_i3
+#define	SVMCTL_MRG_TARGET	m2_i1	/* MEMREQ_GET reply: target process */
+#define	SVMCTL_MRG_ADDR		m2_i2	/* MEMREQ_GET reply: address */
+#define	SVMCTL_MRG_LENGTH	m2_i3	/* MEMREQ_GET reply: length */
+#define	SVMCTL_MRG_FLAG		m2_s1	/* MEMREQ_GET reply: flag */
+#define	SVMCTL_MRG_EP2		m2_l1	/* MEMREQ_GET reply: source process */
+#define	SVMCTL_MRG_ADDR2	m2_l2	/* MEMREQ_GET reply: source address */
+#define SVMCTL_MRG_REQUESTOR	m2_p1	/* MEMREQ_GET reply: requestor */
+#define SVMCTL_MAP_VIR_ADDR	m1_p1
+#define SVMCTL_PTROOT		m1_i3
+#define SVMCTL_PTROOT_V		m1_p1
+
+/* Reply message for VMCTL_KERN_PHYSMAP */
+#define SVMCTL_MAP_FLAGS	m2_i1	/* VMMF_* */
+#define SVMCTL_MAP_PHYS_ADDR	m2_l1
+#define SVMCTL_MAP_PHYS_LEN	m2_l2
+
+#define VMMF_UNCACHED		(1L << 0)
+#define VMMF_USER		(1L << 1)
+#define VMMF_WRITE		(1L << 2)
+#define VMMF_GLO		(1L << 3)
+
+/* Values for SVMCTL_PARAM. */
+#define VMCTL_CLEAR_PAGEFAULT	12
+#define VMCTL_GET_PDBR		13
+#define VMCTL_MEMREQ_GET 	14
+#define VMCTL_MEMREQ_REPLY	15
+#define VMCTL_NOPAGEZERO	18
+#define VMCTL_I386_KERNELLIMIT	19
+#define VMCTL_I386_INVLPG	25
+#define VMCTL_FLUSHTLB		26
+#define VMCTL_KERN_PHYSMAP	27
+#define VMCTL_KERN_MAP_REPLY	28
+#define VMCTL_SETADDRSPACE	29
+#define VMCTL_VMINHIBIT_SET	30
+#define VMCTL_VMINHIBIT_CLEAR	31
+#define VMCTL_CLEARMAPCACHE	32
+#define VMCTL_BOOTINHIBIT_CLEAR	33
+
+/* Codes and field names for SYS_DIAGCTL. */
+#define DIAGCTL_CODE_DIAG	1	/* Print diagnostics. */
+#define DIAGCTL_CODE_STACKTRACE	2	/* Print process stack. */
+#define DIAGCTL_CODE_REGISTER	3	/* Register for diagnostic signals */
+#define DIAGCTL_CODE_UNREGISTER	4	/* Unregister for diagnostic signals */
+#define DIAG_BUFSIZE	(80*25)
+
+/* Field names for SYS_VTIMER. */
+#define VT_WHICH	m2_i1	/* which timer to set/retrieve */
+#  define VT_VIRTUAL        1	/* the ITIMER_VIRTUAL timer */
+#  define VT_PROF           2	/* the ITIMER_PROF timer */
+#define VT_SET		m2_i2	/* 1 for setting a timer, 0 retrieval only */
+#define VT_VALUE	m2_l1	/* new/previous value of the timer */
+#define VT_ENDPT	m2_l2	/* process to set/retrieve the timer for */
+
+/* Field names for SYS_RUNCTL. */
+#define RC_ENDPT	m1_i1	/* which process to stop or resume */
+#define RC_ACTION	m1_i2	/* set or clear stop flag */
+#  define RC_STOP           0	/* stop the process */
+#  define RC_RESUME         1	/* clear the stop flag */
+#define RC_FLAGS	m1_i3	/* request flags */
+#  define RC_DELAY          1	/* delay stop if process is sending */
+
+/* Field names for SYS_UPDATE. */
+#define SYS_UPD_SRC_ENDPT	m1_i1	/* source endpoint */
+#define SYS_UPD_DST_ENDPT	m1_i2	/* destination endpoint */
+
+/* Subfunctions for SYS_STATECTL */
+#define SYS_STATE_CLEAR_IPC_REFS    1	/* clear IPC references */
+
+/* Subfunctions for SYS_SCHEDCTL */
+#  define SCHEDCTL_FLAG_KERNEL	1	/* mark kernel scheduler and remove 
+					 * RTS_NO_QUANTUM; otherwise caller is 
+					 * marked scheduler 
+					 */
+
+/* Field names for SYS_PADCONF */
+#define PADCONF_PADCONF		m2_i1	/* pad to configure */
+#define PADCONF_MASK		m2_i2	/* mask to apply */
+#define PADCONF_VALUE		m2_i3	/* value to write */
+
+/*===========================================================================*
+ *                Messages for the Reincarnation Server 		     *
+ *===========================================================================*/
+
+#define RS_RQ_BASE		0x700
+
+#define RS_UP		(RS_RQ_BASE + 0)	/* start system service */
+#define RS_DOWN		(RS_RQ_BASE + 1)	/* stop system service */
+#define RS_REFRESH	(RS_RQ_BASE + 2)	/* refresh system service */
+#define RS_RESTART	(RS_RQ_BASE + 3)	/* restart system service */
+#define RS_SHUTDOWN	(RS_RQ_BASE + 4)	/* alert about shutdown */
+#define RS_UPDATE	(RS_RQ_BASE + 5)	/* update system service */
+#define RS_CLONE	(RS_RQ_BASE + 6)	/* clone system service */
+#define RS_EDIT		(RS_RQ_BASE + 7)	/* edit system service */
+
+#define RS_LOOKUP	(RS_RQ_BASE + 8)	/* lookup server name */
+
+#define RS_GETSYSINFO	(RS_RQ_BASE + 9)	/* get system information */
+
+#define RS_INIT 	(RS_RQ_BASE + 20)	/* service init message */
+#define RS_LU_PREPARE	(RS_RQ_BASE + 21)	/* prepare to update message */
+
+/*===========================================================================*
+ *                Messages for the Data Store Server			     *
+ *===========================================================================*/
+
+#define DS_RQ_BASE		0x800
+
+#define DS_PUBLISH	(DS_RQ_BASE + 0)	/* publish data */
+#define DS_RETRIEVE	(DS_RQ_BASE + 1)	/* retrieve data by name */
+#define DS_SUBSCRIBE	(DS_RQ_BASE + 2)	/* subscribe to data updates */
+#define DS_CHECK	(DS_RQ_BASE + 3)	/* retrieve updated data */
+#define DS_DELETE	(DS_RQ_BASE + 4)	/* delete data */
+#define DS_SNAPSHOT	(DS_RQ_BASE + 5)	/* take a snapshot */
+#define DS_RETRIEVE_LABEL  (DS_RQ_BASE + 6)	/* retrieve label's name */
+#define DS_GETSYSINFO	(DS_RQ_BASE + 7)	/* get system information */
+
+/*===========================================================================*
+ *                Messages used between PM and VFS			     *
+ *===========================================================================*/
+
+#define VFS_PM_RQ_BASE	0x900
+#define VFS_PM_RS_BASE	0x980
+
+#define IS_VFS_PM_RQ(type) (((type) & ~0x7f) == VFS_PM_RQ_BASE)
+#define IS_VFS_PM_RS(type) (((type) & ~0x7f) == VFS_PM_RS_BASE)
+
+/* Requests from PM to VFS. */
+#define VFS_PM_INIT	(VFS_PM_RQ_BASE + 0)	/* Process table exchange */
+#define VFS_PM_SETUID	(VFS_PM_RQ_BASE + 1)	/* Set new user ID */
+#define VFS_PM_SETGID	(VFS_PM_RQ_BASE + 2)	/* Set group ID */
+#define VFS_PM_SETSID	(VFS_PM_RQ_BASE + 3)	/* Set session leader */
+#define VFS_PM_EXIT	(VFS_PM_RQ_BASE + 4)	/* Process exits */
+#define VFS_PM_DUMPCORE	(VFS_PM_RQ_BASE + 5)	/* Process is to dump core */
+#define VFS_PM_EXEC	(VFS_PM_RQ_BASE + 6)	/* Forwarded exec call */
+#define VFS_PM_FORK	(VFS_PM_RQ_BASE + 7)	/* Newly forked process */
+#define VFS_PM_SRV_FORK	(VFS_PM_RQ_BASE + 8)	/* fork for system services */
+#define VFS_PM_UNPAUSE	(VFS_PM_RQ_BASE + 9)	/* Interrupt process call */
+#define VFS_PM_REBOOT	(VFS_PM_RQ_BASE + 10)	/* System reboot */
+#define VFS_PM_SETGROUPS	(VFS_PM_RQ_BASE + 11)	/* Set groups */
+
+/* Replies from VFS to PM */
+#define VFS_PM_SETUID_REPLY	(VFS_PM_RS_BASE + 1)
+#define VFS_PM_SETGID_REPLY	(VFS_PM_RS_BASE + 2)
+#define VFS_PM_SETSID_REPLY	(VFS_PM_RS_BASE + 3)
+#define VFS_PM_EXIT_REPLY	(VFS_PM_RS_BASE + 4)
+#define VFS_PM_CORE_REPLY	(VFS_PM_RS_BASE + 5)
+#define VFS_PM_EXEC_REPLY	(VFS_PM_RS_BASE + 6)
+#define VFS_PM_FORK_REPLY	(VFS_PM_RS_BASE + 7)
+#define VFS_PM_SRV_FORK_REPLY	(VFS_PM_RS_BASE + 8)
+#define VFS_PM_UNPAUSE_REPLY	(VFS_PM_RS_BASE + 9)
+#define VFS_PM_REBOOT_REPLY	(VFS_PM_RS_BASE + 10)
+#define VFS_PM_SETGROUPS_REPLY	(VFS_PM_RS_BASE + 11)
+
+/* Standard parameters for all requests and replies, except PM_REBOOT */
+#  define VFS_PM_ENDPT		m7_i1	/* process endpoint */
+
+/* Additional parameters for PM_INIT */
+#  define VFS_PM_SLOT		m7_i2	/* process slot number */
+#  define VFS_PM_PID		m7_i3	/* process pid */
+
+/* Additional parameters for PM_SETUID and PM_SETGID */
+#  define VFS_PM_EID		m7_i2	/* effective user/group id */
+#  define VFS_PM_RID		m7_i3	/* real user/group id */
+
+/* Additional parameter for PM_SETGROUPS */
+#  define VFS_PM_GROUP_NO	m7_i2	/* number of groups */
+#  define VFS_PM_GROUP_ADDR	m7_p1	/* struct holding group data */
+
+/* Additional parameters for PM_EXEC */
+#  define VFS_PM_PATH		m7_p1	/* executable */
+#  define VFS_PM_PATH_LEN	m7_i2	/* length of path including
+					 * terminating null character
+					 */
+#  define VFS_PM_FRAME		m7_p2	/* arguments and environment */
+#  define VFS_PM_FRAME_LEN	m7_i3	/* size of frame */
+#  define VFS_PM_PS_STR		m7_i5	/* ps_strings pointer */
+
+/* Additional parameters for PM_EXEC_REPLY and PM_CORE_REPLY */
+#  define VFS_PM_STATUS		m7_i2	/* OK or failure */
+#  define VFS_PM_PC		m7_p1	/* program counter */
+#  define VFS_PM_NEWSP		m7_p2	/* possibly-changed stack ptr */
+#  define VFS_PM_NEWPS_STR	m7_i5	/* possibly-changed ps_strings ptr */
+
+/* Additional parameters for PM_FORK and PM_SRV_FORK */
+#  define VFS_PM_PENDPT		m7_i2	/* parent process endpoint */
+#  define VFS_PM_CPID		m7_i3	/* child pid */
+#  define VFS_PM_REUID		m7_i4	/* real and effective uid */
+#  define VFS_PM_REGID		m7_i5	/* real and effective gid */
+
+/* Additional parameters for PM_DUMPCORE */
+#  define VFS_PM_TERM_SIG	m7_i2	/* process's termination signal */
+
+/*===========================================================================*
+ *                Messages used from VFS to file servers		     *
+ *===========================================================================*/
+
+#define FS_BASE		0xA00		/* Requests sent by VFS to filesystem
+					 * implementations. See <minix/vfsif.h>
+					 */
+
+/*===========================================================================*
+ *                Common requests and miscellaneous field names		     *
+ *===========================================================================*/
+
+#define COMMON_RQ_BASE		0xE00
+
+/* Field names for system signals (sent by a signal manager). */
+#define SIGS_SIGNAL_RECEIVED (COMMON_RQ_BASE+0)
+
+/* Common request to all processes: gcov data. */
+#define COMMON_REQ_GCOV_DATA (COMMON_RQ_BASE+1)
+
+/* Common fault injection ctl request to all processes. */
+#define COMMON_REQ_FI_CTL (COMMON_RQ_BASE+2)
+
+/*===========================================================================*
+ *                Messages for VM server				     *
+ *===========================================================================*/
+#define VM_RQ_BASE		0xC00
+
+/* Calls from PM */
+#define VM_EXIT			(VM_RQ_BASE+0)
+#	define VME_ENDPOINT		m1_i1
+#define VM_FORK			(VM_RQ_BASE+1)
+#	define VMF_ENDPOINT		m1_i1
+#	define VMF_SLOTNO		m1_i2
+#	define VMF_CHILD_ENDPOINT	m1_i3	/* result */
+#define VM_BRK			(VM_RQ_BASE+2)
+#define VM_EXEC_NEWMEM		(VM_RQ_BASE+3)
+#	define VMEN_ENDPOINT		m1_i1
+#	define VMEN_ARGSPTR		m1_p1
+#	define VMEN_ARGSSIZE		m1_i2
+#	define VMEN_FLAGS		m1_i3	/* result */
+#	define VMEN_STACK_TOP		m1_p2	/* result */
+#define VM_WILLEXIT		(VM_RQ_BASE+5)
+#	define VMWE_ENDPOINT		m1_i1
+
+/* General calls. */
+#define VM_MMAP			(VM_RQ_BASE+10)
+
+#define VM_MUNMAP		(VM_RQ_BASE+17)
+#	define VMUM_ADDR		m_mmap.addr
+#	define VMUM_LEN			m_mmap.len
+
+/* to VM: inform VM about a region of memory that is used for
+ * bus-master DMA
+ */
+#define VM_ADDDMA	(VM_RQ_BASE+12)
+#	define VMAD_EP			m2_i1
+#	define VMAD_START		m2_l1
+#	define VMAD_SIZE		m2_l2
+
+/* to VM: inform VM that a region of memory that is no longer
+ * used for bus-master DMA
+ */
+#define VM_DELDMA       (VM_RQ_BASE+13)
+#	define VMDD_EP			m2_i1
+#	define VMDD_START		m2_l1
+#	define VMDD_SIZE		m2_l2
+
+/* to VM: ask VM for a region of memory that should not
+ * be used for bus-master DMA any longer
+ */
+#define VM_GETDMA       (VM_RQ_BASE+14)
+#	define VMGD_PROCP		m2_i1
+#	define VMGD_BASEP		m2_l1
+#	define VMGD_SIZEP		m2_l2
+
+#define VM_MAP_PHYS		(VM_RQ_BASE+15)
+
+#define VM_UNMAP_PHYS		(VM_RQ_BASE+16)
+
+/* To VM: map in cache block by FS */
+#define VM_MAPCACHEPAGE		(VM_RQ_BASE+26)
+
+/* To VM: identify cache block in FS */
+#define VM_SETCACHEPAGE		(VM_RQ_BASE+27)
+
+/* To VM: clear all cache blocks for a device */
+#define VM_CLEARCACHE		(VM_RQ_BASE+28)
+
+/* To VFS: fields for request from VM. */
+#	define VFS_VMCALL_REQ		m10_i1
+#	define VFS_VMCALL_FD		m10_i2
+#	define VFS_VMCALL_REQID		m10_i3
+#	define VFS_VMCALL_ENDPOINT	m10_i4
+#	define VFS_VMCALL_OFFSET	m10_ull1
+#	define VFS_VMCALL_LENGTH	m10_l3
+
+/* Request codes to from VM to VFS */
+#define VMVFSREQ_FDLOOKUP		101
+#define VMVFSREQ_FDCLOSE		102
+#define VMVFSREQ_FDIO			103
+
+/* Calls from VFS. */
+#define VM_VFS_REPLY		(VM_RQ_BASE+30)
+#	define VMV_ENDPOINT		m10_i1
+#	define VMV_RESULT		m10_i2
+#	define VMV_REQID		m10_i3
+#	define VMV_DEV			m10_i4
+#	define VMV_INO			m10_l1
+#	define VMV_FD			m10_l2
+#	define VMV_SIZE_PAGES		m10_l3
+
+#define VM_REMAP		(VM_RQ_BASE+33)
+
+#define VM_SHM_UNMAP		(VM_RQ_BASE+34)
+
+#define VM_GETPHYS		(VM_RQ_BASE+35)
+
+#define VM_GETREF		(VM_RQ_BASE+36)
+
+#define VM_RS_SET_PRIV		(VM_RQ_BASE+37)
+#	define VM_RS_NR			m2_i1
+#	define VM_RS_BUF		m2_l1
+#	define VM_RS_SYS		m2_i2
+
+#define VM_QUERY_EXIT		(VM_RQ_BASE+38)
+
+#define VM_NOTIFY_SIG		(VM_RQ_BASE+39)
+#	define VM_NOTIFY_SIG_ENDPOINT	m1_i1
+#	define VM_NOTIFY_SIG_IPC	m1_i2
+
+#define VM_INFO			(VM_RQ_BASE+40)
+
+/* VM_INFO 'what' values. */
+#define VMIW_STATS			1
+#define VMIW_USAGE			2
+#define VMIW_REGION			3
+
+#define VM_RS_UPDATE		(VM_RQ_BASE+41)
+
+#define VM_RS_MEMCTL		(VM_RQ_BASE+42)
+#	define VM_RS_CTL_ENDPT		m1_i1
+#	define VM_RS_CTL_REQ		m1_i2
+#		define VM_RS_MEM_PIN	    0	/* pin memory */
+#		define VM_RS_MEM_MAKE_VM    1	/* make VM instance */
+
+#define VM_WATCH_EXIT		(VM_RQ_BASE+43)
+
+#define VM_REMAP_RO		(VM_RQ_BASE+44)
+/* same args as VM_REMAP */
+
+#define VM_PROCCTL		(VM_RQ_BASE+45)
+#define VMPCTL_PARAM		m9_l1
+#define VMPCTL_WHO		m9_l2
+#define VMPCTL_M1		m9_l3
+#define VMPCTL_LEN		m9_l4
+#define VMPCTL_FLAGS		m9_l5
+
+#define VMPPARAM_CLEAR		1	/* values for VMPCTL_PARAM */
+#define VMPPARAM_HANDLEMEM	2
+
+#define VM_VFS_MMAP             (VM_RQ_BASE+46)
+
+#define VM_GETRUSAGE		(VM_RQ_BASE+47)
+
+/* Total. */
+#define NR_VM_CALLS				48
+#define VM_CALL_MASK_SIZE			BITMAP_CHUNKS(NR_VM_CALLS)
+
+/* not handled as a normal VM call, thus at the end of the reserved rage */
+#define VM_PAGEFAULT		(VM_RQ_BASE+0xff)
+#	define VPF_ADDR		m1_i1
+#	define VPF_FLAGS	m1_i2
+
+/* Basic vm calls allowed to every process. */
+#define VM_BASIC_CALLS \
+    VM_BRK, VM_MMAP, VM_MUNMAP, VM_MAP_PHYS, VM_UNMAP_PHYS, VM_INFO, \
+    VM_GETRUSAGE
+
+/*===========================================================================*
+ *                Messages for IPC server				     *
+ *===========================================================================*/
+#define IPC_BASE	0xD00
+
+/* Shared Memory */
+#define IPC_SHMGET	(IPC_BASE+1)
+#define IPC_SHMAT	(IPC_BASE+2)
+#define IPC_SHMDT	(IPC_BASE+3)
+#define IPC_SHMCTL	(IPC_BASE+4)
+
+/* Semaphore */
+#define IPC_SEMGET	(IPC_BASE+5)
+#define IPC_SEMCTL	(IPC_BASE+6)
+#define IPC_SEMOP	(IPC_BASE+7)
+
+/*===========================================================================*
+ *                Messages for Scheduling				     *
+ *===========================================================================*/
+#define SCHEDULING_BASE	0xF00
+
+#define SCHEDULING_NO_QUANTUM	(SCHEDULING_BASE+1)
+#define SCHEDULING_START	(SCHEDULING_BASE+2)
+#define SCHEDULING_STOP		(SCHEDULING_BASE+3)
+#define SCHEDULING_SET_NICE	(SCHEDULING_BASE+4)
+#define SCHEDULING_INHERIT	(SCHEDULING_BASE+5)
+
+ /*===========================================================================*
+ *                Messages for Scheduling	RR			     *
+ *===========================================================================*/
+#define SCHEDULING_RR_BASE	0x1700
+
+#define SCHEDULING_RR_NO_QUANTUM	(SCHEDULING_RR_BASE+1)
+#define SCHEDULING_RR_START	(SCHEDULING_RR_BASE+2)
+#define SCHEDULING_RR_STOP		(SCHEDULING_RR_BASE+3)
+#define SCHEDULING_RR_SET_NICE	(SCHEDULING_RR_BASE+4)
+#define SCHEDULING_RR_INHERIT	(SCHEDULING_RR_BASE+5)
+
+/*===========================================================================*
+ *                Messages for Scheduling	RR			     *
+ *===========================================================================*/
+#define SCHEDULING_FCFS_BASE	0x1800
+
+#define SCHEDULING_FCFS_NO_QUANTUM	(SCHEDULING_FCFS_BASE+1)
+#define SCHEDULING_FCFS_START	(SCHEDULING_FCFS_BASE+2)
+#define SCHEDULING_FCFS_STOP		(SCHEDULING_FCFS_BASE+3)
+#define SCHEDULING_FCFS_SET_NICE	(SCHEDULING_FCFS_BASE+4)
+#define SCHEDULING_FCFS_INHERIT	(SCHEDULING_FCFS_BASE+5)
+
+/*===========================================================================*
+ *              Messages for USB                                             *
+ *===========================================================================*/
+
+#define USB_BASE 0x1100
+
+/* those are from driver to USBD */
+#define USB_RQ_INIT          (USB_BASE +  0) /* First message to HCD driver */
+#define USB_RQ_DEINIT        (USB_BASE +  1) /* Quit the session */
+#define USB_RQ_SEND_URB      (USB_BASE +  2) /* Send URB */
+#define USB_RQ_CANCEL_URB    (USB_BASE +  3) /* Cancel URB */
+#define USB_RQ_SEND_INFO     (USB_BASE +  4) /* Sends various information */
+#define USB_REPLY            (USB_BASE +  5)
+
+
+/* those are from USBD to driver */
+#define USB_COMPLETE_URB    (USB_BASE +  6)
+#define USB_ANNOUCE_DEV     (USB_BASE +  7) /* Announce a new USB Device */
+#define USB_WITHDRAW_DEV    (USB_BASE +  8) /* Withdraw a allready anncounced
+                                              USB device*/
+#   define USB_GRANT_ID     m4_l1
+#   define USB_GRANT_SIZE   m4_l2
+
+#   define USB_URB_ID       m4_l1
+#   define USB_RESULT       m4_l2
+#   define USB_DEV_ID       m4_l1
+#   define USB_DRIVER_EP    m4_l2
+#   define USB_INTERFACES   m4_l3
+#   define USB_RB_INIT_NAME m3_ca1
+
+#   define USB_INFO_TYPE    m4_l1
+#   define USB_INFO_VALUE   m4_l2
+
+/*===========================================================================*
+ *              Messages for DeviceManager (s/t like SysFS)                  *
+ *===========================================================================*/
+
+#define DEVMAN_BASE 0x1200
+
+#define DEVMAN_ADD_DEV     (DEVMAN_BASE + 0)
+#define DEVMAN_DEL_DEV     (DEVMAN_BASE + 1)
+#define DEVMAN_ADD_BUS     (DEVMAN_BASE + 2)
+#define DEVMAN_DEL_BUS     (DEVMAN_BASE + 3)
+#define DEVMAN_ADD_DEVFILE (DEVMAN_BASE + 4)
+#define DEVMAN_DEL_DEVFILE (DEVMAN_BASE + 5)
+
+#define DEVMAN_REQUEST     (DEVMAN_BASE + 6)
+#define DEVMAN_REPLY       (DEVMAN_BASE + 7)
+
+#define DEVMAN_BIND        (DEVMAN_BASE + 8)
+#define DEVMAN_UNBIND      (DEVMAN_BASE + 9)
+
+#   define DEVMAN_GRANT_ID       m4_l1
+#   define DEVMAN_GRANT_SIZE     m4_l2
+
+#   define DEVMAN_ENDPOINT       m4_l3
+#   define DEVMAN_DEVICE_ID      m4_l2
+#   define DEVMAN_RESULT         m4_l1
+
+/*===========================================================================*
+ *			Messages for TTY				     *
+ *===========================================================================*/
+
+#define TTY_RQ_BASE 0x1300
+
+#define TTY_FKEY_CONTROL	(TTY_RQ_BASE + 1) /* control an F-key at TTY */
+#  define    FKEY_MAP		10	/* observe function key */
+#  define    FKEY_UNMAP		11	/* stop observing function key */
+#  define    FKEY_EVENTS	12	/* request open key presses */
+
+#define TTY_INPUT_UP		(TTY_RQ_BASE + 2) /* input server is up */
+#define TTY_INPUT_EVENT		(TTY_RQ_BASE + 3) /* relayed input event */
+
+/*===========================================================================*
+ *			Messages for input server and drivers		     *
+ *===========================================================================*/
+
+/* The input protocol has no real replies. All messages are one-way. */
+#define INPUT_RQ_BASE 0x1500	/* from TTY to server, or server to driver */
+#define INPUT_RS_BASE 0x1580	/* from input driver to input server */
+
+#define INPUT_CONF		(INPUT_RQ_BASE + 0)	/* configure driver */
+#define INPUT_SETLEDS		(INPUT_RQ_BASE + 1)	/* set keyboard LEDs */
+
+#define INPUT_EVENT		(INPUT_RS_BASE + 0)	/* send input event */
+
+/*===========================================================================*
+ *			VFS-FS TRANSACTION IDs				     *
+ *===========================================================================*/
+
+#define VFS_TRANSACTION_BASE 0xB00
+
+#define VFS_TRANSID	(VFS_TRANSACTION_BASE + 1)
+#define IS_VFS_FS_TRANSID(type) (((type) & ~0xff) == VFS_TRANSACTION_BASE)
+
+/*===========================================================================*
+ *			Messages for character devices			     *
+ *===========================================================================*/
+
+/* Base type for character device requests and responses. */
+#define CDEV_RQ_BASE	0x400
+#define CDEV_RS_BASE	0x480
+
+#define IS_CDEV_RQ(type) (((type) & ~0x7f) == CDEV_RQ_BASE)
+#define IS_CDEV_RS(type) (((type) & ~0x7f) == CDEV_RS_BASE)
+
+/* Message types for character device requests. */
+#define CDEV_OPEN	(CDEV_RQ_BASE + 0)	/* open a minor device */
+#define CDEV_CLOSE	(CDEV_RQ_BASE + 1)	/* close a minor device */
+#define CDEV_READ	(CDEV_RQ_BASE + 2)	/* read into a buffer */
+#define CDEV_WRITE	(CDEV_RQ_BASE + 3)	/* write from a buffer */
+#define CDEV_IOCTL	(CDEV_RQ_BASE + 4)	/* I/O control operation */
+#define CDEV_CANCEL	(CDEV_RQ_BASE + 5)	/* cancel suspended request */
+#define CDEV_SELECT	(CDEV_RQ_BASE + 6)	/* test for ready operations */
+
+/* Message types for character device responses. */
+#define CDEV_REPLY	(CDEV_RS_BASE + 0)	/* general reply code */
+#define CDEV_SEL1_REPLY	(CDEV_RS_BASE + 1)	/* immediate select reply */
+#define CDEV_SEL2_REPLY	(CDEV_RS_BASE + 2)	/* select notification reply */
+
+/* Bits in 'CDEV_ACCESS' field of block device open requests. */
+#  define CDEV_R_BIT		0x01	/* open with read access */
+#  define CDEV_W_BIT		0x02	/* open with write access */
+#  define CDEV_NOCTTY		0x04	/* not to become the controlling TTY */
+
+/* Bits in 'CDEV_FLAGS' field of block device transfer requests. */
+#  define CDEV_NOFLAGS		0x00	/* no flags are set */
+#  define CDEV_NONBLOCK		0x01	/* do not suspend I/O request */
+
+/* Bits in 'CDEV_OPS', 'CDEV_STATUS' fields of block device select messages. */
+#  define CDEV_OP_RD		0x01	/* selected for read operation */
+#  define CDEV_OP_WR		0x02	/* selected for write operation */
+#  define CDEV_OP_ERR		0x04	/* selected for error operation */
+#  define CDEV_NOTIFY		0x08	/* notification requested */
+
+/* Bits in 'CDEV_STATUS' field of block device open responses. */
+#  define CDEV_CLONED		0x20000000	/* device is cloned */
+#  define CDEV_CTTY		0x40000000	/* device is controlling TTY */
+
+/*===========================================================================*
+ *			Messages for block devices			     *
+ *===========================================================================*/
+
+/* Base type for block device requests and responses. */
+#define BDEV_RQ_BASE	0x500
+#define BDEV_RS_BASE	0x580
+
+#define IS_BDEV_RQ(type) (((type) & ~0x7f) == BDEV_RQ_BASE)
+#define IS_BDEV_RS(type) (((type) & ~0x7f) == BDEV_RS_BASE)
+
+/* Message types for block device requests. */
+#define BDEV_OPEN	(BDEV_RQ_BASE + 0)	/* open a minor device */
+#define BDEV_CLOSE	(BDEV_RQ_BASE + 1)	/* close a minor device */
+#define BDEV_READ	(BDEV_RQ_BASE + 2)	/* read into a buffer */
+#define BDEV_WRITE	(BDEV_RQ_BASE + 3)	/* write from a buffer */
+#define BDEV_GATHER	(BDEV_RQ_BASE + 4)	/* read into a vector */
+#define BDEV_SCATTER	(BDEV_RQ_BASE + 5)	/* write from a vector */
+#define BDEV_IOCTL	(BDEV_RQ_BASE + 6)	/* I/O control operation */
+
+/* Message types for block device responses. */
+#define BDEV_REPLY	(BDEV_RS_BASE + 0)	/* general reply code */
+
+/* Bits in 'BDEV_ACCESS' field of block device open requests. */
+#  define BDEV_R_BIT		0x01	/* open with read access */
+#  define BDEV_W_BIT		0x02	/* open with write access */
+
+/* Bits in 'BDEV_FLAGS' field of block device transfer requests. */
+#  define BDEV_NOFLAGS		0x00	/* no flags are set */
+#  define BDEV_FORCEWRITE	0x01	/* force write to disk immediately */
+#  define BDEV_NOPAGE		0x02	/* eeprom: don't send page address */
+
+/*===========================================================================*
+ *			Messages for Real Time Clocks			     *
+ *===========================================================================*/
+
+/* Base type for real time clock requests and responses. */
+#define RTCDEV_RQ_BASE	0x1400
+#define RTCDEV_RS_BASE	0x1480
+
+#define IS_RTCDEV_RQ(type) (((type) & ~0x7f) == RTCDEV_RQ_BASE)
+#define IS_RTCDEV_RS(type) (((type) & ~0x7f) == RTCDEV_RS_BASE)
+
+/* Message types for real time clock requests. */
+#define RTCDEV_GET_TIME	(RTCDEV_RQ_BASE + 0)	/* get time from hw clock */
+#define RTCDEV_SET_TIME	(RTCDEV_RQ_BASE + 1)	/* set time in hw clock */
+#define RTCDEV_PWR_OFF	(RTCDEV_RQ_BASE + 2)	/* set time to cut the power */
+
+/* Same as GET/SET above but using grants */
+#define RTCDEV_GET_TIME_G (RTCDEV_RQ_BASE + 3)	/* get time from hw clock */
+#define RTCDEV_SET_TIME_G (RTCDEV_RQ_BASE + 4)	/* set time in hw clock */
+
+/* Message types for real time clock responses. */
+#define RTCDEV_REPLY	(RTCDEV_RS_BASE + 0)	/* general reply code */
+
+/* Bits in 'lc_readclock_rtcdev.flags' field of real time clock requests. */
+#define RTCDEV_NOFLAGS	0x00	/* no flags are set */
+#define RTCDEV_Y2KBUG	0x01	/* Interpret 1980 as 2000 for RTC w/Y2K bug */
+#define RTCDEV_CMOSREG	0x02	/* Also set the CMOS clock register bits. */
+
+/*===========================================================================*
+ *		Internal codes used by several services			     *
+ *===========================================================================*/
+
+#define SUSPEND 	 -998 	/* status to suspend caller, reply later */
+
+#endif /* !_MINIX_COM_H */
diff -x .* -ruPN minix2/minix/include/minix/ipc.h minix/minix/include/minix/ipc.h
--- minix2/minix/include/minix/ipc.h	Tue May 24 18:41:15 2016
+++ minix/minix/include/minix/ipc.h	Tue May 24 18:46:23 2016
@@ -1,2420 +1,2423 @@
-#ifndef _IPC_H
-#define _IPC_H
-
-#include <minix/ipcconst.h>
-#include <minix/type.h>
-#include <minix/const.h>
-#include <sys/signal.h>
-#include <sys/types.h>
-
-/*==========================================================================* 
- * Types relating to messages. 						    *
- *==========================================================================*/ 
-
-#define M_PATH_STRING_MAX  40
-
-typedef struct {
-	uint8_t data[56];
-} mess_u8;
-_ASSERT_MSG_SIZE(mess_u8);
-
-typedef struct {
-	uint16_t data[28];
-} mess_u16;
-_ASSERT_MSG_SIZE(mess_u16);
-
-typedef struct {
-	uint32_t data[14];
-} mess_u32;
-_ASSERT_MSG_SIZE(mess_u32);
-
-typedef struct {
-	uint64_t data[7];
-} mess_u64;
-_ASSERT_MSG_SIZE(mess_u64);
-
-typedef struct {
-	uint64_t m1ull1;
-	int m1i1, m1i2, m1i3;
-	char *m1p1, *m1p2, *m1p3, *m1p4;
-	uint8_t padding[20];
-} mess_1;
-_ASSERT_MSG_SIZE(mess_1);
-
-typedef struct {
-	int64_t m2ll1;
-	int m2i1, m2i2, m2i3;
-	long m2l1, m2l2;
-	char *m2p1;
-	sigset_t sigset;
-	short m2s1;
-	uint8_t padding[6];
-} mess_2;
-_ASSERT_MSG_SIZE(mess_2);
-
-typedef struct {
-	int m3i1, m3i2;
-	char *m3p1;
-	char m3ca1[44];
-} mess_3;
-_ASSERT_MSG_SIZE(mess_3);
-
-typedef struct {
-	int64_t m4ll1;
-	long m4l1, m4l2, m4l3, m4l4, m4l5;
-	uint8_t padding[28];
-} mess_4;
-_ASSERT_MSG_SIZE(mess_4);
-
-typedef struct {
-	int m7i1, m7i2, m7i3, m7i4, m7i5;
-	char *m7p1, *m7p2;
-	uint8_t padding[28];
-} mess_7;
-_ASSERT_MSG_SIZE(mess_7);
-
-typedef struct {
-	uint64_t m9ull1, m9ull2;
-	long m9l1, m9l2, m9l3, m9l4, m9l5;
-	short m9s1, m9s2, m9s3, m9s4;
-	uint8_t padding[12];
-} mess_9;
-_ASSERT_MSG_SIZE(mess_9);
-
-typedef struct {
-	u64_t m10ull1;
-	int m10i1, m10i2, m10i3, m10i4;
-	long m10l1, m10l2, m10l3;
-	uint8_t padding[20];
-} mess_10;
-_ASSERT_MSG_SIZE(mess_10);
-
-/* Helper union for DS messages */
-union	ds_val {
-	cp_grant_id_t	grant;
-	u32_t		u32;
-	endpoint_t	ep;
-};
-
-typedef struct {
-	union	ds_val 	val_out;
-	int	val_len;
-	uint8_t padding[48];
-} mess_ds_reply;
-_ASSERT_MSG_SIZE(mess_ds_reply);
-
-typedef struct {
-	cp_grant_id_t	key_grant;
-	int		key_len;
-	int		flags;
-	union ds_val 	val_in;
-	int		val_len;
-	endpoint_t	owner;
-	uint8_t padding[32];
-} mess_ds_req;
-_ASSERT_MSG_SIZE(mess_ds_req);
-
-typedef struct {
-	off_t seek_pos;
-
-	size_t nbytes;
-
-	uint8_t data[44];
-} mess_fs_vfs_breadwrite;
-_ASSERT_MSG_SIZE(mess_fs_vfs_breadwrite);
-
-typedef struct {
-	mode_t mode;
-
-	uint8_t data[52];
-} mess_fs_vfs_chmod;
-_ASSERT_MSG_SIZE(mess_fs_vfs_chmod);
-
-typedef struct {
-	mode_t mode;
-
-	uint8_t data[52];
-} mess_fs_vfs_chown;
-_ASSERT_MSG_SIZE(mess_fs_vfs_chown);
-
-typedef struct {
-	off_t file_size;
-	ino_t inode;
-
-	mode_t mode;
-	uid_t uid;
-	gid_t gid;
-
-	uint8_t data[28];
-} mess_fs_vfs_create;
-_ASSERT_MSG_SIZE(mess_fs_vfs_create);
-
-typedef struct {
-	off_t seek_pos;
-
-	size_t nbytes;
-
-	uint8_t data[44];
-} mess_fs_vfs_getdents;
-_ASSERT_MSG_SIZE(mess_fs_vfs_getdents);
-
-typedef struct {
-	off_t offset;
-	off_t file_size;
-	dev_t device;
-	ino_t inode;
-
-	mode_t mode;
-	uid_t uid;
-	gid_t gid;
-
-	uint16_t symloop;
-
-	uint8_t data[10];
-} mess_fs_vfs_lookup;
-_ASSERT_MSG_SIZE(mess_fs_vfs_lookup);
-
-typedef struct {
-	off_t file_size;
-	dev_t device;
-	ino_t inode;
-
-	mode_t mode;
-	uid_t uid;
-	gid_t gid;
-
-	uint8_t data[20];
-} mess_fs_vfs_newnode;
-_ASSERT_MSG_SIZE(mess_fs_vfs_newnode);
-
-typedef struct {
-	size_t nbytes;
-
-	uint8_t data[52];
-} mess_fs_vfs_rdlink;
-_ASSERT_MSG_SIZE(mess_fs_vfs_rdlink);
-
-typedef struct {
-	off_t file_size;
-	dev_t device;
-	ino_t inode;
-
-	uint32_t flags;
-	mode_t mode;
-	uid_t uid;
-	gid_t gid;
-
-	uint16_t con_reqs;
-
-	uint8_t data[14];
-} mess_fs_vfs_readsuper;
-_ASSERT_MSG_SIZE(mess_fs_vfs_readsuper);
-
-typedef struct {
-	off_t seek_pos;
-
-	size_t nbytes;
-
-	uint8_t data[44];
-} mess_fs_vfs_readwrite;
-_ASSERT_MSG_SIZE(mess_fs_vfs_readwrite);
-
-typedef struct {
-	uint8_t padding[56];
-} mess_i2c_li2cdriver_busc_i2c_exec;
-_ASSERT_MSG_SIZE(mess_i2c_li2cdriver_busc_i2c_exec);
-
-typedef struct {
-	uint8_t padding[56];
-} mess_i2c_li2cdriver_busc_i2c_reserve;
-_ASSERT_MSG_SIZE(mess_i2c_li2cdriver_busc_i2c_reserve);
-
-typedef struct {
-	int kbd_id;
-	int mouse_id;
-	int rsvd1_id;
-	int rsvd2_id;
-
-	uint8_t padding[40];
-} mess_input_linputdriver_input_conf;
-_ASSERT_MSG_SIZE(mess_input_linputdriver_input_conf);
-
-typedef struct {
-	uint32_t led_mask;
-
-	uint8_t padding[52];
-} mess_input_linputdriver_setleds;
-_ASSERT_MSG_SIZE(mess_input_linputdriver_setleds);
-
-typedef struct {
-	int id;
-	int page;
-	int code;
-	int value;
-	int flags;
-
-	uint8_t padding[36];
-} mess_input_tty_event;
-_ASSERT_MSG_SIZE(mess_input_tty_event);
-
-typedef struct {
-	time_t acnt_queue;
-
-	unsigned long acnt_deqs;
-	unsigned long acnt_ipc_sync;
-	unsigned long acnt_ipc_async;
-	unsigned long acnt_preempt;
-	uint32_t acnt_cpu;
-	uint32_t acnt_cpu_load;
-
-	uint8_t padding[24];
-} mess_krn_lsys_schedule;
-_ASSERT_MSG_SIZE(mess_krn_lsys_schedule);
-
-typedef struct {
-	uint32_t value;
-
-	uint8_t padding[52];
-} mess_krn_lsys_sys_devio;
-_ASSERT_MSG_SIZE(mess_krn_lsys_sys_devio);
-
-typedef struct {
-	endpoint_t endpt;
-	vir_bytes msgaddr;
-
-	uint8_t padding[48];
-} mess_krn_lsys_sys_fork;
-_ASSERT_MSG_SIZE(mess_krn_lsys_sys_fork);
-
-typedef struct {
-	endpoint_t endpt;
-	int privflags;
-	char name[48];
-
-} mess_krn_lsys_sys_getwhoami;
-_ASSERT_MSG_SIZE(mess_krn_lsys_sys_getwhoami);
-
-typedef struct {
-	int hook_id;
-
-	uint8_t padding[52];
-} mess_krn_lsys_sys_irqctl;
-_ASSERT_MSG_SIZE(mess_krn_lsys_sys_irqctl);
-
-typedef struct {
-	clock_t real_ticks;
-	clock_t boot_ticks;
-	clock_t boot_time;
-	clock_t user_time;
-	clock_t system_time;
-
-	uint8_t padding[36];
-} mess_krn_lsys_sys_times;
-_ASSERT_MSG_SIZE(mess_krn_lsys_sys_times);
-
-typedef struct {
-	long int data;
-
-	uint8_t padding[52];
-} mess_krn_lsys_sys_trace;
-_ASSERT_MSG_SIZE(mess_krn_lsys_sys_trace);
-
-typedef struct {
-	phys_bytes dst_addr;
-
-	uint8_t padding[52];
-} mess_krn_lsys_sys_umap;
-_ASSERT_MSG_SIZE(mess_krn_lsys_sys_umap);
-
-typedef struct {
-	int pcount;
-
-	uint8_t padding[52];
-} mess_krn_lsys_sys_vumap;
-_ASSERT_MSG_SIZE(mess_krn_lsys_sys_vumap);
-
-typedef struct {
-	off_t pos;
-
-	int minor;
-	int id;
-	int access;
-
-	int count;
-	cp_grant_id_t grant;
-	int flags;
-
-	endpoint_t user;
-	int request;
-
-	uint8_t padding[16];
-} mess_lbdev_lblockdriver_msg;
-_ASSERT_MSG_SIZE(mess_lbdev_lblockdriver_msg);
-
-typedef struct {
-	int status;
-	int id;
-
-	uint8_t padding[48];
-} mess_lblockdriver_lbdev_reply;
-_ASSERT_MSG_SIZE(mess_lblockdriver_lbdev_reply);
-
-typedef struct {
-	int		id;
-	int		num;
-	int		cmd;
-	int		opt;
-	int		ret;
-	uint8_t		padding[36];
-} mess_lc_ipc_semctl;
-_ASSERT_MSG_SIZE(mess_lc_ipc_semctl);
-
-typedef struct {
-	key_t		key;
-	int		nr;
-	int		flag;
-	int		retid;
-	uint8_t		padding[40];
-} mess_lc_ipc_semget;
-_ASSERT_MSG_SIZE(mess_lc_ipc_semget);
-
-typedef struct {
-	int		id;
-	void		*ops;
-	unsigned int	size;
-	uint8_t		padding[42];
-} mess_lc_ipc_semop;
-_ASSERT_MSG_SIZE(mess_lc_ipc_semop);
-
-typedef struct {
-	int		id;
-	const void	*addr;
-	int		flag;
-	void		*retaddr;
-	uint8_t		padding[40];
-} mess_lc_ipc_shmat;
-_ASSERT_MSG_SIZE(mess_lc_ipc_shmat);
-
-typedef struct {
-	int		id;
-	int		cmd;
-	void		*buf;
-	int		ret;
-	uint8_t		padding[40];
-} mess_lc_ipc_shmctl;
-_ASSERT_MSG_SIZE(mess_lc_ipc_shmctl);
-
-typedef struct {
-	const void	*addr;
-	uint8_t		padding[52];
-} mess_lc_ipc_shmdt;
-_ASSERT_MSG_SIZE(mess_lc_ipc_shmdt);
-
-typedef struct {
-	key_t		key;
-	size_t		size;
-	int		flag;
-	int		retid;
-	uint8_t		padding[40];
-} mess_lc_ipc_shmget;
-_ASSERT_MSG_SIZE(mess_lc_ipc_shmget);
-
-typedef struct {
-	int action;
-	vir_bytes ctl_ptr;
-	vir_bytes mem_ptr;
-	size_t mem_size;
-
-	uint8_t padding[40];
-} mess_lc_pm_cprof;
-_ASSERT_MSG_SIZE(mess_lc_pm_cprof);
-
-typedef struct {
-	vir_bytes name;
-	size_t namelen;
-	vir_bytes frame;
-	size_t framelen;
-	vir_bytes ps_str;
-
-	uint8_t padding[36];
-} mess_lc_pm_exec;
-_ASSERT_MSG_SIZE(mess_lc_pm_exec);
-
-typedef struct {
-	int status;
-
-	uint8_t padding[52];
-} mess_lc_pm_exit;
-_ASSERT_MSG_SIZE(mess_lc_pm_exit);
-
-typedef struct {
-	pid_t pid;
-
-	uint8_t padding[52];
-} mess_lc_pm_getsid;
-_ASSERT_MSG_SIZE(mess_lc_pm_getsid);
-
-typedef struct {
-	int num;
-	vir_bytes ptr;		/* gid_t * */
-
-	uint8_t padding[48];
-} mess_lc_pm_groups;
-_ASSERT_MSG_SIZE(mess_lc_pm_groups);
-
-typedef struct {
-	int which;
-	vir_bytes value;	/* const struct itimerval * */
-	vir_bytes ovalue;	/* struct itimerval * */
-
-	uint8_t padding[44];
-} mess_lc_pm_itimer;
-_ASSERT_MSG_SIZE(mess_lc_pm_itimer);
-
-typedef struct {
-	vir_bytes ctx;		/* mcontext_t * */
-
-	uint8_t padding[52];
-} mess_lc_pm_mcontext;
-_ASSERT_MSG_SIZE(mess_lc_pm_mcontext);
-
-typedef struct {
-	int which;
-	int who;
-	int prio;
-
-	uint8_t padding[44];
-} mess_lc_pm_priority;
-_ASSERT_MSG_SIZE(mess_lc_pm_priority);
-
-typedef struct {
-	pid_t pid;
-	int req;
-	vir_bytes addr;
-	long data;
-
-	uint8_t padding[40];
-} mess_lc_pm_ptrace;
-_ASSERT_MSG_SIZE(mess_lc_pm_ptrace);
-
-typedef struct {
-	int how;
-
-	uint8_t padding[52];
-} mess_lc_pm_reboot;
-_ASSERT_MSG_SIZE(mess_lc_pm_reboot);
-
-typedef struct {
-	endpoint_t who;
-	vir_bytes addr;
-
-	uint8_t padding[48];
-} mess_lc_pm_rusage;
-_ASSERT_MSG_SIZE(mess_lc_pm_rusage);
-
-typedef struct {
-	gid_t gid;
-
-	uint8_t padding[52];
-} mess_lc_pm_setgid;
-_ASSERT_MSG_SIZE(mess_lc_pm_setgid);
-
-typedef struct {
-	uid_t uid;
-
-	uint8_t padding[52];
-} mess_lc_pm_setuid;
-_ASSERT_MSG_SIZE(mess_lc_pm_setuid);
-
-typedef struct {
-	pid_t pid;
-	int nr;
-	vir_bytes act;		/* const struct sigaction * */
-	vir_bytes oact;		/* struct sigaction * */
-	vir_bytes ret;		/* int (*)(void) */
-
-	uint8_t padding[36];
-} mess_lc_pm_sig;
-_ASSERT_MSG_SIZE(mess_lc_pm_sig);
-
-typedef struct {
-	int how;
-	vir_bytes ctx;
-	sigset_t set;
-
-	uint8_t padding[32];
-} mess_lc_pm_sigset;
-_ASSERT_MSG_SIZE(mess_lc_pm_sigset);
-
-typedef struct {
-	int action;
-	int freq;
-	int intr_type;
-	vir_bytes ctl_ptr;
-	vir_bytes mem_ptr;
-	size_t mem_size;
-
-	uint8_t padding[32];
-} mess_lc_pm_sprof;
-_ASSERT_MSG_SIZE(mess_lc_pm_sprof);
-
-typedef struct {
-	int req;
-	int field;
-	size_t len;
-	vir_bytes value;
-
-	uint8_t padding[40];
-} mess_lc_pm_sysuname;
-_ASSERT_MSG_SIZE(mess_lc_pm_sysuname);
-
-typedef struct {
-	time_t sec;
-
-	clockid_t clk_id;
-	int now;
-	long nsec;
-
-	uint8_t padding[36];
-} mess_lc_pm_time;
-_ASSERT_MSG_SIZE(mess_lc_pm_time);
-
-typedef struct {
-	pid_t pid;
-	int options;
-
-	uint8_t padding[48];
-} mess_lc_pm_waitpid;
-_ASSERT_MSG_SIZE(mess_lc_pm_waitpid);
-
-typedef struct {
-	cp_grant_id_t grant;
-	vir_bytes tm;			/* struct tm * */
-	int flags;
-
-	uint8_t padding[44];
-} mess_lc_readclock_rtcdev;
-_ASSERT_MSG_SIZE(mess_lc_readclock_rtcdev);
-
-typedef struct {
-	vir_bytes name;
-	size_t len;
-	int fd;
-	uid_t owner;
-	gid_t group;
-
-	uint8_t padding[36];
-} mess_lc_vfs_chown;
-_ASSERT_MSG_SIZE(mess_lc_vfs_chown);
-
-typedef struct {
-	int fd;
-
-	uint8_t padding[52];
-} mess_lc_vfs_close;
-_ASSERT_MSG_SIZE(mess_lc_vfs_close);
-
-typedef struct {
-	vir_bytes name;
-	size_t len;
-	int flags;
-	mode_t mode;
-
-	uint8_t padding[40];
-} mess_lc_vfs_creat;
-_ASSERT_MSG_SIZE(mess_lc_vfs_creat);
-
-typedef struct {
-	int fd;
-
-	uint8_t padding[52];
-} mess_lc_vfs_fchdir;
-_ASSERT_MSG_SIZE(mess_lc_vfs_fchdir);
-
-typedef struct {
-	int fd;
-	mode_t mode;
-
-	uint8_t padding[48];
-} mess_lc_vfs_fchmod;
-_ASSERT_MSG_SIZE(mess_lc_vfs_fchmod);
-
-typedef struct {
-	int fd;
-	int cmd;
-	int arg_int;
-	vir_bytes arg_ptr;	/* struct flock * */
-
-	uint8_t padding[40];
-} mess_lc_vfs_fcntl;
-_ASSERT_MSG_SIZE(mess_lc_vfs_fcntl);
-
-typedef struct {
-	int fd;
-	vir_bytes buf;		/* struct stat * */
-
-	uint8_t padding[48];
-} mess_lc_vfs_fstat;
-_ASSERT_MSG_SIZE(mess_lc_vfs_fstat);
-
-typedef struct {
-	int fd;
-
-	uint8_t padding[52];
-} mess_lc_vfs_fsync;
-_ASSERT_MSG_SIZE(mess_lc_vfs_fsync);
-
-typedef struct {
-	cp_grant_id_t grant;
-	int pid;
-	vir_bytes buff_p;
-	size_t buff_sz;
-
-	uint8_t padding[40];
-} mess_lc_vfs_gcov;
-_ASSERT_MSG_SIZE(mess_lc_vfs_gcov);
-
-typedef struct {
-	int32_t flags;
-	size_t len;
-	vir_bytes buf;		/* struct statvfs */
-
-	uint8_t padding[44];
-} mess_lc_vfs_getvfsstat;
-_ASSERT_MSG_SIZE(mess_lc_vfs_getvfsstat);
-
-typedef struct {
-	int fd;
-	unsigned long req;
-	vir_bytes arg;
-
-	uint8_t padding[44];
-} mess_lc_vfs_ioctl;
-_ASSERT_MSG_SIZE(mess_lc_vfs_ioctl);
-
-typedef struct {
-	vir_bytes name1;
-	vir_bytes name2;
-	size_t len1;
-	size_t len2;
-
-	uint8_t padding[40];
-} mess_lc_vfs_link;
-_ASSERT_MSG_SIZE(mess_lc_vfs_link);
-
-typedef struct {
-	off_t offset;
-
-	int fd;
-	int whence;
-
-	uint8_t padding[40];
-} mess_lc_vfs_lseek;
-_ASSERT_MSG_SIZE(mess_lc_vfs_lseek);
-
-typedef struct {
-	dev_t device;
-
-	vir_bytes name;
-	size_t len;
-	mode_t mode;
-
-	uint8_t padding[36];
-} mess_lc_vfs_mknod;
-_ASSERT_MSG_SIZE(mess_lc_vfs_mknod);
-
-typedef struct {
-	int flags;
-	size_t devlen;
-	size_t pathlen;
-	size_t typelen;
-	size_t labellen;
-	vir_bytes dev;
-	vir_bytes path;
-	vir_bytes type;
-	vir_bytes label;
-
-	uint8_t padding[20];
-} mess_lc_vfs_mount;
-_ASSERT_MSG_SIZE(mess_lc_vfs_mount);
-
-typedef struct {
-	vir_bytes name;
-	size_t len;
-	int flags;
-	mode_t mode;
-	char buf[M_PATH_STRING_MAX];
-} mess_lc_vfs_path;
-_ASSERT_MSG_SIZE(mess_lc_vfs_path);
-
-typedef struct {
-	int fd0;
-	int fd1;
-	int flags;
-
-	uint8_t padding[44];
-} mess_lc_vfs_pipe2;
-_ASSERT_MSG_SIZE(mess_lc_vfs_pipe2);
-
-typedef struct {
-	vir_bytes name;		/* const char * */
-	size_t namelen;
-	vir_bytes buf;
-	size_t bufsize;
-
-	uint8_t padding[40];
-} mess_lc_vfs_readlink;
-_ASSERT_MSG_SIZE(mess_lc_vfs_readlink);
-
-typedef struct {
-	int fd;
-	vir_bytes buf;
-	size_t len;
-
-	uint8_t padding[44];
-} mess_lc_vfs_readwrite;
-_ASSERT_MSG_SIZE(mess_lc_vfs_readwrite);
-
-typedef struct {
-	vir_bytes addr;
-
-	uint8_t padding[52];
-} mess_lc_vfs_rusage;
-_ASSERT_MSG_SIZE(mess_lc_vfs_rusage);
-
-typedef struct {
-	uint32_t nfds;
-	fd_set *readfds;
-	fd_set *writefds;
-	fd_set *errorfds;
-	vir_bytes timeout;	/* user-provided 'struct timeval *' */
-
-	uint8_t padding[36];
-} mess_lc_vfs_select;
-_ASSERT_MSG_SIZE(mess_lc_vfs_select);
-
-typedef struct {
-	size_t len;
-	vir_bytes name;		/* const char * */
-	vir_bytes buf;		/* struct stat * */
-
-	uint8_t padding[44];
-} mess_lc_vfs_stat;
-_ASSERT_MSG_SIZE(mess_lc_vfs_stat);
-
-typedef struct {
-	int fd;
-	int flags;
-	size_t len;
-	vir_bytes name;
-	vir_bytes buf;
-
-	uint8_t padding[36];
-} mess_lc_vfs_statvfs1;
-_ASSERT_MSG_SIZE(mess_lc_vfs_statvfs1);
-
-typedef struct {
-	off_t offset;
-
-	int fd;
-	vir_bytes name;
-	size_t len;
-
-	uint8_t padding[36];
-} mess_lc_vfs_truncate;
-_ASSERT_MSG_SIZE(mess_lc_vfs_truncate);
-
-typedef struct {
-	mode_t mask;
-
-	uint8_t padding[52];
-} mess_lc_vfs_umask;
-_ASSERT_MSG_SIZE(mess_lc_vfs_umask);
-
-typedef struct {
-	vir_bytes name;
-	size_t namelen;
-	vir_bytes label;
-	size_t labellen;
-
-	uint8_t padding[40];
-} mess_lc_vfs_umount;
-_ASSERT_MSG_SIZE(mess_lc_vfs_umount);
-
-typedef struct {
-	void		*addr;
-	uint8_t		padding[52];
-} mess_lc_vm_brk;
-_ASSERT_MSG_SIZE(mess_lc_vm_brk);
-
-typedef struct {
-	endpoint_t	endpt;
-	void		*addr;
-	void		*ret_addr;
-	uint8_t		padding[44];
-} mess_lc_vm_getphys;
-_ASSERT_MSG_SIZE(mess_lc_vm_getphys);
-
-typedef struct {
-	vir_bytes addr;
-
-	uint8_t padding[52];
-} mess_lc_vm_rusage;
-_ASSERT_MSG_SIZE(mess_lc_vm_rusage);
-
-typedef struct {
-	endpoint_t	forwhom;
-	void		*addr;
-	uint8_t		padding[48];
-} mess_lc_vm_shm_unmap;
-_ASSERT_MSG_SIZE(mess_lc_vm_shm_unmap);
-
-typedef struct {
-	int status;
-	uint32_t id;		/* should be cdev_id_t */
-
-	uint8_t padding[48];
-} mess_lchardriver_vfs_reply;
-_ASSERT_MSG_SIZE(mess_lchardriver_vfs_reply);
-
-typedef struct {
-	int status;
-	int32_t minor;
-
-	uint8_t padding[48];
-} mess_lchardriver_vfs_sel1;
-_ASSERT_MSG_SIZE(mess_lchardriver_vfs_sel1);
-
-typedef struct {
-	int status;
-	int32_t minor;
-
-	uint8_t padding[48];
-} mess_lchardriver_vfs_sel2;
-_ASSERT_MSG_SIZE(mess_lchardriver_vfs_sel2);
-
-typedef struct {
-	endpoint_t endpt;
-	vir_bytes ptr;		/* struct exec_info * */
-
-	uint8_t padding[48];
-} mess_lexec_pm_exec_new;
-_ASSERT_MSG_SIZE(mess_lexec_pm_exec_new);
-
-typedef struct {
-	cp_grant_id_t grant;
-
-	uint8_t padding[52];
-} mess_li2cdriver_i2c_busc_i2c_exec;
-_ASSERT_MSG_SIZE(mess_li2cdriver_i2c_busc_i2c_exec);
-
-typedef struct {
-	uint16_t addr; /* FIXME: strictly speaking this is an i2c_addr_t, but
-			  to get it I would need to include
-			  sys/dev/i2c/i2c_io.h, which I am not sure is a good
-			  idea to have everywhere. */
-
-	uint8_t padding[54];
-} mess_li2cdriver_i2c_busc_i2c_reserve;
-_ASSERT_MSG_SIZE(mess_li2cdriver_i2c_busc_i2c_reserve);
-
-typedef struct {
-	int id;
-	int page;
-	int code;
-	int value;
-	int flags;
-
-	uint8_t padding[36];
-} mess_linputdriver_input_event;
-_ASSERT_MSG_SIZE(mess_linputdriver_input_event);
-
-typedef struct {
-        cp_grant_id_t gid;
-	size_t size;
-
-        uint8_t padding[48];
-} mess_lsys_fi_ctl;
-_ASSERT_MSG_SIZE(mess_lsys_fi_ctl);
-
-typedef struct {
-        int status;
-
-        uint8_t padding[52];
-} mess_lsys_fi_reply;
-_ASSERT_MSG_SIZE(mess_lsys_fi_reply);
-
-typedef struct {
-	int what;
-	vir_bytes where;
-	size_t size;
-
-	uint8_t padding[44];
-} mess_lsys_getsysinfo;
-_ASSERT_MSG_SIZE(mess_lsys_getsysinfo);
-
-typedef struct {
-	size_t size;
-	phys_bytes addr;
-	vir_bytes buf;
-
-	uint8_t padding[44];
-} mess_lsys_krn_readbios;
-_ASSERT_MSG_SIZE(mess_lsys_krn_readbios);
-
-typedef struct {
-	endpoint_t	from_to;
-	cp_grant_id_t	gid;
-	size_t		offset;
-	void		*address;
-	size_t		bytes;
-	uint8_t padding[36];
-} mess_lsys_kern_safecopy;
-_ASSERT_MSG_SIZE(mess_lsys_kern_safecopy);
-
-typedef struct {
-	uint32_t flags;
-	endpoint_t endpoint;
-	int priority;
-	int quantum;
-	int cpu;
-
-	uint8_t padding[36];
-} mess_lsys_krn_schedctl;
-_ASSERT_MSG_SIZE(mess_lsys_krn_schedctl);
-
-typedef struct {
-	endpoint_t endpoint;
-	int quantum;
-	int priority;
-	int cpu;
-
-	uint8_t padding[40];
-} mess_lsys_krn_schedule;
-_ASSERT_MSG_SIZE(mess_lsys_krn_schedule);
-
-typedef struct {
-	int how;
-
-	uint8_t padding[52];
-} mess_lsys_krn_sys_abort;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_abort);
-
-typedef struct {
-	endpoint_t endpt;
-
-	uint8_t padding[52];
-} mess_lsys_krn_sys_clear;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_clear);
-
-typedef struct {
-	endpoint_t src_endpt;
-	vir_bytes src_addr;
-	endpoint_t dst_endpt;
-	vir_bytes dst_addr;
-	phys_bytes nr_bytes;
-	int flags;
-
-	uint8_t padding[32];
-} mess_lsys_krn_sys_copy;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_copy);
-
-typedef struct {
-	endpoint_t endpt;
-	int action;
-	vir_bytes ctl_ptr;
-	vir_bytes mem_ptr;
-	size_t mem_size;
-
-	uint8_t padding[36];
-} mess_lsys_krn_sys_cprof;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_cprof);
-
-typedef struct {
-	int request;
-	int port;
-	uint32_t value;
-
-	uint8_t padding[44];
-} mess_lsys_krn_sys_devio;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_devio);
-
-typedef struct {
-	int code;
-	vir_bytes buf;
-	int len;
-	endpoint_t endpt;
-
-	uint8_t padding[40];
-} mess_lsys_krn_sys_diagctl;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_diagctl);
-
-typedef struct {
-	endpoint_t endpt;
-	vir_bytes ip;
-	vir_bytes stack;
-	vir_bytes name;
-	vir_bytes ps_str;
-
-	uint8_t padding[36];
-} mess_lsys_krn_sys_exec;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_exec);
-
-typedef struct {
-	endpoint_t endpt;
-	endpoint_t slot;
-	uint32_t flags;
-
-	uint8_t padding[44];
-} mess_lsys_krn_sys_fork;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_fork);
-
-typedef struct {
-	int request;
-	endpoint_t endpt;
-	vir_bytes val_ptr;
-	int val_len;
-	vir_bytes val_ptr2;
-	int val_len2_e;
-
-	uint8_t padding[32];
-} mess_lsys_krn_sys_getinfo;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_getinfo);
-
-typedef struct {
-	endpoint_t endpt;
-	vir_bytes ctx_ptr;
-
-	uint8_t padding[48];
-} mess_lsys_krn_sys_getmcontext;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_getmcontext);
-
-typedef struct {
-	endpoint_t endpt;
-
-	uint8_t padding[52];
-} mess_lsys_krn_sys_iopenable;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_iopenable);
-
-typedef struct {
-	int request;
-	int vector;
-	int policy;
-	int hook_id;
-
-	uint8_t padding[40];
-} mess_lsys_krn_sys_irqctl;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_irqctl);
-
-typedef struct {
-	phys_bytes base;
-	phys_bytes count;
-	unsigned long pattern;
-	endpoint_t process;
-
-	uint8_t padding[40];
-} mess_lsys_krn_sys_memset;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_memset);
-
-typedef struct {
-	int request;
-	endpoint_t endpt;
-	vir_bytes arg_ptr;
-	phys_bytes phys_start;
-	phys_bytes phys_len;
-
-	uint8_t padding[36];
-} mess_lsys_krn_sys_privctl;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_privctl);
-
-typedef struct {
-	vir_bytes ctl_ptr;
-	vir_bytes mem_ptr;
-
-	uint8_t padding[48];
-} mess_lsys_krn_sys_profbuf;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_profbuf);
-
-typedef struct {
-	int request;
-	long int port;
-	endpoint_t vec_endpt;
-	phys_bytes vec_addr;
-	vir_bytes vec_size;
-	vir_bytes offset;
-
-	uint8_t padding[32];
-} mess_lsys_krn_sys_sdevio;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_sdevio);
-
-typedef struct {
-	clock_t exp_time;
-	clock_t time_left;
-	int abs_time;
-
-	uint8_t padding[44];
-} mess_lsys_krn_sys_setalarm;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setalarm);
-
-typedef struct {
-	vir_bytes addr;			/* cp_grant_t * */
-	int size;
-
-	uint8_t padding[48];
-} mess_lsys_krn_sys_setgrant;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setgrant);
-
-typedef struct {
-	endpoint_t endpt;
-	vir_bytes ctx_ptr;
-
-	uint8_t padding[48];
-} mess_lsys_krn_sys_setmcontext;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setmcontext);
-
-typedef struct {
-	time_t sec;		/* time in seconds since 1970 */
-	long int nsec;
-	int now;		/* non-zero for immediate, 0 for adjtime */
-	clockid_t clock_id;
-
-	uint8_t padding[36];
-} mess_lsys_krn_sys_settime;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_settime);
-
-typedef struct {
-	int action;
-	int freq;
-	int intr_type;
-	endpoint_t endpt;
-	vir_bytes ctl_ptr;
-	vir_bytes mem_ptr;
-	size_t mem_size;
-
-	uint8_t padding[28];
-} mess_lsys_krn_sys_sprof;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_sprof);
-
-typedef struct {
-	int request;
-
-	uint8_t padding[52];
-} mess_lsys_krn_sys_statectl;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_statectl);
-
-typedef struct {
-	time_t boot_time;
-
-	uint8_t padding[48];
-} mess_lsys_krn_sys_stime;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_stime);
-
-typedef struct {
-	endpoint_t endpt;
-
-	uint8_t padding[52];
-} mess_lsys_krn_sys_times;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_times);
-
-typedef struct {
-	int request;
-	endpoint_t endpt;
-	vir_bytes address;
-	long int data;
-
-	uint8_t padding[40];
-} mess_lsys_krn_sys_trace;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_trace);
-
-typedef struct {
-	endpoint_t src_endpt;
-	int segment;
-	vir_bytes src_addr;
-	endpoint_t dst_endpt;
-	int nr_bytes;
-
-	uint8_t padding[36];
-} mess_lsys_krn_sys_umap;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_umap);
-
-
-typedef struct {
-	int request;
-	int vec_size;
-	vir_bytes vec_addr;		/* pv{b,w,l}_pair_t * */
-
-	uint8_t padding[44];
-} mess_lsys_krn_sys_vdevio;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_vdevio);
-
-typedef struct {
-	endpoint_t endpt;
-	vir_bytes vaddr;			/* struct vumap_vir * */
-	int vcount;
-	vir_bytes paddr;			/* struct vumap_phys * */
-	int pmax;
-	int access;
-	size_t offset;
-
-	uint8_t padding[28];
-} mess_lsys_krn_sys_vumap;
-_ASSERT_MSG_SIZE(mess_lsys_krn_sys_vumap);
-
-typedef struct {
-	void		*vec_addr;
-	int		vec_size;
-	uint8_t padding[48];
-} mess_lsys_kern_vsafecopy;
-_ASSERT_MSG_SIZE(mess_lsys_kern_vsafecopy);
-
-typedef struct {
-	int devind;
-	int port;
-
-	uint8_t padding[48];
-} mess_lsys_pci_busc_get_bar;
-_ASSERT_MSG_SIZE(mess_lsys_pci_busc_get_bar);
-
-typedef struct {
-	endpoint_t endpt;
-
-	uint8_t padding[52];
-} mess_lsys_pm_getepinfo;
-_ASSERT_MSG_SIZE(mess_lsys_pm_getepinfo);
-
-typedef struct {
-	pid_t pid;
-
-	uint8_t padding[52];
-} mess_lsys_pm_getprocnr;
-_ASSERT_MSG_SIZE(mess_lsys_pm_getprocnr);
-
-typedef struct {
-	uid_t uid;
-	gid_t gid;
-
-	uint8_t padding[48];
-} mess_lsys_pm_srv_fork;
-_ASSERT_MSG_SIZE(mess_lsys_pm_srv_fork);
-
-typedef struct {
-	endpoint_t endpoint;
-	endpoint_t parent;
-	int maxprio;
-	int quantum;
-
-	uint8_t padding[40];
-} mess_lsys_sched_scheduling_start;
-_ASSERT_MSG_SIZE(mess_lsys_sched_scheduling_start);
-
-typedef struct {
-	endpoint_t endpoint;
-
-	uint8_t padding[52];
-} mess_lsys_sched_scheduling_stop;
-_ASSERT_MSG_SIZE(mess_lsys_sched_scheduling_stop);
-
-typedef struct {
-	int request;
-	vir_bytes arg;
-
-	uint8_t padding[48];
-} mess_lsys_svrctl;
-_ASSERT_MSG_SIZE(mess_lsys_svrctl);
-
-typedef struct {
-	int request;
-	int fkeys;
-	int sfkeys;
-
-	uint8_t padding[44];
-} mess_lsys_tty_fkey_ctl;
-_ASSERT_MSG_SIZE(mess_lsys_tty_fkey_ctl);
-
-typedef struct {
-	endpoint_t endpt;
-	cp_grant_id_t grant;
-	size_t count;
-
-	uint8_t padding[44];
-} mess_lsys_vfs_checkperms;
-_ASSERT_MSG_SIZE(mess_lsys_vfs_checkperms);
-
-typedef struct {
-	endpoint_t endpt;
-	int fd;
-	int what;
-
-	uint8_t padding[44];
-} mess_lsys_vfs_copyfd;
-_ASSERT_MSG_SIZE(mess_lsys_vfs_copyfd);
-
-typedef struct {
-	devmajor_t major;
-	size_t labellen;
-	vir_bytes label;
-
-	uint8_t padding[44];
-} mess_lsys_vfs_mapdriver;
-_ASSERT_MSG_SIZE(mess_lsys_vfs_mapdriver);
-
-typedef struct {
-	endpoint_t	endpt;
-	void		*addr;
-	int		retc;
-	uint8_t		padding[44];
-} mess_lsys_vm_getref;
-_ASSERT_MSG_SIZE(mess_lsys_vm_getref);
-
-typedef struct {
-	int		what;
-	endpoint_t	ep;
-	int		count;
-	void		*ptr;
-	vir_bytes	next;
-	uint8_t		padding[36];
-} mess_lsys_vm_info;
-_ASSERT_MSG_SIZE(mess_lsys_vm_info);
-
-typedef struct {
-	endpoint_t	ep;
-	phys_bytes	phaddr;
-	size_t		len;
-	void		*reply;
-	uint8_t		padding[40];
-} mess_lsys_vm_map_phys;
-_ASSERT_MSG_SIZE(mess_lsys_vm_map_phys);
-
-typedef struct {
-	endpoint_t	ret_pt;
-	int		is_more;
-	uint8_t		padding[48];
-} mess_lsys_vm_query_exit;
-_ASSERT_MSG_SIZE(mess_lsys_vm_query_exit);
-
-typedef struct {
-	endpoint_t	ep;
-	void		*vaddr;
-	uint8_t		padding[48];
-} mess_lsys_vm_unmap_phys;
-_ASSERT_MSG_SIZE(mess_lsys_vm_unmap_phys);
-
-typedef struct {
-	endpoint_t src;
-	endpoint_t dst;
-	uint8_t		padding[48];
-} mess_lsys_vm_update;
-_ASSERT_MSG_SIZE(mess_lsys_vm_update);
-
-typedef struct {
-	endpoint_t	destination;
-	endpoint_t	source;
-	void		*dest_addr;
-	void		*src_addr;
-	size_t		size;
-	void		*ret_addr;
-	uint8_t		padding[32];
-} mess_lsys_vm_vmremap;
-_ASSERT_MSG_SIZE(mess_lsys_vm_vmremap);
-
-typedef struct {
-	endpoint_t	ep;
-	uint8_t		padding[52];
-} mess_lsys_vm_watch_exit;
-_ASSERT_MSG_SIZE(mess_lsys_vm_watch_exit);
-
-typedef struct {
-	off_t offset;
-	void *addr;
-	size_t len;
-	int prot;
-	int flags;
-	int fd;
-	endpoint_t forwhom;
-	void *retaddr;
-	u32_t padding[5];
-} mess_mmap;
-_ASSERT_MSG_SIZE(mess_mmap);
-
-typedef struct {
-	int mode;
-
-	uint8_t padding[52];
-} mess_net_netdrv_dl_conf;
-_ASSERT_MSG_SIZE(mess_net_netdrv_dl_conf);
-
-typedef struct {
-	cp_grant_id_t grant;
-
-	uint8_t padding[52];
-} mess_net_netdrv_dl_getstat_s;
-_ASSERT_MSG_SIZE(mess_net_netdrv_dl_getstat_s);
-
-typedef struct {
-	cp_grant_id_t grant;
-	int count;
-
-	uint8_t padding[48];
-} mess_net_netdrv_dl_readv_s;
-_ASSERT_MSG_SIZE(mess_net_netdrv_dl_readv_s);
-
-typedef struct {
-	cp_grant_id_t grant;
-	int count;
-
-	uint8_t padding[48];
-} mess_net_netdrv_dl_writev_s;
-_ASSERT_MSG_SIZE(mess_net_netdrv_dl_writev_s);
-
-typedef struct {
-	int stat;
-	uint8_t hw_addr[6];
-
-	uint8_t padding[46];
-} mess_netdrv_net_dl_conf;
-_ASSERT_MSG_SIZE(mess_netdrv_net_dl_conf);
-
-typedef struct {
-	int count;
-	uint32_t flags;
-
-	uint8_t padding[48];
-} mess_netdrv_net_dl_task;
-_ASSERT_MSG_SIZE(mess_netdrv_net_dl_task);
-
-typedef struct {
-	u64_t timestamp;	/* valid for every notify msg */
-	u64_t interrupts;	/* raised interrupts; valid if from HARDWARE */
-	sigset_t sigset;	/* raised signals; valid if from SYSTEM */
-	uint8_t padding[24];
-} mess_notify;
-_ASSERT_MSG_SIZE(mess_notify);
-
-typedef struct {
-	int base;
-	size_t size;
-	uint32_t flags;
-
-	uint8_t padding[44];
-} mess_pci_lsys_busc_get_bar;
-_ASSERT_MSG_SIZE(mess_pci_lsys_busc_get_bar);
-
-typedef struct {
-	uid_t egid;
-
-	uint8_t padding[52];
-} mess_pm_lc_getgid;
-_ASSERT_MSG_SIZE(mess_pm_lc_getgid);
-
-typedef struct {
-	pid_t parent_pid;
-
-	uint8_t padding[52];
-} mess_pm_lc_getpid;
-_ASSERT_MSG_SIZE(mess_pm_lc_getpid);
-
-typedef struct {
-	uid_t euid;
-
-	uint8_t padding[52];
-} mess_pm_lc_getuid;
-_ASSERT_MSG_SIZE(mess_pm_lc_getuid);
-
-typedef struct {
-	long data;
-
-	uint8_t padding[52];
-} mess_pm_lc_ptrace;
-_ASSERT_MSG_SIZE(mess_pm_lc_ptrace);
-
-typedef struct {
-	sigset_t set;
-
-	uint8_t padding[40];
-} mess_pm_lc_sigset;
-_ASSERT_MSG_SIZE(mess_pm_lc_sigset);
-
-typedef struct {
-	time_t sec;
-
-	long nsec;
-
-	uint8_t padding[44];
-} mess_pm_lc_time;
-_ASSERT_MSG_SIZE(mess_pm_lc_time);
-
-typedef struct {
-	int status;
-
-	uint8_t padding[52];
-} mess_pm_lc_waitpid;
-_ASSERT_MSG_SIZE(mess_pm_lc_waitpid);
-
-typedef struct {
-	int suid;
-
-	uint8_t padding[52];
-} mess_pm_lexec_exec_new;
-_ASSERT_MSG_SIZE(mess_pm_lexec_exec_new);
-
-typedef struct {
-	uid_t uid;
-	gid_t gid;
-
-	uint8_t padding[48];
-} mess_pm_lsys_getepinfo;
-_ASSERT_MSG_SIZE(mess_pm_lsys_getepinfo);
-
-typedef struct {
-	endpoint_t endpt;
-
-	uint8_t padding[52];
-} mess_pm_lsys_getprocnr;
-_ASSERT_MSG_SIZE(mess_pm_lsys_getprocnr);
-
-typedef struct {
-	int num;
-
-	uint8_t padding[52];
-} mess_pm_lsys_sigs_signal;
-_ASSERT_MSG_SIZE(mess_pm_lsys_sigs_signal);
-
-typedef struct {
-	endpoint_t endpoint;
-	uint32_t maxprio;
-
-	uint8_t padding[48];
-} mess_pm_sched_scheduling_set_nice;
-_ASSERT_MSG_SIZE(mess_pm_sched_scheduling_set_nice);
-
-typedef struct {
-	int status;
-
-	uint8_t padding[52];
-} mess_readclock_lc_rtcdev;
-_ASSERT_MSG_SIZE(mess_readclock_lc_rtcdev);
-
-typedef struct {
-	int		result;
-	int		type;
-	cp_grant_id_t	rproctab_gid;
-	endpoint_t	old_endpoint;
-	uint8_t padding[40];
-} mess_rs_init;
-_ASSERT_MSG_SIZE(mess_rs_init);
-
-typedef struct {
-	endpoint_t endpt;
-	int result;
-	vir_bytes pc;
-	vir_bytes ps_str;
-
-	uint8_t padding[40];
-} mess_rs_pm_exec_restart;
-_ASSERT_MSG_SIZE(mess_rs_pm_exec_restart);
-
-typedef struct {
-	pid_t pid;
-	int nr;
-
-	uint8_t padding[48];
-} mess_rs_pm_srv_kill;
-_ASSERT_MSG_SIZE(mess_rs_pm_srv_kill);
-
-typedef struct {
-	int		len;
-	int		name_len;
-	endpoint_t	endpoint;
-	void		*addr;
-	const char	*name;
-	uint8_t padding[36];
-} mess_rs_req;
-_ASSERT_MSG_SIZE(mess_rs_req);
-
-typedef struct {
-	int		result;
-	int		state;
-	int		prepare_maxtime;
-	uint8_t padding[44];
-} mess_rs_update;
-_ASSERT_MSG_SIZE(mess_rs_update);
-
-typedef struct {
-	endpoint_t scheduler;
-
-	uint8_t padding[52];
-} mess_sched_lsys_scheduling_start;
-_ASSERT_MSG_SIZE(mess_sched_lsys_scheduling_start);
-
-/* For SYS_GETKSIG, _ENDKSIG, _KILL, _SIGSEND, _SIGRETURN. */
-typedef struct {
-	sigset_t map;		/* used to pass signal bit map */
-	endpoint_t endpt;	/* process number for inform */
-	int sig;		/* signal number to send */
-	void *sigctx;		/* pointer to signal context */
-	uint8_t padding[28];
-} mess_sigcalls;
-_ASSERT_MSG_SIZE(mess_sigcalls);
-
-typedef struct {
-	int fkeys;
-	int sfkeys;
-
-	uint8_t padding[48];
-} mess_tty_lsys_fkey_ctl;
-_ASSERT_MSG_SIZE(mess_tty_lsys_fkey_ctl);
-
-typedef struct {
-	dev_t device;
-	off_t seek_pos;
-
-	cp_grant_id_t grant;
-	size_t nbytes;
-
-	uint8_t data[32];
-} mess_vfs_fs_breadwrite;
-_ASSERT_MSG_SIZE(mess_vfs_fs_breadwrite);
-
-typedef struct {
-	ino_t inode;
-
-	mode_t mode;
-
-	uint8_t data[44];
-} mess_vfs_fs_chmod;
-_ASSERT_MSG_SIZE(mess_vfs_fs_chmod);
-
-typedef struct {
-	ino_t inode;
-
-	uid_t uid;
-	gid_t gid;
-
-	uint8_t data[40];
-} mess_vfs_fs_chown;
-_ASSERT_MSG_SIZE(mess_vfs_fs_chown);
-
-typedef struct {
-	ino_t inode;
-
-	mode_t mode;
-	uid_t uid;
-	gid_t gid;
-	cp_grant_id_t grant;
-	size_t path_len;
-
-	uint8_t data[28];
-} mess_vfs_fs_create;
-_ASSERT_MSG_SIZE(mess_vfs_fs_create);
-
-typedef struct {
-	dev_t device;
-
-	uint8_t data[48];
-} mess_vfs_fs_flush;
-_ASSERT_MSG_SIZE(mess_vfs_fs_flush);
-
-typedef struct {
-	ino_t inode;
-	off_t trc_start;
-	off_t trc_end;
-
-	uint8_t data[32];
-} mess_vfs_fs_ftrunc;
-_ASSERT_MSG_SIZE(mess_vfs_fs_ftrunc);
-
-typedef struct {
-	ino_t inode;
-	off_t seek_pos;
-
-	cp_grant_id_t grant;
-	size_t mem_size;
-
-	uint8_t data[32];
-} mess_vfs_fs_getdents;
-_ASSERT_MSG_SIZE(mess_vfs_fs_getdents);
-
-typedef struct {
-	ino_t inode;
-
-	uint8_t data[48];
-} mess_vfs_fs_inhibread;
-_ASSERT_MSG_SIZE(mess_vfs_fs_inhibread);
-
-typedef struct {
-	ino_t inode;
-	ino_t dir_ino;
-
-	cp_grant_id_t grant;
-	size_t path_len;
-
-	uint8_t data[32];
-} mess_vfs_fs_link;
-_ASSERT_MSG_SIZE(mess_vfs_fs_link);
-
-typedef struct {
-	ino_t dir_ino;
-	ino_t root_ino;
-
-	uint32_t flags;
-	size_t path_len;
-	size_t path_size;
-	size_t ucred_size;
-	cp_grant_id_t grant_path;
-	cp_grant_id_t grant_ucred;
-	uid_t uid;
-	gid_t gid;
-
-	uint8_t data[8];
-} mess_vfs_fs_lookup;
-_ASSERT_MSG_SIZE(mess_vfs_fs_lookup);
-
-typedef struct {
-	ino_t inode;
-
-	mode_t mode;
-	uid_t uid;
-	gid_t gid;
-	cp_grant_id_t grant;
-	size_t path_len;
-
-	uint8_t data[28];
-} mess_vfs_fs_mkdir;
-_ASSERT_MSG_SIZE(mess_vfs_fs_mkdir);
-
-typedef struct {
-	dev_t device;
-	ino_t inode;
-
-	mode_t mode;
-	uid_t uid;
-	gid_t gid;
-	cp_grant_id_t grant;
-	size_t path_len;
-
-	uint8_t data[20];
-} mess_vfs_fs_mknod;
-_ASSERT_MSG_SIZE(mess_vfs_fs_mknod);
-
-typedef struct {
-	ino_t inode;
-
-	uint8_t data[48];
-} mess_vfs_fs_mountpoint;
-_ASSERT_MSG_SIZE(mess_vfs_fs_mountpoint);
-
-typedef struct {
-	dev_t device;
-
-	cp_grant_id_t grant;
-	size_t path_len;
-
-	uint8_t data[40];
-} mess_vfs_fs_new_driver;
-_ASSERT_MSG_SIZE(mess_vfs_fs_new_driver);
-
-typedef struct {
-	dev_t device;
-
-	mode_t mode;
-	uid_t uid;
-	gid_t gid;
-
-	uint8_t data[36];
-} mess_vfs_fs_newnode;
-_ASSERT_MSG_SIZE(mess_vfs_fs_newnode);
-
-typedef struct {
-	uint64_t count;
-	ino_t inode;
-
-	uint8_t data[40];
-} mess_vfs_fs_putnode;
-_ASSERT_MSG_SIZE(mess_vfs_fs_putnode);
-
-typedef struct {
-	ino_t inode;
-
-	cp_grant_id_t grant;
-	size_t mem_size;
-
-	uint8_t data[40];
-} mess_vfs_fs_rdlink;
-_ASSERT_MSG_SIZE(mess_vfs_fs_rdlink);
-
-typedef struct {
-	dev_t device;
-
-	uint32_t flags;
-	size_t path_len;
-	cp_grant_id_t grant;
-
-	uint8_t data[36];
-} mess_vfs_fs_readsuper;
-_ASSERT_MSG_SIZE(mess_vfs_fs_readsuper);
-
-typedef struct {
-	ino_t inode;
-	off_t seek_pos;
-
-	cp_grant_id_t grant;
-	size_t nbytes;
-
-	uint8_t data[32];
-} mess_vfs_fs_readwrite;
-_ASSERT_MSG_SIZE(mess_vfs_fs_readwrite);
-
-typedef struct {
-	ino_t dir_old;
-	ino_t dir_new;
-
-	size_t len_old;
-	size_t len_new;
-	cp_grant_id_t grant_old;
-	cp_grant_id_t grant_new;
-
-	uint8_t data[24];
-} mess_vfs_fs_rename;
-_ASSERT_MSG_SIZE(mess_vfs_fs_rename);
-
-typedef struct {
-	ino_t inode;
-
-	size_t path_len;
-	size_t mem_size;
-	cp_grant_id_t grant_path;
-	cp_grant_id_t grant_target;
-	uid_t uid;
-	gid_t gid;
-
-	uint8_t data[24];
-} mess_vfs_fs_slink;
-_ASSERT_MSG_SIZE(mess_vfs_fs_slink);
-
-typedef struct {
-	ino_t inode;
-
-	cp_grant_id_t grant;
-
-	uint8_t data[44];
-} mess_vfs_fs_stat;
-_ASSERT_MSG_SIZE(mess_vfs_fs_stat);
-
-typedef struct {
-	cp_grant_id_t grant;
-
-	uint8_t data[52];
-} mess_vfs_fs_statvfs;
-_ASSERT_MSG_SIZE(mess_vfs_fs_statvfs);
-
-typedef struct {
-	ino_t inode;
-
-	cp_grant_id_t grant;
-	size_t path_len;
-
-	uint8_t data[40];
-} mess_vfs_fs_unlink;
-_ASSERT_MSG_SIZE(mess_vfs_fs_unlink);
-
-typedef struct {
-	ino_t inode;
-	time_t actime;
-	time_t modtime;
-
-	uint32_t acnsec;
-	uint32_t modnsec;
-
-	uint8_t data[24];
-} mess_vfs_fs_utime;
-_ASSERT_MSG_SIZE(mess_vfs_fs_utime);
-
-typedef struct {
-	off_t offset;
-
-	uint8_t padding[48];
-} mess_vfs_lc_lseek;
-_ASSERT_MSG_SIZE(mess_vfs_lc_lseek);
-
-typedef struct {
-	endpoint_t id;
-	devminor_t minor;
-
-	uint8_t padding[48];
-} mess_vfs_lchardriver_cancel;
-_ASSERT_MSG_SIZE(mess_vfs_lchardriver_cancel);
-
-typedef struct {
-	endpoint_t id;
-	endpoint_t user;
-	devminor_t minor;
-	int access;
-
-	uint8_t padding[40];
-} mess_vfs_lchardriver_openclose;
-_ASSERT_MSG_SIZE(mess_vfs_lchardriver_openclose);
-
-typedef struct {
-	off_t pos;
-	cp_grant_id_t grant;
-	size_t count;
-	int request;
-	int flags;
-	endpoint_t id;
-	endpoint_t user;
-	devminor_t minor;
-
-	uint8_t padding[20];
-} mess_vfs_lchardriver_readwrite;
-_ASSERT_MSG_SIZE(mess_vfs_lchardriver_readwrite);
-
-typedef struct {
-	devminor_t minor;
-	int ops;
-
-	uint8_t padding[48];
-} mess_vfs_lchardriver_select;
-_ASSERT_MSG_SIZE(mess_vfs_lchardriver_select);
-
-typedef struct {
-	time_t atime;
-	time_t mtime;
-	long ansec;
-	long mnsec;
-	size_t len;
-	char *name;
-	int fd;
-	int flags;
-	uint8_t padding[16];
-} mess_vfs_utimens;
-_ASSERT_MSG_SIZE(mess_vfs_utimens);
-
-typedef struct {
-	off_t offset;
-	dev_t dev;
-	ino_t ino;
-	endpoint_t who;
-	u32_t vaddr;
-	u32_t len;
-	u32_t flags;
-	u32_t fd;
-	u16_t clearend;
-	uint8_t padding[8];
-} mess_vm_vfs_mmap;
-_ASSERT_MSG_SIZE(mess_vm_vfs_mmap);
-
-typedef struct {
-	dev_t dev;	/* 64bits long. */
-	off_t dev_offset;
-	off_t ino_offset;
-	ino_t ino;
-	void *block;
-	u32_t *flags_ptr;
-	u8_t pages;
-	u8_t flags;
-	uint8_t padding[12];
-} mess_vmmcp;
-_ASSERT_MSG_SIZE(mess_vmmcp);
-
-typedef struct {
-	void *addr;
-	u8_t flags;
-	uint8_t padding[51];
-} mess_vmmcp_reply;
-_ASSERT_MSG_SIZE(mess_vmmcp_reply);
-
-typedef struct {
-	endpoint_t m_source;		/* who sent the message */
-	int m_type;			/* what kind of message is it */
-	union {
-		mess_u8			m_u8;
-		mess_u16		m_u16;
-		mess_u32		m_u32;
-		mess_u64		m_u64;
-
-		mess_1			m_m1;
-		mess_2			m_m2;
-		mess_3			m_m3;
-		mess_4			m_m4;
-		mess_7			m_m7;
-		mess_9			m_m9;
-		mess_10			m_m10;
-
-		mess_ds_reply		m_ds_reply;
-		mess_ds_req		m_ds_req;
-		mess_fs_vfs_breadwrite	m_fs_vfs_breadwrite;
-		mess_fs_vfs_chmod	m_fs_vfs_chmod;
-		mess_fs_vfs_chown	m_fs_vfs_chown;
-		mess_fs_vfs_create	m_fs_vfs_create;
-		mess_fs_vfs_getdents	m_fs_vfs_getdents;
-		mess_fs_vfs_lookup	m_fs_vfs_lookup;
-		mess_fs_vfs_newnode	m_fs_vfs_newnode;
-		mess_fs_vfs_rdlink	m_fs_vfs_rdlink;
-		mess_fs_vfs_readsuper	m_fs_vfs_readsuper;
-		mess_fs_vfs_readwrite	m_fs_vfs_readwrite;
-		mess_i2c_li2cdriver_busc_i2c_exec m_i2c_li2cdriver_busc_i2c_exec;
-		mess_i2c_li2cdriver_busc_i2c_reserve m_i2c_li2cdriver_busc_i2c_reserve;
-		mess_input_linputdriver_input_conf m_input_linputdriver_input_conf;
-		mess_input_linputdriver_setleds m_input_linputdriver_setleds;
-		mess_input_tty_event	m_input_tty_event;
-		mess_krn_lsys_schedule	m_krn_lsys_schedule;
-		mess_krn_lsys_sys_devio m_krn_lsys_sys_devio;
-		mess_krn_lsys_sys_fork m_krn_lsys_sys_fork;
-		mess_krn_lsys_sys_getwhoami m_krn_lsys_sys_getwhoami;
-		mess_krn_lsys_sys_irqctl m_krn_lsys_sys_irqctl;
-		mess_krn_lsys_sys_times	m_krn_lsys_sys_times;
-		mess_krn_lsys_sys_trace	m_krn_lsys_sys_trace;
-		mess_krn_lsys_sys_umap	m_krn_lsys_sys_umap;
-		mess_krn_lsys_sys_vumap	m_krn_lsys_sys_vumap;
-		mess_lbdev_lblockdriver_msg m_lbdev_lblockdriver_msg;
-		mess_lblockdriver_lbdev_reply m_lblockdriver_lbdev_reply;
-		mess_lc_ipc_semctl	m_lc_ipc_semctl;
-		mess_lc_ipc_semget	m_lc_ipc_semget;
-		mess_lc_ipc_semop	m_lc_ipc_semop;
-		mess_lc_ipc_shmat	m_lc_ipc_shmat;
-		mess_lc_ipc_shmctl	m_lc_ipc_shmctl;
-		mess_lc_ipc_shmdt	m_lc_ipc_shmdt;
-		mess_lc_ipc_shmget	m_lc_ipc_shmget;
-		mess_lc_pm_cprof	m_lc_pm_cprof;
-		mess_lc_pm_exec		m_lc_pm_exec;
-		mess_lc_pm_exit		m_lc_pm_exit;
-		mess_lc_pm_getsid	m_lc_pm_getsid;
-		mess_lc_pm_groups	m_lc_pm_groups;
-		mess_lc_pm_itimer	m_lc_pm_itimer;
-		mess_lc_pm_mcontext	m_lc_pm_mcontext;
-		mess_lc_pm_priority	m_lc_pm_priority;
-		mess_lc_pm_ptrace	m_lc_pm_ptrace;
-		mess_lc_pm_reboot	m_lc_pm_reboot;
-		mess_lc_pm_rusage	m_lc_pm_rusage;
-		mess_lc_pm_setgid	m_lc_pm_setgid;
-		mess_lc_pm_setuid	m_lc_pm_setuid;
-		mess_lc_pm_sig		m_lc_pm_sig;
-		mess_lc_pm_sigset	m_lc_pm_sigset;
-		mess_lc_pm_sprof	m_lc_pm_sprof;
-		mess_lc_pm_sysuname	m_lc_pm_sysuname;
-		mess_lc_pm_time		m_lc_pm_time;
-		mess_lc_pm_waitpid	m_lc_pm_waitpid;
-		mess_lc_readclock_rtcdev m_lc_readclock_rtcdev;
-		mess_lc_vfs_chown	m_lc_vfs_chown;
-		mess_lc_vfs_close	m_lc_vfs_close;
-		mess_lc_vfs_creat	m_lc_vfs_creat;
-		mess_lc_vfs_fchdir	m_lc_vfs_fchdir;
-		mess_lc_vfs_fchmod	m_lc_vfs_fchmod;
-		mess_lc_vfs_fcntl	m_lc_vfs_fcntl;
-		mess_lc_vfs_fstat	m_lc_vfs_fstat;
-		mess_lc_vfs_fsync	m_lc_vfs_fsync;
-		mess_lc_vfs_gcov	m_lc_vfs_gcov;
-		mess_lc_vfs_getvfsstat	m_lc_vfs_getvfsstat;
-		mess_lc_vfs_ioctl	m_lc_vfs_ioctl;
-		mess_lc_vfs_link	m_lc_vfs_link;
-		mess_lc_vfs_lseek	m_lc_vfs_lseek;
-		mess_lc_vfs_mknod	m_lc_vfs_mknod;
-		mess_lc_vfs_mount	m_lc_vfs_mount;
-		mess_lc_vfs_path	m_lc_vfs_path;
-		mess_lc_vfs_pipe2	m_lc_vfs_pipe2;
-		mess_lc_vfs_readlink	m_lc_vfs_readlink;
-		mess_lc_vfs_readwrite	m_lc_vfs_readwrite;
-		mess_lc_vfs_rusage	m_lc_vfs_rusage;
-		mess_lc_vfs_select	m_lc_vfs_select;
-		mess_lc_vfs_stat	m_lc_vfs_stat;
-		mess_lc_vfs_statvfs1	m_lc_vfs_statvfs1;
-		mess_lc_vfs_truncate	m_lc_vfs_truncate;
-		mess_lc_vfs_umask	m_lc_vfs_umask;
-		mess_lc_vfs_umount	m_lc_vfs_umount;
-		mess_lc_vm_brk		m_lc_vm_brk;
-		mess_lc_vm_getphys	m_lc_vm_getphys;
-		mess_lc_vm_rusage	m_lc_vm_rusage;
-		mess_lc_vm_shm_unmap	m_lc_vm_shm_unmap;
-		mess_lchardriver_vfs_reply m_lchardriver_vfs_reply;
-		mess_lchardriver_vfs_sel1 m_lchardriver_vfs_sel1;
-		mess_lchardriver_vfs_sel2 m_lchardriver_vfs_sel2;
-		mess_lexec_pm_exec_new	m_lexec_pm_exec_new;
-		mess_li2cdriver_i2c_busc_i2c_exec m_li2cdriver_i2c_busc_i2c_exec;
-		mess_li2cdriver_i2c_busc_i2c_reserve m_li2cdriver_i2c_busc_i2c_reserve;
-		mess_linputdriver_input_event m_linputdriver_input_event;
-		mess_lsys_fi_ctl	m_lsys_fi_ctl;
-		mess_lsys_fi_reply	m_lsys_fi_reply;
-		mess_lsys_getsysinfo	m_lsys_getsysinfo;
-		mess_lsys_krn_readbios	m_lsys_krn_readbios;
-		mess_lsys_kern_safecopy	m_lsys_kern_safecopy;
-		mess_lsys_krn_schedctl	m_lsys_krn_schedctl;
-		mess_lsys_krn_schedule	m_lsys_krn_schedule;
-		mess_lsys_krn_sys_abort m_lsys_krn_sys_abort;
-		mess_lsys_krn_sys_clear m_lsys_krn_sys_clear;
-		mess_lsys_krn_sys_copy	m_lsys_krn_sys_copy;
-		mess_lsys_krn_sys_cprof m_lsys_krn_sys_cprof;
-		mess_lsys_krn_sys_devio m_lsys_krn_sys_devio;
-		mess_lsys_krn_sys_diagctl m_lsys_krn_sys_diagctl;
-		mess_lsys_krn_sys_exec	m_lsys_krn_sys_exec;
-		mess_lsys_krn_sys_fork	m_lsys_krn_sys_fork;
-		mess_lsys_krn_sys_getinfo m_lsys_krn_sys_getinfo;
-		mess_lsys_krn_sys_getmcontext m_lsys_krn_sys_getmcontext;
-		mess_lsys_krn_sys_iopenable m_lsys_krn_sys_iopenable;
-		mess_lsys_krn_sys_irqctl m_lsys_krn_sys_irqctl;
-		mess_lsys_krn_sys_memset m_lsys_krn_sys_memset;
-		mess_lsys_krn_sys_privctl m_lsys_krn_sys_privctl;
-		mess_lsys_krn_sys_profbuf m_lsys_krn_sys_profbuf;
-		mess_lsys_krn_sys_sdevio m_lsys_krn_sys_sdevio;
-		mess_lsys_krn_sys_setalarm m_lsys_krn_sys_setalarm;
-		mess_lsys_krn_sys_setgrant m_lsys_krn_sys_setgrant;
-		mess_lsys_krn_sys_setmcontext m_lsys_krn_sys_setmcontext;
-		mess_lsys_krn_sys_settime m_lsys_krn_sys_settime;
-		mess_lsys_krn_sys_sprof m_lsys_krn_sys_sprof;
-		mess_lsys_krn_sys_statectl m_lsys_krn_sys_statectl;
-		mess_lsys_krn_sys_stime	m_lsys_krn_sys_stime;
-		mess_lsys_krn_sys_times	m_lsys_krn_sys_times;
-		mess_lsys_krn_sys_trace	m_lsys_krn_sys_trace;
-		mess_lsys_krn_sys_umap	m_lsys_krn_sys_umap;
-		mess_lsys_krn_sys_vdevio m_lsys_krn_sys_vdevio;
-		mess_lsys_krn_sys_vumap m_lsys_krn_sys_vumap;
-		mess_lsys_kern_vsafecopy m_lsys_kern_vsafecopy;
-		mess_lsys_pci_busc_get_bar m_lsys_pci_busc_get_bar;
-		mess_lsys_pm_getepinfo	m_lsys_pm_getepinfo;
-		mess_lsys_pm_getprocnr	m_lsys_pm_getprocnr;
-		mess_lsys_pm_srv_fork	m_lsys_pm_srv_fork;
-		mess_lsys_sched_scheduling_start m_lsys_sched_scheduling_start;
-		mess_lsys_sched_scheduling_stop m_lsys_sched_scheduling_stop;
-		mess_lsys_svrctl	m_lsys_svrctl;
-		mess_lsys_tty_fkey_ctl	m_lsys_tty_fkey_ctl;
-		mess_lsys_vfs_checkperms m_lsys_vfs_checkperms;
-		mess_lsys_vfs_copyfd	m_lsys_vfs_copyfd;
-		mess_lsys_vfs_mapdriver	m_lsys_vfs_mapdriver;
-		mess_lsys_vm_getref	m_lsys_vm_getref;
-		mess_lsys_vm_info	m_lsys_vm_info;
-		mess_lsys_vm_map_phys	m_lsys_vm_map_phys;
-		mess_lsys_vm_query_exit	m_lsys_vm_query_exit;
-		mess_lsys_vm_unmap_phys	m_lsys_vm_unmap_phys;
-		mess_lsys_vm_update	m_lsys_vm_update;
-		mess_lsys_vm_vmremap	m_lsys_vm_vmremap;
-		mess_lsys_vm_watch_exit	m_lsys_vm_watch_exit;
-		mess_mmap		m_mmap;
-		mess_net_netdrv_dl_conf m_net_netdrv_dl_conf;
-		mess_net_netdrv_dl_getstat_s m_net_netdrv_dl_getstat_s;
-		mess_net_netdrv_dl_readv_s m_net_netdrv_dl_readv_s;
-		mess_net_netdrv_dl_writev_s m_net_netdrv_dl_writev_s;
-		mess_netdrv_net_dl_conf m_netdrv_net_dl_conf;
-		mess_netdrv_net_dl_task m_netdrv_net_dl_task;
-		mess_notify		m_notify;
-		mess_pci_lsys_busc_get_bar m_pci_lsys_busc_get_bar;
-		mess_pm_lc_getgid	m_pm_lc_getgid;
-		mess_pm_lc_getpid	m_pm_lc_getpid;
-		mess_pm_lc_getuid	m_pm_lc_getuid;
-		mess_pm_lc_ptrace	m_pm_lc_ptrace;
-		mess_pm_lc_sigset	m_pm_lc_sigset;
-		mess_pm_lc_time		m_pm_lc_time;
-		mess_pm_lc_waitpid	m_pm_lc_waitpid;
-		mess_pm_lexec_exec_new	m_pm_lexec_exec_new;
-		mess_pm_lsys_getepinfo	m_pm_lsys_getepinfo;
-		mess_pm_lsys_getprocnr	m_pm_lsys_getprocnr;
-		mess_pm_lsys_sigs_signal m_pm_lsys_sigs_signal;
-		mess_pm_sched_scheduling_set_nice m_pm_sched_scheduling_set_nice;
-		mess_readclock_lc_rtcdev m_readclock_lc_rtcdev;
-		mess_rs_init		m_rs_init;
-		mess_rs_pm_exec_restart	m_rs_pm_exec_restart;
-		mess_rs_pm_srv_kill	m_rs_pm_srv_kill;
-		mess_rs_req		m_rs_req;
-		mess_rs_update		m_rs_update;
-		mess_sched_lsys_scheduling_start m_sched_lsys_scheduling_start;
-		mess_sigcalls		m_sigcalls;
-		mess_tty_lsys_fkey_ctl	m_tty_lsys_fkey_ctl;
-		mess_vfs_fs_breadwrite	m_vfs_fs_breadwrite;
-		mess_vfs_fs_chmod	m_vfs_fs_chmod;
-		mess_vfs_fs_chown	m_vfs_fs_chown;
-		mess_vfs_fs_create	m_vfs_fs_create;
-		mess_vfs_fs_flush	m_vfs_fs_flush;
-		mess_vfs_fs_ftrunc	m_vfs_fs_ftrunc;
-		mess_vfs_fs_getdents	m_vfs_fs_getdents;
-		mess_vfs_fs_inhibread	m_vfs_fs_inhibread;
-		mess_vfs_fs_link	m_vfs_fs_link;
-		mess_vfs_fs_lookup	m_vfs_fs_lookup;
-		mess_vfs_fs_mkdir	m_vfs_fs_mkdir;
-		mess_vfs_fs_mknod	m_vfs_fs_mknod;
-		mess_vfs_fs_mountpoint	m_vfs_fs_mountpoint;
-		mess_vfs_fs_new_driver	m_vfs_fs_new_driver;
-		mess_vfs_fs_newnode	m_vfs_fs_newnode;
-		mess_vfs_fs_putnode	m_vfs_fs_putnode;
-		mess_vfs_fs_rdlink	m_vfs_fs_rdlink;
-		mess_vfs_fs_readsuper	m_vfs_fs_readsuper;
-		mess_vfs_fs_readwrite	m_vfs_fs_readwrite;
-		mess_vfs_fs_rename	m_vfs_fs_rename;
-		mess_vfs_fs_slink	m_vfs_fs_slink;
-		mess_vfs_fs_stat	m_vfs_fs_stat;
-		mess_vfs_fs_statvfs	m_vfs_fs_statvfs;
-		mess_vfs_fs_unlink	m_vfs_fs_unlink;
-		mess_vfs_fs_utime	m_vfs_fs_utime;
-		mess_vfs_lc_lseek	m_vfs_lc_lseek;
-		mess_vfs_lchardriver_cancel	m_vfs_lchardriver_cancel;
-		mess_vfs_lchardriver_openclose	m_vfs_lchardriver_openclose;
-		mess_vfs_lchardriver_readwrite	m_vfs_lchardriver_readwrite;
-		mess_vfs_lchardriver_select	m_vfs_lchardriver_select;
-		mess_vfs_utimens	m_vfs_utimens;
-		mess_vm_vfs_mmap	m_vm_vfs_mmap;
-		mess_vmmcp		m_vmmcp;
-		mess_vmmcp_reply	m_vmmcp_reply;
-
-		u8_t size[56];	/* message payload may have 56 bytes at most */
-	};
-} message __aligned(16);
-
-/* Ensure the complete union respects the IPC assumptions. */
-typedef int _ASSERT_message[/* CONSTCOND */sizeof(message) == 64 ? 1 : -1];
-
-/* The following defines provide names for useful members. */
-#define m1_i1  m_m1.m1i1
-#define m1_i2  m_m1.m1i2
-#define m1_i3  m_m1.m1i3
-#define m1_p1  m_m1.m1p1
-#define m1_p2  m_m1.m1p2
-#define m1_p3  m_m1.m1p3
-#define m1_p4  m_m1.m1p4
-#define m1_ull1  m_m1.m1ull1
-
-#define m2_ll1  m_m2.m2ll1
-#define m2_i1  m_m2.m2i1
-#define m2_i2  m_m2.m2i2
-#define m2_i3  m_m2.m2i3
-#define m2_l1  m_m2.m2l1
-#define m2_l2  m_m2.m2l2
-#define m2_p1  m_m2.m2p1
-#define m2_sigset  m_m2.sigset
-
-#define m2_s1  m_m2.m2s1
-
-#define m3_i1  m_m3.m3i1
-#define m3_i2  m_m3.m3i2
-#define m3_p1  m_m3.m3p1
-#define m3_ca1 m_m3.m3ca1
-
-#define m4_ll1  m_m4.m4ll1
-#define m4_l1  m_m4.m4l1
-#define m4_l2  m_m4.m4l2
-#define m4_l3  m_m4.m4l3
-#define m4_l4  m_m4.m4l4
-#define m4_l5  m_m4.m4l5
-
-#define m7_i1  m_m7.m7i1
-#define m7_i2  m_m7.m7i2
-#define m7_i3  m_m7.m7i3
-#define m7_i4  m_m7.m7i4
-#define m7_i5  m_m7.m7i5
-#define m7_p1  m_m7.m7p1
-#define m7_p2  m_m7.m7p2
-
-#define m9_l1  m_m9.m9l1
-#define m9_l2  m_m9.m9l2
-#define m9_l3  m_m9.m9l3
-#define m9_l4  m_m9.m9l4
-#define m9_l5  m_m9.m9l5
-#define m9_s1  m_m9.m9s1
-#define m9_s2  m_m9.m9s2
-#define m9_s3  m_m9.m9s3
-#define m9_s4  m_m9.m9s4
-#define m9_ull1  m_m9.m9ull1
-#define m9_ull2  m_m9.m9ull2
-
-#define m10_i1 m_m10.m10i1
-#define m10_i2 m_m10.m10i2
-#define m10_i3 m_m10.m10i3
-#define m10_i4 m_m10.m10i4
-#define m10_l1 m_m10.m10l1
-#define m10_l2 m_m10.m10l2
-#define m10_l3 m_m10.m10l3
-#define m10_ull1 m_m10.m10ull1
-
-
-/*==========================================================================* 
- * Minix run-time system (IPC). 					    *
- *==========================================================================*/ 
-
-/* Datastructure for asynchronous sends */
-typedef struct asynmsg
-{
-	unsigned flags;
-	endpoint_t dst;
-	int result;
-	message msg;
-} asynmsg_t;
-
-/* Defines for flags field */
-#define AMF_EMPTY	000	/* slot is not inuse */
-#define AMF_VALID	001	/* slot contains message */
-#define AMF_DONE	002	/* Kernel has processed the message. The
-				 * result is stored in 'result'
-				 */
-#define AMF_NOTIFY	004	/* Send a notification when AMF_DONE is set */
-#define AMF_NOREPLY	010	/* Not a reply message for a SENDREC */
-#define AMF_NOTIFY_ERR	020	/* Send a notification when AMF_DONE is set and
-				 * delivery of the message failed */
-
-int _ipc_send_intr(endpoint_t dest, message *m_ptr);
-int _ipc_receive_intr(endpoint_t src, message *m_ptr, int *status_ptr);
-int _ipc_sendrec_intr(endpoint_t src_dest, message *m_ptr);
-int _ipc_sendnb_intr(endpoint_t dest, message *m_ptr);
-int _ipc_notify_intr(endpoint_t dest);
-int _ipc_senda_intr(asynmsg_t *table, size_t count);
-
-int _do_kernel_call_intr(message *m_ptr);
-
-int get_minix_kerninfo(struct minix_kerninfo **);
-
-/* Hide names to avoid name space pollution. */
-#define ipc_notify	_ipc_notify
-#define ipc_sendrec	_ipc_sendrec
-#define ipc_receive	_ipc_receive
-#define ipc_receivenb	_ipc_receivenb
-#define ipc_send	_ipc_send
-#define ipc_sendnb	_ipc_sendnb
-#define ipc_senda	_ipc_senda
-
-#define do_kernel_call	_do_kernel_call
-
-struct minix_ipcvecs {
-	int (*send)(endpoint_t dest, message *m_ptr);
-	int (*receive)(endpoint_t src, message *m_ptr, int *st);
-	int (*sendrec)(endpoint_t src_dest, message *m_ptr);
-	int (*sendnb)(endpoint_t dest, message *m_ptr);
-	int (*notify)(endpoint_t dest);
-	int (*do_kernel_call)(message *m_ptr);
-	int (*senda)(asynmsg_t *table, size_t count);
-};
-
-/* kernel-set IPC vectors retrieved by a constructor in
- * minix/lib/libc/sys/init.c */
-extern struct minix_ipcvecs _minix_ipcvecs;
-
-static inline int _ipc_send(endpoint_t dest, message *m_ptr)
-{
-	return _minix_ipcvecs.send(dest, m_ptr);
-}
-
-static inline int _ipc_receive(endpoint_t src, message *m_ptr, int *st)
-{
-	return _minix_ipcvecs.receive(src, m_ptr, st);
-}
-
-static inline int _ipc_sendrec(endpoint_t src_dest, message *m_ptr)
-{
-	return _minix_ipcvecs.sendrec(src_dest, m_ptr);
-}
-
-static inline int _ipc_sendnb(endpoint_t dest, message *m_ptr)
-{
-	return _minix_ipcvecs.sendnb(dest, m_ptr);
-}
-
-static inline int _ipc_notify(endpoint_t dest)
-{
-	return _minix_ipcvecs.notify(dest);
-}
-
-static inline int _do_kernel_call(message *m_ptr)
-{
-	return _minix_ipcvecs.do_kernel_call(m_ptr);
-}
-
-static inline int _ipc_senda(asynmsg_t *table, size_t count)
-{
-	return _minix_ipcvecs.senda(table, count);
-}
-
-#endif /* _IPC_H */
+#ifndef _IPC_H
+#define _IPC_H
+
+#include <minix/ipcconst.h>
+#include <minix/type.h>
+#include <minix/const.h>
+#include <sys/signal.h>
+#include <sys/types.h>
+
+/*==========================================================================* 
+ * Types relating to messages. 						    *
+ *==========================================================================*/ 
+
+#define M_PATH_STRING_MAX  40
+
+typedef struct {
+	uint8_t data[56];
+} mess_u8;
+_ASSERT_MSG_SIZE(mess_u8);
+
+typedef struct {
+	uint16_t data[28];
+} mess_u16;
+_ASSERT_MSG_SIZE(mess_u16);
+
+typedef struct {
+	uint32_t data[14];
+} mess_u32;
+_ASSERT_MSG_SIZE(mess_u32);
+
+typedef struct {
+	uint64_t data[7];
+} mess_u64;
+_ASSERT_MSG_SIZE(mess_u64);
+
+typedef struct {
+	uint64_t m1ull1;
+	int m1i1, m1i2, m1i3;
+	char *m1p1, *m1p2, *m1p3, *m1p4;
+	uint8_t padding[20];
+} mess_1;
+_ASSERT_MSG_SIZE(mess_1);
+
+typedef struct {
+	int64_t m2ll1;
+	int m2i1, m2i2, m2i3;
+	long m2l1, m2l2;
+	char *m2p1;
+	sigset_t sigset;
+	short m2s1;
+	uint8_t padding[6];
+} mess_2;
+_ASSERT_MSG_SIZE(mess_2);
+
+typedef struct {
+	int m3i1, m3i2;
+	char *m3p1;
+	char m3ca1[44];
+} mess_3;
+_ASSERT_MSG_SIZE(mess_3);
+
+typedef struct {
+	int64_t m4ll1;
+	long m4l1, m4l2, m4l3, m4l4, m4l5;
+	uint8_t padding[28];
+} mess_4;
+_ASSERT_MSG_SIZE(mess_4);
+
+typedef struct {
+	int m7i1, m7i2, m7i3, m7i4, m7i5;
+	char *m7p1, *m7p2;
+	uint8_t padding[28];
+} mess_7;
+_ASSERT_MSG_SIZE(mess_7);
+
+typedef struct {
+	uint64_t m9ull1, m9ull2;
+	long m9l1, m9l2, m9l3, m9l4, m9l5;
+	short m9s1, m9s2, m9s3, m9s4;
+	uint8_t padding[12];
+} mess_9;
+_ASSERT_MSG_SIZE(mess_9);
+
+typedef struct {
+	u64_t m10ull1;
+	int m10i1, m10i2, m10i3, m10i4;
+	long m10l1, m10l2, m10l3;
+	uint8_t padding[20];
+} mess_10;
+_ASSERT_MSG_SIZE(mess_10);
+
+/* Helper union for DS messages */
+union	ds_val {
+	cp_grant_id_t	grant;
+	u32_t		u32;
+	endpoint_t	ep;
+};
+
+typedef struct {
+	union	ds_val 	val_out;
+	int	val_len;
+	uint8_t padding[48];
+} mess_ds_reply;
+_ASSERT_MSG_SIZE(mess_ds_reply);
+
+typedef struct {
+	cp_grant_id_t	key_grant;
+	int		key_len;
+	int		flags;
+	union ds_val 	val_in;
+	int		val_len;
+	endpoint_t	owner;
+	uint8_t padding[32];
+} mess_ds_req;
+_ASSERT_MSG_SIZE(mess_ds_req);
+
+typedef struct {
+	off_t seek_pos;
+
+	size_t nbytes;
+
+	uint8_t data[44];
+} mess_fs_vfs_breadwrite;
+_ASSERT_MSG_SIZE(mess_fs_vfs_breadwrite);
+
+typedef struct {
+	mode_t mode;
+
+	uint8_t data[52];
+} mess_fs_vfs_chmod;
+_ASSERT_MSG_SIZE(mess_fs_vfs_chmod);
+
+typedef struct {
+	mode_t mode;
+
+	uint8_t data[52];
+} mess_fs_vfs_chown;
+_ASSERT_MSG_SIZE(mess_fs_vfs_chown);
+
+typedef struct {
+	off_t file_size;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[28];
+} mess_fs_vfs_create;
+_ASSERT_MSG_SIZE(mess_fs_vfs_create);
+
+typedef struct {
+	off_t seek_pos;
+
+	size_t nbytes;
+
+	uint8_t data[44];
+} mess_fs_vfs_getdents;
+_ASSERT_MSG_SIZE(mess_fs_vfs_getdents);
+
+typedef struct {
+	off_t offset;
+	off_t file_size;
+	dev_t device;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint16_t symloop;
+
+	uint8_t data[10];
+} mess_fs_vfs_lookup;
+_ASSERT_MSG_SIZE(mess_fs_vfs_lookup);
+
+typedef struct {
+	off_t file_size;
+	dev_t device;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[20];
+} mess_fs_vfs_newnode;
+_ASSERT_MSG_SIZE(mess_fs_vfs_newnode);
+
+typedef struct {
+	size_t nbytes;
+
+	uint8_t data[52];
+} mess_fs_vfs_rdlink;
+_ASSERT_MSG_SIZE(mess_fs_vfs_rdlink);
+
+typedef struct {
+	off_t file_size;
+	dev_t device;
+	ino_t inode;
+
+	uint32_t flags;
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint16_t con_reqs;
+
+	uint8_t data[14];
+} mess_fs_vfs_readsuper;
+_ASSERT_MSG_SIZE(mess_fs_vfs_readsuper);
+
+typedef struct {
+	off_t seek_pos;
+
+	size_t nbytes;
+
+	uint8_t data[44];
+} mess_fs_vfs_readwrite;
+_ASSERT_MSG_SIZE(mess_fs_vfs_readwrite);
+
+typedef struct {
+	uint8_t padding[56];
+} mess_i2c_li2cdriver_busc_i2c_exec;
+_ASSERT_MSG_SIZE(mess_i2c_li2cdriver_busc_i2c_exec);
+
+typedef struct {
+	uint8_t padding[56];
+} mess_i2c_li2cdriver_busc_i2c_reserve;
+_ASSERT_MSG_SIZE(mess_i2c_li2cdriver_busc_i2c_reserve);
+
+typedef struct {
+	int kbd_id;
+	int mouse_id;
+	int rsvd1_id;
+	int rsvd2_id;
+
+	uint8_t padding[40];
+} mess_input_linputdriver_input_conf;
+_ASSERT_MSG_SIZE(mess_input_linputdriver_input_conf);
+
+typedef struct {
+	uint32_t led_mask;
+
+	uint8_t padding[52];
+} mess_input_linputdriver_setleds;
+_ASSERT_MSG_SIZE(mess_input_linputdriver_setleds);
+
+typedef struct {
+	int id;
+	int page;
+	int code;
+	int value;
+	int flags;
+
+	uint8_t padding[36];
+} mess_input_tty_event;
+_ASSERT_MSG_SIZE(mess_input_tty_event);
+
+typedef struct {
+	time_t acnt_queue;
+
+	unsigned long acnt_deqs;
+	unsigned long acnt_ipc_sync;
+	unsigned long acnt_ipc_async;
+	unsigned long acnt_preempt;
+	uint32_t acnt_cpu;
+	uint32_t acnt_cpu_load;
+
+	uint8_t padding[24];
+} mess_krn_lsys_schedule;
+_ASSERT_MSG_SIZE(mess_krn_lsys_schedule);
+
+typedef struct {
+	uint32_t value;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_devio;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_devio);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes msgaddr;
+
+	uint8_t padding[48];
+} mess_krn_lsys_sys_fork;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_fork);
+
+typedef struct {
+	endpoint_t endpt;
+	int privflags;
+	char name[48];
+
+} mess_krn_lsys_sys_getwhoami;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_getwhoami);
+
+typedef struct {
+	int hook_id;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_irqctl;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_irqctl);
+
+typedef struct {
+	clock_t real_ticks;
+	clock_t boot_ticks;
+	clock_t boot_time;
+	clock_t user_time;
+	clock_t system_time;
+
+	uint8_t padding[36];
+} mess_krn_lsys_sys_times;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_times);
+
+typedef struct {
+	long int data;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_trace;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_trace);
+
+typedef struct {
+	phys_bytes dst_addr;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_umap;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_umap);
+
+typedef struct {
+	int pcount;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_vumap;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_vumap);
+
+typedef struct {
+	off_t pos;
+
+	int minor;
+	int id;
+	int access;
+
+	int count;
+	cp_grant_id_t grant;
+	int flags;
+
+	endpoint_t user;
+	int request;
+
+	uint8_t padding[16];
+} mess_lbdev_lblockdriver_msg;
+_ASSERT_MSG_SIZE(mess_lbdev_lblockdriver_msg);
+
+typedef struct {
+	int status;
+	int id;
+
+	uint8_t padding[48];
+} mess_lblockdriver_lbdev_reply;
+_ASSERT_MSG_SIZE(mess_lblockdriver_lbdev_reply);
+
+typedef struct {
+	int		id;
+	int		num;
+	int		cmd;
+	int		opt;
+	int		ret;
+	uint8_t		padding[36];
+} mess_lc_ipc_semctl;
+_ASSERT_MSG_SIZE(mess_lc_ipc_semctl);
+
+typedef struct {
+	key_t		key;
+	int		nr;
+	int		flag;
+	int		retid;
+	uint8_t		padding[40];
+} mess_lc_ipc_semget;
+_ASSERT_MSG_SIZE(mess_lc_ipc_semget);
+
+typedef struct {
+	int		id;
+	void		*ops;
+	unsigned int	size;
+	uint8_t		padding[42];
+} mess_lc_ipc_semop;
+_ASSERT_MSG_SIZE(mess_lc_ipc_semop);
+
+typedef struct {
+	int		id;
+	const void	*addr;
+	int		flag;
+	void		*retaddr;
+	uint8_t		padding[40];
+} mess_lc_ipc_shmat;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmat);
+
+typedef struct {
+	int		id;
+	int		cmd;
+	void		*buf;
+	int		ret;
+	uint8_t		padding[40];
+} mess_lc_ipc_shmctl;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmctl);
+
+typedef struct {
+	const void	*addr;
+	uint8_t		padding[52];
+} mess_lc_ipc_shmdt;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmdt);
+
+typedef struct {
+	key_t		key;
+	size_t		size;
+	int		flag;
+	int		retid;
+	uint8_t		padding[40];
+} mess_lc_ipc_shmget;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmget);
+
+typedef struct {
+	int action;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[40];
+} mess_lc_pm_cprof;
+_ASSERT_MSG_SIZE(mess_lc_pm_cprof);
+
+typedef struct {
+	vir_bytes name;
+	size_t namelen;
+	vir_bytes frame;
+	size_t framelen;
+	vir_bytes ps_str;
+
+	uint8_t padding[36];
+} mess_lc_pm_exec;
+_ASSERT_MSG_SIZE(mess_lc_pm_exec);
+
+typedef struct {
+	int status;
+
+	uint8_t padding[52];
+} mess_lc_pm_exit;
+_ASSERT_MSG_SIZE(mess_lc_pm_exit);
+
+typedef struct {
+	pid_t pid;
+
+	uint8_t padding[52];
+} mess_lc_pm_getsid;
+_ASSERT_MSG_SIZE(mess_lc_pm_getsid);
+
+typedef struct {
+	int num;
+	vir_bytes ptr;		/* gid_t * */
+
+	uint8_t padding[48];
+} mess_lc_pm_groups;
+_ASSERT_MSG_SIZE(mess_lc_pm_groups);
+
+typedef struct {
+	int which;
+	vir_bytes value;	/* const struct itimerval * */
+	vir_bytes ovalue;	/* struct itimerval * */
+
+	uint8_t padding[44];
+} mess_lc_pm_itimer;
+_ASSERT_MSG_SIZE(mess_lc_pm_itimer);
+
+typedef struct {
+	vir_bytes ctx;		/* mcontext_t * */
+
+	uint8_t padding[52];
+} mess_lc_pm_mcontext;
+_ASSERT_MSG_SIZE(mess_lc_pm_mcontext);
+
+typedef struct {
+	int which;
+	int who;
+	int prio;
+
+	uint8_t padding[44];
+} mess_lc_pm_priority;
+_ASSERT_MSG_SIZE(mess_lc_pm_priority);
+
+typedef struct {
+	pid_t pid;
+	int req;
+	vir_bytes addr;
+	long data;
+
+	uint8_t padding[40];
+} mess_lc_pm_ptrace;
+_ASSERT_MSG_SIZE(mess_lc_pm_ptrace);
+
+typedef struct {
+	int how;
+
+	uint8_t padding[52];
+} mess_lc_pm_reboot;
+_ASSERT_MSG_SIZE(mess_lc_pm_reboot);
+
+typedef struct {
+	endpoint_t who;
+	vir_bytes addr;
+
+	uint8_t padding[48];
+} mess_lc_pm_rusage;
+_ASSERT_MSG_SIZE(mess_lc_pm_rusage);
+
+typedef struct {
+	gid_t gid;
+
+	uint8_t padding[52];
+} mess_lc_pm_setgid;
+_ASSERT_MSG_SIZE(mess_lc_pm_setgid);
+
+typedef struct {
+	uid_t uid;
+
+	uint8_t padding[52];
+} mess_lc_pm_setuid;
+_ASSERT_MSG_SIZE(mess_lc_pm_setuid);
+
+typedef struct {
+	pid_t pid;
+	int nr;
+	vir_bytes act;		/* const struct sigaction * */
+	vir_bytes oact;		/* struct sigaction * */
+	vir_bytes ret;		/* int (*)(void) */
+
+	uint8_t padding[36];
+} mess_lc_pm_sig;
+_ASSERT_MSG_SIZE(mess_lc_pm_sig);
+
+typedef struct {
+	int how;
+	vir_bytes ctx;
+	sigset_t set;
+
+	uint8_t padding[32];
+} mess_lc_pm_sigset;
+_ASSERT_MSG_SIZE(mess_lc_pm_sigset);
+
+typedef struct {
+	int action;
+	int freq;
+	int intr_type;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[32];
+} mess_lc_pm_sprof;
+_ASSERT_MSG_SIZE(mess_lc_pm_sprof);
+
+typedef struct {
+	int req;
+	int field;
+	size_t len;
+	vir_bytes value;
+
+	uint8_t padding[40];
+} mess_lc_pm_sysuname;
+_ASSERT_MSG_SIZE(mess_lc_pm_sysuname);
+
+typedef struct {
+	time_t sec;
+
+	clockid_t clk_id;
+	int now;
+	long nsec;
+
+	uint8_t padding[36];
+} mess_lc_pm_time;
+_ASSERT_MSG_SIZE(mess_lc_pm_time);
+
+typedef struct {
+	pid_t pid;
+	int options;
+
+	uint8_t padding[48];
+} mess_lc_pm_waitpid;
+_ASSERT_MSG_SIZE(mess_lc_pm_waitpid);
+
+typedef struct {
+	cp_grant_id_t grant;
+	vir_bytes tm;			/* struct tm * */
+	int flags;
+
+	uint8_t padding[44];
+} mess_lc_readclock_rtcdev;
+_ASSERT_MSG_SIZE(mess_lc_readclock_rtcdev);
+
+typedef struct {
+	vir_bytes name;
+	size_t len;
+	int fd;
+	uid_t owner;
+	gid_t group;
+
+	uint8_t padding[36];
+} mess_lc_vfs_chown;
+_ASSERT_MSG_SIZE(mess_lc_vfs_chown);
+
+typedef struct {
+	int fd;
+
+	uint8_t padding[52];
+} mess_lc_vfs_close;
+_ASSERT_MSG_SIZE(mess_lc_vfs_close);
+
+typedef struct {
+	vir_bytes name;
+	size_t len;
+	int flags;
+	mode_t mode;
+
+	uint8_t padding[40];
+} mess_lc_vfs_creat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_creat);
+
+typedef struct {
+	int fd;
+
+	uint8_t padding[52];
+} mess_lc_vfs_fchdir;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fchdir);
+
+typedef struct {
+	int fd;
+	mode_t mode;
+
+	uint8_t padding[48];
+} mess_lc_vfs_fchmod;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fchmod);
+
+typedef struct {
+	int fd;
+	int cmd;
+	int arg_int;
+	vir_bytes arg_ptr;	/* struct flock * */
+
+	uint8_t padding[40];
+} mess_lc_vfs_fcntl;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fcntl);
+
+typedef struct {
+	int fd;
+	vir_bytes buf;		/* struct stat * */
+
+	uint8_t padding[48];
+} mess_lc_vfs_fstat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fstat);
+
+typedef struct {
+	int fd;
+
+	uint8_t padding[52];
+} mess_lc_vfs_fsync;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fsync);
+
+typedef struct {
+	cp_grant_id_t grant;
+	int pid;
+	vir_bytes buff_p;
+	size_t buff_sz;
+
+	uint8_t padding[40];
+} mess_lc_vfs_gcov;
+_ASSERT_MSG_SIZE(mess_lc_vfs_gcov);
+
+typedef struct {
+	int32_t flags;
+	size_t len;
+	vir_bytes buf;		/* struct statvfs */
+
+	uint8_t padding[44];
+} mess_lc_vfs_getvfsstat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_getvfsstat);
+
+typedef struct {
+	int fd;
+	unsigned long req;
+	vir_bytes arg;
+
+	uint8_t padding[44];
+} mess_lc_vfs_ioctl;
+_ASSERT_MSG_SIZE(mess_lc_vfs_ioctl);
+
+typedef struct {
+	vir_bytes name1;
+	vir_bytes name2;
+	size_t len1;
+	size_t len2;
+
+	uint8_t padding[40];
+} mess_lc_vfs_link;
+_ASSERT_MSG_SIZE(mess_lc_vfs_link);
+
+typedef struct {
+	off_t offset;
+
+	int fd;
+	int whence;
+
+	uint8_t padding[40];
+} mess_lc_vfs_lseek;
+_ASSERT_MSG_SIZE(mess_lc_vfs_lseek);
+
+typedef struct {
+	dev_t device;
+
+	vir_bytes name;
+	size_t len;
+	mode_t mode;
+
+	uint8_t padding[36];
+} mess_lc_vfs_mknod;
+_ASSERT_MSG_SIZE(mess_lc_vfs_mknod);
+
+typedef struct {
+	int flags;
+	size_t devlen;
+	size_t pathlen;
+	size_t typelen;
+	size_t labellen;
+	vir_bytes dev;
+	vir_bytes path;
+	vir_bytes type;
+	vir_bytes label;
+
+	uint8_t padding[20];
+} mess_lc_vfs_mount;
+_ASSERT_MSG_SIZE(mess_lc_vfs_mount);
+
+typedef struct {
+	vir_bytes name;
+	size_t len;
+	int flags;
+	mode_t mode;
+	char buf[M_PATH_STRING_MAX];
+} mess_lc_vfs_path;
+_ASSERT_MSG_SIZE(mess_lc_vfs_path);
+
+typedef struct {
+	int fd0;
+	int fd1;
+	int flags;
+
+	uint8_t padding[44];
+} mess_lc_vfs_pipe2;
+_ASSERT_MSG_SIZE(mess_lc_vfs_pipe2);
+
+typedef struct {
+	vir_bytes name;		/* const char * */
+	size_t namelen;
+	vir_bytes buf;
+	size_t bufsize;
+
+	uint8_t padding[40];
+} mess_lc_vfs_readlink;
+_ASSERT_MSG_SIZE(mess_lc_vfs_readlink);
+
+typedef struct {
+	int fd;
+	vir_bytes buf;
+	size_t len;
+
+	uint8_t padding[44];
+} mess_lc_vfs_readwrite;
+_ASSERT_MSG_SIZE(mess_lc_vfs_readwrite);
+
+typedef struct {
+	vir_bytes addr;
+
+	uint8_t padding[52];
+} mess_lc_vfs_rusage;
+_ASSERT_MSG_SIZE(mess_lc_vfs_rusage);
+
+typedef struct {
+	uint32_t nfds;
+	fd_set *readfds;
+	fd_set *writefds;
+	fd_set *errorfds;
+	vir_bytes timeout;	/* user-provided 'struct timeval *' */
+
+	uint8_t padding[36];
+} mess_lc_vfs_select;
+_ASSERT_MSG_SIZE(mess_lc_vfs_select);
+
+typedef struct {
+	size_t len;
+	vir_bytes name;		/* const char * */
+	vir_bytes buf;		/* struct stat * */
+
+	uint8_t padding[44];
+} mess_lc_vfs_stat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_stat);
+
+typedef struct {
+	int fd;
+	int flags;
+	size_t len;
+	vir_bytes name;
+	vir_bytes buf;
+
+	uint8_t padding[36];
+} mess_lc_vfs_statvfs1;
+_ASSERT_MSG_SIZE(mess_lc_vfs_statvfs1);
+
+typedef struct {
+	off_t offset;
+
+	int fd;
+	vir_bytes name;
+	size_t len;
+
+	uint8_t padding[36];
+} mess_lc_vfs_truncate;
+_ASSERT_MSG_SIZE(mess_lc_vfs_truncate);
+
+typedef struct {
+	mode_t mask;
+
+	uint8_t padding[52];
+} mess_lc_vfs_umask;
+_ASSERT_MSG_SIZE(mess_lc_vfs_umask);
+
+typedef struct {
+	vir_bytes name;
+	size_t namelen;
+	vir_bytes label;
+	size_t labellen;
+
+	uint8_t padding[40];
+} mess_lc_vfs_umount;
+_ASSERT_MSG_SIZE(mess_lc_vfs_umount);
+
+typedef struct {
+	void		*addr;
+	uint8_t		padding[52];
+} mess_lc_vm_brk;
+_ASSERT_MSG_SIZE(mess_lc_vm_brk);
+
+typedef struct {
+	endpoint_t	endpt;
+	void		*addr;
+	void		*ret_addr;
+	uint8_t		padding[44];
+} mess_lc_vm_getphys;
+_ASSERT_MSG_SIZE(mess_lc_vm_getphys);
+
+typedef struct {
+	vir_bytes addr;
+
+	uint8_t padding[52];
+} mess_lc_vm_rusage;
+_ASSERT_MSG_SIZE(mess_lc_vm_rusage);
+
+typedef struct {
+	endpoint_t	forwhom;
+	void		*addr;
+	uint8_t		padding[48];
+} mess_lc_vm_shm_unmap;
+_ASSERT_MSG_SIZE(mess_lc_vm_shm_unmap);
+
+typedef struct {
+	int status;
+	uint32_t id;		/* should be cdev_id_t */
+
+	uint8_t padding[48];
+} mess_lchardriver_vfs_reply;
+_ASSERT_MSG_SIZE(mess_lchardriver_vfs_reply);
+
+typedef struct {
+	int status;
+	int32_t minor;
+
+	uint8_t padding[48];
+} mess_lchardriver_vfs_sel1;
+_ASSERT_MSG_SIZE(mess_lchardriver_vfs_sel1);
+
+typedef struct {
+	int status;
+	int32_t minor;
+
+	uint8_t padding[48];
+} mess_lchardriver_vfs_sel2;
+_ASSERT_MSG_SIZE(mess_lchardriver_vfs_sel2);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ptr;		/* struct exec_info * */
+
+	uint8_t padding[48];
+} mess_lexec_pm_exec_new;
+_ASSERT_MSG_SIZE(mess_lexec_pm_exec_new);
+
+typedef struct {
+	cp_grant_id_t grant;
+
+	uint8_t padding[52];
+} mess_li2cdriver_i2c_busc_i2c_exec;
+_ASSERT_MSG_SIZE(mess_li2cdriver_i2c_busc_i2c_exec);
+
+typedef struct {
+	uint16_t addr; /* FIXME: strictly speaking this is an i2c_addr_t, but
+			  to get it I would need to include
+			  sys/dev/i2c/i2c_io.h, which I am not sure is a good
+			  idea to have everywhere. */
+
+	uint8_t padding[54];
+} mess_li2cdriver_i2c_busc_i2c_reserve;
+_ASSERT_MSG_SIZE(mess_li2cdriver_i2c_busc_i2c_reserve);
+
+typedef struct {
+	int id;
+	int page;
+	int code;
+	int value;
+	int flags;
+
+	uint8_t padding[36];
+} mess_linputdriver_input_event;
+_ASSERT_MSG_SIZE(mess_linputdriver_input_event);
+
+typedef struct {
+        cp_grant_id_t gid;
+	size_t size;
+
+        uint8_t padding[48];
+} mess_lsys_fi_ctl;
+_ASSERT_MSG_SIZE(mess_lsys_fi_ctl);
+
+typedef struct {
+        int status;
+
+        uint8_t padding[52];
+} mess_lsys_fi_reply;
+_ASSERT_MSG_SIZE(mess_lsys_fi_reply);
+
+typedef struct {
+	int what;
+	vir_bytes where;
+	size_t size;
+
+	uint8_t padding[44];
+} mess_lsys_getsysinfo;
+_ASSERT_MSG_SIZE(mess_lsys_getsysinfo);
+
+typedef struct {
+	size_t size;
+	phys_bytes addr;
+	vir_bytes buf;
+
+	uint8_t padding[44];
+} mess_lsys_krn_readbios;
+_ASSERT_MSG_SIZE(mess_lsys_krn_readbios);
+
+typedef struct {
+	endpoint_t	from_to;
+	cp_grant_id_t	gid;
+	size_t		offset;
+	void		*address;
+	size_t		bytes;
+	uint8_t padding[36];
+} mess_lsys_kern_safecopy;
+_ASSERT_MSG_SIZE(mess_lsys_kern_safecopy);
+
+typedef struct {
+	uint32_t flags;
+	endpoint_t endpoint;
+	int priority;
+	int quantum;
+	int cpu;
+
+	uint8_t padding[36];
+} mess_lsys_krn_schedctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_schedctl);
+
+typedef struct {
+	endpoint_t endpoint;
+	int quantum;
+	int priority;
+	int cpu;
+
+	uint8_t padding[40];
+} mess_lsys_krn_schedule;
+_ASSERT_MSG_SIZE(mess_lsys_krn_schedule);
+
+typedef struct {
+	int how;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_abort;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_abort);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_clear;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_clear);
+
+typedef struct {
+	endpoint_t src_endpt;
+	vir_bytes src_addr;
+	endpoint_t dst_endpt;
+	vir_bytes dst_addr;
+	phys_bytes nr_bytes;
+	int flags;
+
+	uint8_t padding[32];
+} mess_lsys_krn_sys_copy;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_copy);
+
+typedef struct {
+	endpoint_t endpt;
+	int action;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_cprof;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_cprof);
+
+typedef struct {
+	int request;
+	int port;
+	uint32_t value;
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_devio;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_devio);
+
+typedef struct {
+	int code;
+	vir_bytes buf;
+	int len;
+	endpoint_t endpt;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_diagctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_diagctl);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ip;
+	vir_bytes stack;
+	vir_bytes name;
+	vir_bytes ps_str;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_exec;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_exec);
+
+typedef struct {
+	endpoint_t endpt;
+	endpoint_t slot;
+	uint32_t flags;
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_fork;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_fork);
+
+typedef struct {
+	int request;
+	endpoint_t endpt;
+	vir_bytes val_ptr;
+	int val_len;
+	vir_bytes val_ptr2;
+	int val_len2_e;
+
+	uint8_t padding[32];
+} mess_lsys_krn_sys_getinfo;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_getinfo);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ctx_ptr;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_getmcontext;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_getmcontext);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_iopenable;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_iopenable);
+
+typedef struct {
+	int request;
+	int vector;
+	int policy;
+	int hook_id;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_irqctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_irqctl);
+
+typedef struct {
+	phys_bytes base;
+	phys_bytes count;
+	unsigned long pattern;
+	endpoint_t process;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_memset;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_memset);
+
+typedef struct {
+	int request;
+	endpoint_t endpt;
+	vir_bytes arg_ptr;
+	phys_bytes phys_start;
+	phys_bytes phys_len;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_privctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_privctl);
+
+typedef struct {
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_profbuf;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_profbuf);
+
+typedef struct {
+	int request;
+	long int port;
+	endpoint_t vec_endpt;
+	phys_bytes vec_addr;
+	vir_bytes vec_size;
+	vir_bytes offset;
+
+	uint8_t padding[32];
+} mess_lsys_krn_sys_sdevio;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_sdevio);
+
+typedef struct {
+	clock_t exp_time;
+	clock_t time_left;
+	int abs_time;
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_setalarm;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setalarm);
+
+typedef struct {
+	vir_bytes addr;			/* cp_grant_t * */
+	int size;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_setgrant;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setgrant);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ctx_ptr;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_setmcontext;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setmcontext);
+
+typedef struct {
+	time_t sec;		/* time in seconds since 1970 */
+	long int nsec;
+	int now;		/* non-zero for immediate, 0 for adjtime */
+	clockid_t clock_id;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_settime;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_settime);
+
+typedef struct {
+	int action;
+	int freq;
+	int intr_type;
+	endpoint_t endpt;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[28];
+} mess_lsys_krn_sys_sprof;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_sprof);
+
+typedef struct {
+	int request;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_statectl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_statectl);
+
+typedef struct {
+	time_t boot_time;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_stime;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_stime);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_times;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_times);
+
+typedef struct {
+	int request;
+	endpoint_t endpt;
+	vir_bytes address;
+	long int data;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_trace;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_trace);
+
+typedef struct {
+	endpoint_t src_endpt;
+	int segment;
+	vir_bytes src_addr;
+	endpoint_t dst_endpt;
+	int nr_bytes;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_umap;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_umap);
+
+
+typedef struct {
+	int request;
+	int vec_size;
+	vir_bytes vec_addr;		/* pv{b,w,l}_pair_t * */
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_vdevio;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_vdevio);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes vaddr;			/* struct vumap_vir * */
+	int vcount;
+	vir_bytes paddr;			/* struct vumap_phys * */
+	int pmax;
+	int access;
+	size_t offset;
+
+	uint8_t padding[28];
+} mess_lsys_krn_sys_vumap;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_vumap);
+
+typedef struct {
+	void		*vec_addr;
+	int		vec_size;
+	uint8_t padding[48];
+} mess_lsys_kern_vsafecopy;
+_ASSERT_MSG_SIZE(mess_lsys_kern_vsafecopy);
+
+typedef struct {
+	int devind;
+	int port;
+
+	uint8_t padding[48];
+} mess_lsys_pci_busc_get_bar;
+_ASSERT_MSG_SIZE(mess_lsys_pci_busc_get_bar);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_pm_getepinfo;
+_ASSERT_MSG_SIZE(mess_lsys_pm_getepinfo);
+
+typedef struct {
+	pid_t pid;
+
+	uint8_t padding[52];
+} mess_lsys_pm_getprocnr;
+_ASSERT_MSG_SIZE(mess_lsys_pm_getprocnr);
+
+typedef struct {
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t padding[48];
+} mess_lsys_pm_srv_fork;
+_ASSERT_MSG_SIZE(mess_lsys_pm_srv_fork);
+
+typedef struct {
+	endpoint_t endpoint;
+	endpoint_t parent;
+	int maxprio;
+	int quantum;
+	int sh;
+	
+
+	uint8_t padding[36];
+} mess_lsys_sched_scheduling_start;
+_ASSERT_MSG_SIZE(mess_lsys_sched_scheduling_start);
+
+typedef struct {
+	endpoint_t endpoint;
+
+	uint8_t padding[52];
+} mess_lsys_sched_scheduling_stop;
+_ASSERT_MSG_SIZE(mess_lsys_sched_scheduling_stop);
+
+typedef struct {
+	int request;
+	vir_bytes arg;
+
+	uint8_t padding[48];
+} mess_lsys_svrctl;
+_ASSERT_MSG_SIZE(mess_lsys_svrctl);
+
+typedef struct {
+	int request;
+	int fkeys;
+	int sfkeys;
+
+	uint8_t padding[44];
+} mess_lsys_tty_fkey_ctl;
+_ASSERT_MSG_SIZE(mess_lsys_tty_fkey_ctl);
+
+typedef struct {
+	endpoint_t endpt;
+	cp_grant_id_t grant;
+	size_t count;
+
+	uint8_t padding[44];
+} mess_lsys_vfs_checkperms;
+_ASSERT_MSG_SIZE(mess_lsys_vfs_checkperms);
+
+typedef struct {
+	endpoint_t endpt;
+	int fd;
+	int what;
+
+	uint8_t padding[44];
+} mess_lsys_vfs_copyfd;
+_ASSERT_MSG_SIZE(mess_lsys_vfs_copyfd);
+
+typedef struct {
+	devmajor_t major;
+	size_t labellen;
+	vir_bytes label;
+
+	uint8_t padding[44];
+} mess_lsys_vfs_mapdriver;
+_ASSERT_MSG_SIZE(mess_lsys_vfs_mapdriver);
+
+typedef struct {
+	endpoint_t	endpt;
+	void		*addr;
+	int		retc;
+	uint8_t		padding[44];
+} mess_lsys_vm_getref;
+_ASSERT_MSG_SIZE(mess_lsys_vm_getref);
+
+typedef struct {
+	int		what;
+	endpoint_t	ep;
+	int		count;
+	void		*ptr;
+	vir_bytes	next;
+	uint8_t		padding[36];
+} mess_lsys_vm_info;
+_ASSERT_MSG_SIZE(mess_lsys_vm_info);
+
+typedef struct {
+	endpoint_t	ep;
+	phys_bytes	phaddr;
+	size_t		len;
+	void		*reply;
+	uint8_t		padding[40];
+} mess_lsys_vm_map_phys;
+_ASSERT_MSG_SIZE(mess_lsys_vm_map_phys);
+
+typedef struct {
+	endpoint_t	ret_pt;
+	int		is_more;
+	uint8_t		padding[48];
+} mess_lsys_vm_query_exit;
+_ASSERT_MSG_SIZE(mess_lsys_vm_query_exit);
+
+typedef struct {
+	endpoint_t	ep;
+	void		*vaddr;
+	uint8_t		padding[48];
+} mess_lsys_vm_unmap_phys;
+_ASSERT_MSG_SIZE(mess_lsys_vm_unmap_phys);
+
+typedef struct {
+	endpoint_t src;
+	endpoint_t dst;
+	uint8_t		padding[48];
+} mess_lsys_vm_update;
+_ASSERT_MSG_SIZE(mess_lsys_vm_update);
+
+typedef struct {
+	endpoint_t	destination;
+	endpoint_t	source;
+	void		*dest_addr;
+	void		*src_addr;
+	size_t		size;
+	void		*ret_addr;
+	uint8_t		padding[32];
+} mess_lsys_vm_vmremap;
+_ASSERT_MSG_SIZE(mess_lsys_vm_vmremap);
+
+typedef struct {
+	endpoint_t	ep;
+	uint8_t		padding[52];
+} mess_lsys_vm_watch_exit;
+_ASSERT_MSG_SIZE(mess_lsys_vm_watch_exit);
+
+typedef struct {
+	off_t offset;
+	void *addr;
+	size_t len;
+	int prot;
+	int flags;
+	int fd;
+	endpoint_t forwhom;
+	void *retaddr;
+	u32_t padding[5];
+} mess_mmap;
+_ASSERT_MSG_SIZE(mess_mmap);
+
+typedef struct {
+	int mode;
+
+	uint8_t padding[52];
+} mess_net_netdrv_dl_conf;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_conf);
+
+typedef struct {
+	cp_grant_id_t grant;
+
+	uint8_t padding[52];
+} mess_net_netdrv_dl_getstat_s;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_getstat_s);
+
+typedef struct {
+	cp_grant_id_t grant;
+	int count;
+
+	uint8_t padding[48];
+} mess_net_netdrv_dl_readv_s;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_readv_s);
+
+typedef struct {
+	cp_grant_id_t grant;
+	int count;
+
+	uint8_t padding[48];
+} mess_net_netdrv_dl_writev_s;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_writev_s);
+
+typedef struct {
+	int stat;
+	uint8_t hw_addr[6];
+
+	uint8_t padding[46];
+} mess_netdrv_net_dl_conf;
+_ASSERT_MSG_SIZE(mess_netdrv_net_dl_conf);
+
+typedef struct {
+	int count;
+	uint32_t flags;
+
+	uint8_t padding[48];
+} mess_netdrv_net_dl_task;
+_ASSERT_MSG_SIZE(mess_netdrv_net_dl_task);
+
+typedef struct {
+	u64_t timestamp;	/* valid for every notify msg */
+	u64_t interrupts;	/* raised interrupts; valid if from HARDWARE */
+	sigset_t sigset;	/* raised signals; valid if from SYSTEM */
+	uint8_t padding[24];
+} mess_notify;
+_ASSERT_MSG_SIZE(mess_notify);
+
+typedef struct {
+	int base;
+	size_t size;
+	uint32_t flags;
+
+	uint8_t padding[44];
+} mess_pci_lsys_busc_get_bar;
+_ASSERT_MSG_SIZE(mess_pci_lsys_busc_get_bar);
+
+typedef struct {
+	uid_t egid;
+
+	uint8_t padding[52];
+} mess_pm_lc_getgid;
+_ASSERT_MSG_SIZE(mess_pm_lc_getgid);
+
+typedef struct {
+	pid_t parent_pid;
+
+	uint8_t padding[52];
+} mess_pm_lc_getpid;
+_ASSERT_MSG_SIZE(mess_pm_lc_getpid);
+
+typedef struct {
+	uid_t euid;
+
+	uint8_t padding[52];
+} mess_pm_lc_getuid;
+_ASSERT_MSG_SIZE(mess_pm_lc_getuid);
+
+typedef struct {
+	long data;
+
+	uint8_t padding[52];
+} mess_pm_lc_ptrace;
+_ASSERT_MSG_SIZE(mess_pm_lc_ptrace);
+
+typedef struct {
+	sigset_t set;
+
+	uint8_t padding[40];
+} mess_pm_lc_sigset;
+_ASSERT_MSG_SIZE(mess_pm_lc_sigset);
+
+typedef struct {
+	time_t sec;
+
+	long nsec;
+
+	uint8_t padding[44];
+} mess_pm_lc_time;
+_ASSERT_MSG_SIZE(mess_pm_lc_time);
+
+typedef struct {
+	int status;
+
+	uint8_t padding[52];
+} mess_pm_lc_waitpid;
+_ASSERT_MSG_SIZE(mess_pm_lc_waitpid);
+
+typedef struct {
+	int suid;
+
+	uint8_t padding[52];
+} mess_pm_lexec_exec_new;
+_ASSERT_MSG_SIZE(mess_pm_lexec_exec_new);
+
+typedef struct {
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t padding[48];
+} mess_pm_lsys_getepinfo;
+_ASSERT_MSG_SIZE(mess_pm_lsys_getepinfo);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_pm_lsys_getprocnr;
+_ASSERT_MSG_SIZE(mess_pm_lsys_getprocnr);
+
+typedef struct {
+	int num;
+
+	uint8_t padding[52];
+} mess_pm_lsys_sigs_signal;
+_ASSERT_MSG_SIZE(mess_pm_lsys_sigs_signal);
+
+typedef struct {
+	endpoint_t endpoint;
+	uint32_t maxprio;
+	
+	uint8_t padding[48];
+} mess_pm_sched_scheduling_set_nice;
+_ASSERT_MSG_SIZE(mess_pm_sched_scheduling_set_nice);
+
+typedef struct {
+	int status;
+
+	uint8_t padding[52];
+} mess_readclock_lc_rtcdev;
+_ASSERT_MSG_SIZE(mess_readclock_lc_rtcdev);
+
+typedef struct {
+	int		result;
+	int		type;
+	cp_grant_id_t	rproctab_gid;
+	endpoint_t	old_endpoint;
+	uint8_t padding[40];
+} mess_rs_init;
+_ASSERT_MSG_SIZE(mess_rs_init);
+
+typedef struct {
+	endpoint_t endpt;
+	int result;
+	vir_bytes pc;
+	vir_bytes ps_str;
+
+	uint8_t padding[40];
+} mess_rs_pm_exec_restart;
+_ASSERT_MSG_SIZE(mess_rs_pm_exec_restart);
+
+typedef struct {
+	pid_t pid;
+	int nr;
+
+	uint8_t padding[48];
+} mess_rs_pm_srv_kill;
+_ASSERT_MSG_SIZE(mess_rs_pm_srv_kill);
+
+typedef struct {
+	int		len;
+	int		name_len;
+	endpoint_t	endpoint;
+	void		*addr;
+	const char	*name;
+	uint8_t padding[36];
+} mess_rs_req;
+_ASSERT_MSG_SIZE(mess_rs_req);
+
+typedef struct {
+	int		result;
+	int		state;
+	int		prepare_maxtime;
+	uint8_t padding[44];
+} mess_rs_update;
+_ASSERT_MSG_SIZE(mess_rs_update);
+
+typedef struct {
+	endpoint_t scheduler;
+	endpoint_t real_sched;
+	uint8_t padding[48];
+} mess_sched_lsys_scheduling_start;
+_ASSERT_MSG_SIZE(mess_sched_lsys_scheduling_start);
+
+/* For SYS_GETKSIG, _ENDKSIG, _KILL, _SIGSEND, _SIGRETURN. */
+typedef struct {
+	sigset_t map;		/* used to pass signal bit map */
+	endpoint_t endpt;	/* process number for inform */
+	int sig;		/* signal number to send */
+	void *sigctx;		/* pointer to signal context */
+	uint8_t padding[28];
+} mess_sigcalls;
+_ASSERT_MSG_SIZE(mess_sigcalls);
+
+typedef struct {
+	int fkeys;
+	int sfkeys;
+
+	uint8_t padding[48];
+} mess_tty_lsys_fkey_ctl;
+_ASSERT_MSG_SIZE(mess_tty_lsys_fkey_ctl);
+
+typedef struct {
+	dev_t device;
+	off_t seek_pos;
+
+	cp_grant_id_t grant;
+	size_t nbytes;
+
+	uint8_t data[32];
+} mess_vfs_fs_breadwrite;
+_ASSERT_MSG_SIZE(mess_vfs_fs_breadwrite);
+
+typedef struct {
+	ino_t inode;
+
+	mode_t mode;
+
+	uint8_t data[44];
+} mess_vfs_fs_chmod;
+_ASSERT_MSG_SIZE(mess_vfs_fs_chmod);
+
+typedef struct {
+	ino_t inode;
+
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[40];
+} mess_vfs_fs_chown;
+_ASSERT_MSG_SIZE(mess_vfs_fs_chown);
+
+typedef struct {
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[28];
+} mess_vfs_fs_create;
+_ASSERT_MSG_SIZE(mess_vfs_fs_create);
+
+typedef struct {
+	dev_t device;
+
+	uint8_t data[48];
+} mess_vfs_fs_flush;
+_ASSERT_MSG_SIZE(mess_vfs_fs_flush);
+
+typedef struct {
+	ino_t inode;
+	off_t trc_start;
+	off_t trc_end;
+
+	uint8_t data[32];
+} mess_vfs_fs_ftrunc;
+_ASSERT_MSG_SIZE(mess_vfs_fs_ftrunc);
+
+typedef struct {
+	ino_t inode;
+	off_t seek_pos;
+
+	cp_grant_id_t grant;
+	size_t mem_size;
+
+	uint8_t data[32];
+} mess_vfs_fs_getdents;
+_ASSERT_MSG_SIZE(mess_vfs_fs_getdents);
+
+typedef struct {
+	ino_t inode;
+
+	uint8_t data[48];
+} mess_vfs_fs_inhibread;
+_ASSERT_MSG_SIZE(mess_vfs_fs_inhibread);
+
+typedef struct {
+	ino_t inode;
+	ino_t dir_ino;
+
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[32];
+} mess_vfs_fs_link;
+_ASSERT_MSG_SIZE(mess_vfs_fs_link);
+
+typedef struct {
+	ino_t dir_ino;
+	ino_t root_ino;
+
+	uint32_t flags;
+	size_t path_len;
+	size_t path_size;
+	size_t ucred_size;
+	cp_grant_id_t grant_path;
+	cp_grant_id_t grant_ucred;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[8];
+} mess_vfs_fs_lookup;
+_ASSERT_MSG_SIZE(mess_vfs_fs_lookup);
+
+typedef struct {
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[28];
+} mess_vfs_fs_mkdir;
+_ASSERT_MSG_SIZE(mess_vfs_fs_mkdir);
+
+typedef struct {
+	dev_t device;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[20];
+} mess_vfs_fs_mknod;
+_ASSERT_MSG_SIZE(mess_vfs_fs_mknod);
+
+typedef struct {
+	ino_t inode;
+
+	uint8_t data[48];
+} mess_vfs_fs_mountpoint;
+_ASSERT_MSG_SIZE(mess_vfs_fs_mountpoint);
+
+typedef struct {
+	dev_t device;
+
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[40];
+} mess_vfs_fs_new_driver;
+_ASSERT_MSG_SIZE(mess_vfs_fs_new_driver);
+
+typedef struct {
+	dev_t device;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[36];
+} mess_vfs_fs_newnode;
+_ASSERT_MSG_SIZE(mess_vfs_fs_newnode);
+
+typedef struct {
+	uint64_t count;
+	ino_t inode;
+
+	uint8_t data[40];
+} mess_vfs_fs_putnode;
+_ASSERT_MSG_SIZE(mess_vfs_fs_putnode);
+
+typedef struct {
+	ino_t inode;
+
+	cp_grant_id_t grant;
+	size_t mem_size;
+
+	uint8_t data[40];
+} mess_vfs_fs_rdlink;
+_ASSERT_MSG_SIZE(mess_vfs_fs_rdlink);
+
+typedef struct {
+	dev_t device;
+
+	uint32_t flags;
+	size_t path_len;
+	cp_grant_id_t grant;
+
+	uint8_t data[36];
+} mess_vfs_fs_readsuper;
+_ASSERT_MSG_SIZE(mess_vfs_fs_readsuper);
+
+typedef struct {
+	ino_t inode;
+	off_t seek_pos;
+
+	cp_grant_id_t grant;
+	size_t nbytes;
+
+	uint8_t data[32];
+} mess_vfs_fs_readwrite;
+_ASSERT_MSG_SIZE(mess_vfs_fs_readwrite);
+
+typedef struct {
+	ino_t dir_old;
+	ino_t dir_new;
+
+	size_t len_old;
+	size_t len_new;
+	cp_grant_id_t grant_old;
+	cp_grant_id_t grant_new;
+
+	uint8_t data[24];
+} mess_vfs_fs_rename;
+_ASSERT_MSG_SIZE(mess_vfs_fs_rename);
+
+typedef struct {
+	ino_t inode;
+
+	size_t path_len;
+	size_t mem_size;
+	cp_grant_id_t grant_path;
+	cp_grant_id_t grant_target;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[24];
+} mess_vfs_fs_slink;
+_ASSERT_MSG_SIZE(mess_vfs_fs_slink);
+
+typedef struct {
+	ino_t inode;
+
+	cp_grant_id_t grant;
+
+	uint8_t data[44];
+} mess_vfs_fs_stat;
+_ASSERT_MSG_SIZE(mess_vfs_fs_stat);
+
+typedef struct {
+	cp_grant_id_t grant;
+
+	uint8_t data[52];
+} mess_vfs_fs_statvfs;
+_ASSERT_MSG_SIZE(mess_vfs_fs_statvfs);
+
+typedef struct {
+	ino_t inode;
+
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[40];
+} mess_vfs_fs_unlink;
+_ASSERT_MSG_SIZE(mess_vfs_fs_unlink);
+
+typedef struct {
+	ino_t inode;
+	time_t actime;
+	time_t modtime;
+
+	uint32_t acnsec;
+	uint32_t modnsec;
+
+	uint8_t data[24];
+} mess_vfs_fs_utime;
+_ASSERT_MSG_SIZE(mess_vfs_fs_utime);
+
+typedef struct {
+	off_t offset;
+
+	uint8_t padding[48];
+} mess_vfs_lc_lseek;
+_ASSERT_MSG_SIZE(mess_vfs_lc_lseek);
+
+typedef struct {
+	endpoint_t id;
+	devminor_t minor;
+
+	uint8_t padding[48];
+} mess_vfs_lchardriver_cancel;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_cancel);
+
+typedef struct {
+	endpoint_t id;
+	endpoint_t user;
+	devminor_t minor;
+	int access;
+
+	uint8_t padding[40];
+} mess_vfs_lchardriver_openclose;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_openclose);
+
+typedef struct {
+	off_t pos;
+	cp_grant_id_t grant;
+	size_t count;
+	int request;
+	int flags;
+	endpoint_t id;
+	endpoint_t user;
+	devminor_t minor;
+
+	uint8_t padding[20];
+} mess_vfs_lchardriver_readwrite;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_readwrite);
+
+typedef struct {
+	devminor_t minor;
+	int ops;
+
+	uint8_t padding[48];
+} mess_vfs_lchardriver_select;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_select);
+
+typedef struct {
+	time_t atime;
+	time_t mtime;
+	long ansec;
+	long mnsec;
+	size_t len;
+	char *name;
+	int fd;
+	int flags;
+	uint8_t padding[16];
+} mess_vfs_utimens;
+_ASSERT_MSG_SIZE(mess_vfs_utimens);
+
+typedef struct {
+	off_t offset;
+	dev_t dev;
+	ino_t ino;
+	endpoint_t who;
+	u32_t vaddr;
+	u32_t len;
+	u32_t flags;
+	u32_t fd;
+	u16_t clearend;
+	uint8_t padding[8];
+} mess_vm_vfs_mmap;
+_ASSERT_MSG_SIZE(mess_vm_vfs_mmap);
+
+typedef struct {
+	dev_t dev;	/* 64bits long. */
+	off_t dev_offset;
+	off_t ino_offset;
+	ino_t ino;
+	void *block;
+	u32_t *flags_ptr;
+	u8_t pages;
+	u8_t flags;
+	uint8_t padding[12];
+} mess_vmmcp;
+_ASSERT_MSG_SIZE(mess_vmmcp);
+
+typedef struct {
+	void *addr;
+	u8_t flags;
+	uint8_t padding[51];
+} mess_vmmcp_reply;
+_ASSERT_MSG_SIZE(mess_vmmcp_reply);
+
+typedef struct {
+	endpoint_t m_source;		/* who sent the message */
+	int m_type;			/* what kind of message is it */
+	union {
+		mess_u8			m_u8;
+		mess_u16		m_u16;
+		mess_u32		m_u32;
+		mess_u64		m_u64;
+
+		mess_1			m_m1;
+		mess_2			m_m2;
+		mess_3			m_m3;
+		mess_4			m_m4;
+		mess_7			m_m7;
+		mess_9			m_m9;
+		mess_10			m_m10;
+
+		mess_ds_reply		m_ds_reply;
+		mess_ds_req		m_ds_req;
+		mess_fs_vfs_breadwrite	m_fs_vfs_breadwrite;
+		mess_fs_vfs_chmod	m_fs_vfs_chmod;
+		mess_fs_vfs_chown	m_fs_vfs_chown;
+		mess_fs_vfs_create	m_fs_vfs_create;
+		mess_fs_vfs_getdents	m_fs_vfs_getdents;
+		mess_fs_vfs_lookup	m_fs_vfs_lookup;
+		mess_fs_vfs_newnode	m_fs_vfs_newnode;
+		mess_fs_vfs_rdlink	m_fs_vfs_rdlink;
+		mess_fs_vfs_readsuper	m_fs_vfs_readsuper;
+		mess_fs_vfs_readwrite	m_fs_vfs_readwrite;
+		mess_i2c_li2cdriver_busc_i2c_exec m_i2c_li2cdriver_busc_i2c_exec;
+		mess_i2c_li2cdriver_busc_i2c_reserve m_i2c_li2cdriver_busc_i2c_reserve;
+		mess_input_linputdriver_input_conf m_input_linputdriver_input_conf;
+		mess_input_linputdriver_setleds m_input_linputdriver_setleds;
+		mess_input_tty_event	m_input_tty_event;
+		mess_krn_lsys_schedule	m_krn_lsys_schedule;
+		mess_krn_lsys_sys_devio m_krn_lsys_sys_devio;
+		mess_krn_lsys_sys_fork m_krn_lsys_sys_fork;
+		mess_krn_lsys_sys_getwhoami m_krn_lsys_sys_getwhoami;
+		mess_krn_lsys_sys_irqctl m_krn_lsys_sys_irqctl;
+		mess_krn_lsys_sys_times	m_krn_lsys_sys_times;
+		mess_krn_lsys_sys_trace	m_krn_lsys_sys_trace;
+		mess_krn_lsys_sys_umap	m_krn_lsys_sys_umap;
+		mess_krn_lsys_sys_vumap	m_krn_lsys_sys_vumap;
+		mess_lbdev_lblockdriver_msg m_lbdev_lblockdriver_msg;
+		mess_lblockdriver_lbdev_reply m_lblockdriver_lbdev_reply;
+		mess_lc_ipc_semctl	m_lc_ipc_semctl;
+		mess_lc_ipc_semget	m_lc_ipc_semget;
+		mess_lc_ipc_semop	m_lc_ipc_semop;
+		mess_lc_ipc_shmat	m_lc_ipc_shmat;
+		mess_lc_ipc_shmctl	m_lc_ipc_shmctl;
+		mess_lc_ipc_shmdt	m_lc_ipc_shmdt;
+		mess_lc_ipc_shmget	m_lc_ipc_shmget;
+		mess_lc_pm_cprof	m_lc_pm_cprof;
+		mess_lc_pm_exec		m_lc_pm_exec;
+		mess_lc_pm_exit		m_lc_pm_exit;
+		mess_lc_pm_getsid	m_lc_pm_getsid;
+		mess_lc_pm_groups	m_lc_pm_groups;
+		mess_lc_pm_itimer	m_lc_pm_itimer;
+		mess_lc_pm_mcontext	m_lc_pm_mcontext;
+		mess_lc_pm_priority	m_lc_pm_priority;
+		mess_lc_pm_ptrace	m_lc_pm_ptrace;
+		mess_lc_pm_reboot	m_lc_pm_reboot;
+		mess_lc_pm_rusage	m_lc_pm_rusage;
+		mess_lc_pm_setgid	m_lc_pm_setgid;
+		mess_lc_pm_setuid	m_lc_pm_setuid;
+		mess_lc_pm_sig		m_lc_pm_sig;
+		mess_lc_pm_sigset	m_lc_pm_sigset;
+		mess_lc_pm_sprof	m_lc_pm_sprof;
+		mess_lc_pm_sysuname	m_lc_pm_sysuname;
+		mess_lc_pm_time		m_lc_pm_time;
+		mess_lc_pm_waitpid	m_lc_pm_waitpid;
+		mess_lc_readclock_rtcdev m_lc_readclock_rtcdev;
+		mess_lc_vfs_chown	m_lc_vfs_chown;
+		mess_lc_vfs_close	m_lc_vfs_close;
+		mess_lc_vfs_creat	m_lc_vfs_creat;
+		mess_lc_vfs_fchdir	m_lc_vfs_fchdir;
+		mess_lc_vfs_fchmod	m_lc_vfs_fchmod;
+		mess_lc_vfs_fcntl	m_lc_vfs_fcntl;
+		mess_lc_vfs_fstat	m_lc_vfs_fstat;
+		mess_lc_vfs_fsync	m_lc_vfs_fsync;
+		mess_lc_vfs_gcov	m_lc_vfs_gcov;
+		mess_lc_vfs_getvfsstat	m_lc_vfs_getvfsstat;
+		mess_lc_vfs_ioctl	m_lc_vfs_ioctl;
+		mess_lc_vfs_link	m_lc_vfs_link;
+		mess_lc_vfs_lseek	m_lc_vfs_lseek;
+		mess_lc_vfs_mknod	m_lc_vfs_mknod;
+		mess_lc_vfs_mount	m_lc_vfs_mount;
+		mess_lc_vfs_path	m_lc_vfs_path;
+		mess_lc_vfs_pipe2	m_lc_vfs_pipe2;
+		mess_lc_vfs_readlink	m_lc_vfs_readlink;
+		mess_lc_vfs_readwrite	m_lc_vfs_readwrite;
+		mess_lc_vfs_rusage	m_lc_vfs_rusage;
+		mess_lc_vfs_select	m_lc_vfs_select;
+		mess_lc_vfs_stat	m_lc_vfs_stat;
+		mess_lc_vfs_statvfs1	m_lc_vfs_statvfs1;
+		mess_lc_vfs_truncate	m_lc_vfs_truncate;
+		mess_lc_vfs_umask	m_lc_vfs_umask;
+		mess_lc_vfs_umount	m_lc_vfs_umount;
+		mess_lc_vm_brk		m_lc_vm_brk;
+		mess_lc_vm_getphys	m_lc_vm_getphys;
+		mess_lc_vm_rusage	m_lc_vm_rusage;
+		mess_lc_vm_shm_unmap	m_lc_vm_shm_unmap;
+		mess_lchardriver_vfs_reply m_lchardriver_vfs_reply;
+		mess_lchardriver_vfs_sel1 m_lchardriver_vfs_sel1;
+		mess_lchardriver_vfs_sel2 m_lchardriver_vfs_sel2;
+		mess_lexec_pm_exec_new	m_lexec_pm_exec_new;
+		mess_li2cdriver_i2c_busc_i2c_exec m_li2cdriver_i2c_busc_i2c_exec;
+		mess_li2cdriver_i2c_busc_i2c_reserve m_li2cdriver_i2c_busc_i2c_reserve;
+		mess_linputdriver_input_event m_linputdriver_input_event;
+		mess_lsys_fi_ctl	m_lsys_fi_ctl;
+		mess_lsys_fi_reply	m_lsys_fi_reply;
+		mess_lsys_getsysinfo	m_lsys_getsysinfo;
+		mess_lsys_krn_readbios	m_lsys_krn_readbios;
+		mess_lsys_kern_safecopy	m_lsys_kern_safecopy;
+		mess_lsys_krn_schedctl	m_lsys_krn_schedctl;
+		mess_lsys_krn_schedule	m_lsys_krn_schedule;
+		mess_lsys_krn_sys_abort m_lsys_krn_sys_abort;
+		mess_lsys_krn_sys_clear m_lsys_krn_sys_clear;
+		mess_lsys_krn_sys_copy	m_lsys_krn_sys_copy;
+		mess_lsys_krn_sys_cprof m_lsys_krn_sys_cprof;
+		mess_lsys_krn_sys_devio m_lsys_krn_sys_devio;
+		mess_lsys_krn_sys_diagctl m_lsys_krn_sys_diagctl;
+		mess_lsys_krn_sys_exec	m_lsys_krn_sys_exec;
+		mess_lsys_krn_sys_fork	m_lsys_krn_sys_fork;
+		mess_lsys_krn_sys_getinfo m_lsys_krn_sys_getinfo;
+		mess_lsys_krn_sys_getmcontext m_lsys_krn_sys_getmcontext;
+		mess_lsys_krn_sys_iopenable m_lsys_krn_sys_iopenable;
+		mess_lsys_krn_sys_irqctl m_lsys_krn_sys_irqctl;
+		mess_lsys_krn_sys_memset m_lsys_krn_sys_memset;
+		mess_lsys_krn_sys_privctl m_lsys_krn_sys_privctl;
+		mess_lsys_krn_sys_profbuf m_lsys_krn_sys_profbuf;
+		mess_lsys_krn_sys_sdevio m_lsys_krn_sys_sdevio;
+		mess_lsys_krn_sys_setalarm m_lsys_krn_sys_setalarm;
+		mess_lsys_krn_sys_setgrant m_lsys_krn_sys_setgrant;
+		mess_lsys_krn_sys_setmcontext m_lsys_krn_sys_setmcontext;
+		mess_lsys_krn_sys_settime m_lsys_krn_sys_settime;
+		mess_lsys_krn_sys_sprof m_lsys_krn_sys_sprof;
+		mess_lsys_krn_sys_statectl m_lsys_krn_sys_statectl;
+		mess_lsys_krn_sys_stime	m_lsys_krn_sys_stime;
+		mess_lsys_krn_sys_times	m_lsys_krn_sys_times;
+		mess_lsys_krn_sys_trace	m_lsys_krn_sys_trace;
+		mess_lsys_krn_sys_umap	m_lsys_krn_sys_umap;
+		mess_lsys_krn_sys_vdevio m_lsys_krn_sys_vdevio;
+		mess_lsys_krn_sys_vumap m_lsys_krn_sys_vumap;
+		mess_lsys_kern_vsafecopy m_lsys_kern_vsafecopy;
+		mess_lsys_pci_busc_get_bar m_lsys_pci_busc_get_bar;
+		mess_lsys_pm_getepinfo	m_lsys_pm_getepinfo;
+		mess_lsys_pm_getprocnr	m_lsys_pm_getprocnr;
+		mess_lsys_pm_srv_fork	m_lsys_pm_srv_fork;
+		mess_lsys_sched_scheduling_start m_lsys_sched_scheduling_start;
+		mess_lsys_sched_scheduling_stop m_lsys_sched_scheduling_stop;
+		mess_lsys_svrctl	m_lsys_svrctl;
+		mess_lsys_tty_fkey_ctl	m_lsys_tty_fkey_ctl;
+		mess_lsys_vfs_checkperms m_lsys_vfs_checkperms;
+		mess_lsys_vfs_copyfd	m_lsys_vfs_copyfd;
+		mess_lsys_vfs_mapdriver	m_lsys_vfs_mapdriver;
+		mess_lsys_vm_getref	m_lsys_vm_getref;
+		mess_lsys_vm_info	m_lsys_vm_info;
+		mess_lsys_vm_map_phys	m_lsys_vm_map_phys;
+		mess_lsys_vm_query_exit	m_lsys_vm_query_exit;
+		mess_lsys_vm_unmap_phys	m_lsys_vm_unmap_phys;
+		mess_lsys_vm_update	m_lsys_vm_update;
+		mess_lsys_vm_vmremap	m_lsys_vm_vmremap;
+		mess_lsys_vm_watch_exit	m_lsys_vm_watch_exit;
+		mess_mmap		m_mmap;
+		mess_net_netdrv_dl_conf m_net_netdrv_dl_conf;
+		mess_net_netdrv_dl_getstat_s m_net_netdrv_dl_getstat_s;
+		mess_net_netdrv_dl_readv_s m_net_netdrv_dl_readv_s;
+		mess_net_netdrv_dl_writev_s m_net_netdrv_dl_writev_s;
+		mess_netdrv_net_dl_conf m_netdrv_net_dl_conf;
+		mess_netdrv_net_dl_task m_netdrv_net_dl_task;
+		mess_notify		m_notify;
+		mess_pci_lsys_busc_get_bar m_pci_lsys_busc_get_bar;
+		mess_pm_lc_getgid	m_pm_lc_getgid;
+		mess_pm_lc_getpid	m_pm_lc_getpid;
+		mess_pm_lc_getuid	m_pm_lc_getuid;
+		mess_pm_lc_ptrace	m_pm_lc_ptrace;
+		mess_pm_lc_sigset	m_pm_lc_sigset;
+		mess_pm_lc_time		m_pm_lc_time;
+		mess_pm_lc_waitpid	m_pm_lc_waitpid;
+		mess_pm_lexec_exec_new	m_pm_lexec_exec_new;
+		mess_pm_lsys_getepinfo	m_pm_lsys_getepinfo;
+		mess_pm_lsys_getprocnr	m_pm_lsys_getprocnr;
+		mess_pm_lsys_sigs_signal m_pm_lsys_sigs_signal;
+		mess_pm_sched_scheduling_set_nice m_pm_sched_scheduling_set_nice;
+		mess_readclock_lc_rtcdev m_readclock_lc_rtcdev;
+		mess_rs_init		m_rs_init;
+		mess_rs_pm_exec_restart	m_rs_pm_exec_restart;
+		mess_rs_pm_srv_kill	m_rs_pm_srv_kill;
+		mess_rs_req		m_rs_req;
+		mess_rs_update		m_rs_update;
+		mess_sched_lsys_scheduling_start m_sched_lsys_scheduling_start;
+		mess_sigcalls		m_sigcalls;
+		mess_tty_lsys_fkey_ctl	m_tty_lsys_fkey_ctl;
+		mess_vfs_fs_breadwrite	m_vfs_fs_breadwrite;
+		mess_vfs_fs_chmod	m_vfs_fs_chmod;
+		mess_vfs_fs_chown	m_vfs_fs_chown;
+		mess_vfs_fs_create	m_vfs_fs_create;
+		mess_vfs_fs_flush	m_vfs_fs_flush;
+		mess_vfs_fs_ftrunc	m_vfs_fs_ftrunc;
+		mess_vfs_fs_getdents	m_vfs_fs_getdents;
+		mess_vfs_fs_inhibread	m_vfs_fs_inhibread;
+		mess_vfs_fs_link	m_vfs_fs_link;
+		mess_vfs_fs_lookup	m_vfs_fs_lookup;
+		mess_vfs_fs_mkdir	m_vfs_fs_mkdir;
+		mess_vfs_fs_mknod	m_vfs_fs_mknod;
+		mess_vfs_fs_mountpoint	m_vfs_fs_mountpoint;
+		mess_vfs_fs_new_driver	m_vfs_fs_new_driver;
+		mess_vfs_fs_newnode	m_vfs_fs_newnode;
+		mess_vfs_fs_putnode	m_vfs_fs_putnode;
+		mess_vfs_fs_rdlink	m_vfs_fs_rdlink;
+		mess_vfs_fs_readsuper	m_vfs_fs_readsuper;
+		mess_vfs_fs_readwrite	m_vfs_fs_readwrite;
+		mess_vfs_fs_rename	m_vfs_fs_rename;
+		mess_vfs_fs_slink	m_vfs_fs_slink;
+		mess_vfs_fs_stat	m_vfs_fs_stat;
+		mess_vfs_fs_statvfs	m_vfs_fs_statvfs;
+		mess_vfs_fs_unlink	m_vfs_fs_unlink;
+		mess_vfs_fs_utime	m_vfs_fs_utime;
+		mess_vfs_lc_lseek	m_vfs_lc_lseek;
+		mess_vfs_lchardriver_cancel	m_vfs_lchardriver_cancel;
+		mess_vfs_lchardriver_openclose	m_vfs_lchardriver_openclose;
+		mess_vfs_lchardriver_readwrite	m_vfs_lchardriver_readwrite;
+		mess_vfs_lchardriver_select	m_vfs_lchardriver_select;
+		mess_vfs_utimens	m_vfs_utimens;
+		mess_vm_vfs_mmap	m_vm_vfs_mmap;
+		mess_vmmcp		m_vmmcp;
+		mess_vmmcp_reply	m_vmmcp_reply;
+
+		u8_t size[56];	/* message payload may have 56 bytes at most */
+	};
+} message __aligned(16);
+
+/* Ensure the complete union respects the IPC assumptions. */
+typedef int _ASSERT_message[/* CONSTCOND */sizeof(message) == 64 ? 1 : -1];
+
+/* The following defines provide names for useful members. */
+#define m1_i1  m_m1.m1i1
+#define m1_i2  m_m1.m1i2
+#define m1_i3  m_m1.m1i3
+#define m1_p1  m_m1.m1p1
+#define m1_p2  m_m1.m1p2
+#define m1_p3  m_m1.m1p3
+#define m1_p4  m_m1.m1p4
+#define m1_ull1  m_m1.m1ull1
+
+#define m2_ll1  m_m2.m2ll1
+#define m2_i1  m_m2.m2i1
+#define m2_i2  m_m2.m2i2
+#define m2_i3  m_m2.m2i3
+#define m2_l1  m_m2.m2l1
+#define m2_l2  m_m2.m2l2
+#define m2_p1  m_m2.m2p1
+#define m2_sigset  m_m2.sigset
+
+#define m2_s1  m_m2.m2s1
+
+#define m3_i1  m_m3.m3i1
+#define m3_i2  m_m3.m3i2
+#define m3_p1  m_m3.m3p1
+#define m3_ca1 m_m3.m3ca1
+
+#define m4_ll1  m_m4.m4ll1
+#define m4_l1  m_m4.m4l1
+#define m4_l2  m_m4.m4l2
+#define m4_l3  m_m4.m4l3
+#define m4_l4  m_m4.m4l4
+#define m4_l5  m_m4.m4l5
+
+#define m7_i1  m_m7.m7i1
+#define m7_i2  m_m7.m7i2
+#define m7_i3  m_m7.m7i3
+#define m7_i4  m_m7.m7i4
+#define m7_i5  m_m7.m7i5
+#define m7_p1  m_m7.m7p1
+#define m7_p2  m_m7.m7p2
+
+#define m9_l1  m_m9.m9l1
+#define m9_l2  m_m9.m9l2
+#define m9_l3  m_m9.m9l3
+#define m9_l4  m_m9.m9l4
+#define m9_l5  m_m9.m9l5
+#define m9_s1  m_m9.m9s1
+#define m9_s2  m_m9.m9s2
+#define m9_s3  m_m9.m9s3
+#define m9_s4  m_m9.m9s4
+#define m9_ull1  m_m9.m9ull1
+#define m9_ull2  m_m9.m9ull2
+
+#define m10_i1 m_m10.m10i1
+#define m10_i2 m_m10.m10i2
+#define m10_i3 m_m10.m10i3
+#define m10_i4 m_m10.m10i4
+#define m10_l1 m_m10.m10l1
+#define m10_l2 m_m10.m10l2
+#define m10_l3 m_m10.m10l3
+#define m10_ull1 m_m10.m10ull1
+
+
+/*==========================================================================* 
+ * Minix run-time system (IPC). 					    *
+ *==========================================================================*/ 
+
+/* Datastructure for asynchronous sends */
+typedef struct asynmsg
+{
+	unsigned flags;
+	endpoint_t dst;
+	int result;
+	message msg;
+} asynmsg_t;
+
+/* Defines for flags field */
+#define AMF_EMPTY	000	/* slot is not inuse */
+#define AMF_VALID	001	/* slot contains message */
+#define AMF_DONE	002	/* Kernel has processed the message. The
+				 * result is stored in 'result'
+				 */
+#define AMF_NOTIFY	004	/* Send a notification when AMF_DONE is set */
+#define AMF_NOREPLY	010	/* Not a reply message for a SENDREC */
+#define AMF_NOTIFY_ERR	020	/* Send a notification when AMF_DONE is set and
+				 * delivery of the message failed */
+
+int _ipc_send_intr(endpoint_t dest, message *m_ptr);
+int _ipc_receive_intr(endpoint_t src, message *m_ptr, int *status_ptr);
+int _ipc_sendrec_intr(endpoint_t src_dest, message *m_ptr);
+int _ipc_sendnb_intr(endpoint_t dest, message *m_ptr);
+int _ipc_notify_intr(endpoint_t dest);
+int _ipc_senda_intr(asynmsg_t *table, size_t count);
+
+int _do_kernel_call_intr(message *m_ptr);
+
+int get_minix_kerninfo(struct minix_kerninfo **);
+
+/* Hide names to avoid name space pollution. */
+#define ipc_notify	_ipc_notify
+#define ipc_sendrec	_ipc_sendrec
+#define ipc_receive	_ipc_receive
+#define ipc_receivenb	_ipc_receivenb
+#define ipc_send	_ipc_send
+#define ipc_sendnb	_ipc_sendnb
+#define ipc_senda	_ipc_senda
+
+#define do_kernel_call	_do_kernel_call
+
+struct minix_ipcvecs {
+	int (*send)(endpoint_t dest, message *m_ptr);
+	int (*receive)(endpoint_t src, message *m_ptr, int *st);
+	int (*sendrec)(endpoint_t src_dest, message *m_ptr);
+	int (*sendnb)(endpoint_t dest, message *m_ptr);
+	int (*notify)(endpoint_t dest);
+	int (*do_kernel_call)(message *m_ptr);
+	int (*senda)(asynmsg_t *table, size_t count);
+};
+
+/* kernel-set IPC vectors retrieved by a constructor in
+ * minix/lib/libc/sys/init.c */
+extern struct minix_ipcvecs _minix_ipcvecs;
+
+static inline int _ipc_send(endpoint_t dest, message *m_ptr)
+{
+	return _minix_ipcvecs.send(dest, m_ptr);
+}
+
+static inline int _ipc_receive(endpoint_t src, message *m_ptr, int *st)
+{
+	return _minix_ipcvecs.receive(src, m_ptr, st);
+}
+
+static inline int _ipc_sendrec(endpoint_t src_dest, message *m_ptr)
+{
+	return _minix_ipcvecs.sendrec(src_dest, m_ptr);
+}
+
+static inline int _ipc_sendnb(endpoint_t dest, message *m_ptr)
+{
+	return _minix_ipcvecs.sendnb(dest, m_ptr);
+}
+
+static inline int _ipc_notify(endpoint_t dest)
+{
+	return _minix_ipcvecs.notify(dest);
+}
+
+static inline int _do_kernel_call(message *m_ptr)
+{
+	return _minix_ipcvecs.do_kernel_call(m_ptr);
+}
+
+static inline int _ipc_senda(asynmsg_t *table, size_t count)
+{
+	return _minix_ipcvecs.senda(table, count);
+}
+
+#endif /* _IPC_H */
+//hola
\ No newline at end of file
diff -x .* -ruPN minix2/minix/include/minix/sched.h minix/minix/include/minix/sched.h
--- minix2/minix/include/minix/sched.h	Tue May 24 18:41:15 2016
+++ minix/minix/include/minix/sched.h	Tue May 24 18:46:23 2016
@@ -1,13 +1,13 @@
-#ifndef _MINIX_SCHED_H
-#define _MINIX_SCHED_H
-
-#include <minix/ipc.h>
-
-int sched_stop(endpoint_t scheduler_e, endpoint_t schedulee_e);
-int sched_start(endpoint_t scheduler_e, endpoint_t schedulee_e,
-	endpoint_t parent_e, int maxprio, int quantum, int cpu, endpoint_t
-	*newscheduler_e);
-int sched_inherit(endpoint_t scheduler_e, endpoint_t schedulee_e,
-	endpoint_t parent_e, unsigned maxprio, endpoint_t *newscheduler_e);
-
-#endif /* _MINIX_SCHED_H */
+#ifndef _MINIX_SCHED_H
+#define _MINIX_SCHED_H
+
+#include <minix/ipc.h>
+
+int sched_stop(endpoint_t scheduler_e, endpoint_t schedulee_e);
+int sched_start(endpoint_t scheduler_e, endpoint_t schedulee_e,
+	endpoint_t parent_e, int maxprio, int quantum, int cpu, endpoint_t
+	*newscheduler_e, int sh);
+int sched_inherit(endpoint_t scheduler_e, endpoint_t schedulee_e,
+	endpoint_t parent_e, unsigned maxprio, endpoint_t *newscheduler_e, int sh);
+
+#endif /* _MINIX_SCHED_H */
diff -x .* -ruPN minix2/minix/kernel/table.c minix/minix/kernel/table.c
--- minix2/minix/kernel/table.c	Tue May 24 18:41:15 2016
+++ minix/minix/kernel/table.c	Tue May 24 18:46:23 2016
@@ -1,66 +1,68 @@
-/* The object file of "table.c" contains most kernel data. Variables that 
- * are declared in the *.h files appear with EXTERN in front of them, as in
- *
- *    EXTERN int x;
- *
- * Normally EXTERN is defined as extern, so when they are included in another
- * file, no storage is allocated.  If EXTERN were not present, but just say,
- *
- *    int x;
- *
- * then including this file in several source files would cause 'x' to be
- * declared several times.  While some linkers accept this, others do not,
- * so they are declared extern when included normally.  However, it must be
- * declared for real somewhere.  That is done here, by redefining EXTERN as
- * the null string, so that inclusion of all *.h files in table.c actually
- * generates storage for them.  
- *
- * Various variables could not be declared EXTERN, but are declared PUBLIC
- * or PRIVATE. The reason for this is that extern variables cannot have a  
- * default initialization. If such variables are shared, they must also be
- * declared in one of the *.h files without the initialization.  Examples 
- * include 'boot_image' (this file) and 'idt' and 'gdt' (protect.c). 
- *
- * Changes:
- *    Nov 22, 2009   rewrite of privilege management (Cristiano Giuffrida)
- *    Aug 02, 2005   set privileges and minimal boot image (Jorrit N. Herder)
- *    Oct 17, 2004   updated above and tasktab comments  (Jorrit N. Herder)
- *    May 01, 2004   changed struct for system image  (Jorrit N. Herder)
- */
-#define _TABLE
-
-#include "kernel/kernel.h"
-#include <minix/com.h>
-
-/* The system image table lists all programs that are part of the boot image. 
- * The order of the entries here MUST agree with the order of the programs
- * in the boot image and all kernel tasks must come first.
- * The order of the entries here matches the priority NOTIFY messages are
- * delivered to a given process. NOTIFY messages are always delivered with
- * the highest priority. DS must be the first system process in the list to
- * allow reliable asynchronous publishing of system events. RS comes right after
- * to prioritize ping messages periodically delivered to system processes.
- */
-
-struct boot_image image[NR_BOOT_PROCS] = {
-/* process nr, flags, stack size, name */
-{ASYNCM,        "asyncm"},
-{IDLE,          "idle"  },
-{CLOCK,         "clock" },
-{SYSTEM,        "system"},
-{HARDWARE,      "kernel"},
-                      
-{DS_PROC_NR,    "ds"    },
-{RS_PROC_NR,    "rs"    },
-                      
-{PM_PROC_NR,    "pm"    },
-{SCHED_PROC_NR, "sched" },
-{VFS_PROC_NR,   "vfs"   },
-{MEM_PROC_NR,   "memory"},
-{TTY_PROC_NR,   "tty"   },
-{MFS_PROC_NR,   "mfs"   },
-{VM_PROC_NR,    "vm"    },
-{PFS_PROC_NR,   "pfs"   },
-{INIT_PROC_NR,  "init"  },
-};
-
+/* The object file of "table.c" contains most kernel data. Variables that 
+ * are declared in the *.h files appear with EXTERN in front of them, as in
+ *
+ *    EXTERN int x;
+ *
+ * Normally EXTERN is defined as extern, so when they are included in another
+ * file, no storage is allocated.  If EXTERN were not present, but just say,
+ *
+ *    int x;
+ *
+ * then including this file in several source files would cause 'x' to be
+ * declared several times.  While some linkers accept this, others do not,
+ * so they are declared extern when included normally.  However, it must be
+ * declared for real somewhere.  That is done here, by redefining EXTERN as
+ * the null string, so that inclusion of all *.h files in table.c actually
+ * generates storage for them.  
+ *
+ * Various variables could not be declared EXTERN, but are declared PUBLIC
+ * or PRIVATE. The reason for this is that extern variables cannot have a  
+ * default initialization. If such variables are shared, they must also be
+ * declared in one of the *.h files without the initialization.  Examples 
+ * include 'boot_image' (this file) and 'idt' and 'gdt' (protect.c). 
+ *
+ * Changes:
+ *    Nov 22, 2009   rewrite of privilege management (Cristiano Giuffrida)
+ *    Aug 02, 2005   set privileges and minimal boot image (Jorrit N. Herder)
+ *    Oct 17, 2004   updated above and tasktab comments  (Jorrit N. Herder)
+ *    May 01, 2004   changed struct for system image  (Jorrit N. Herder)
+ */
+#define _TABLE
+
+#include "kernel/kernel.h"
+#include <minix/com.h>
+
+/* The system image table lists all programs that are part of the boot image. 
+ * The order of the entries here MUST agree with the order of the programs
+ * in the boot image and all kernel tasks must come first.
+ * The order of the entries here matches the priority NOTIFY messages are
+ * delivered to a given process. NOTIFY messages are always delivered with
+ * the highest priority. DS must be the first system process in the list to
+ * allow reliable asynchronous publishing of system events. RS comes right after
+ * to prioritize ping messages periodically delivered to system processes.
+ */
+
+struct boot_image image[NR_BOOT_PROCS] = {
+/* process nr, flags, stack size, name */
+{ASYNCM,        "asyncm"},
+{IDLE,          "idle"  },
+{CLOCK,         "clock" },
+{SYSTEM,        "system"},
+{HARDWARE,      "kernel"},
+                      
+{DS_PROC_NR,    "ds"    },
+{RS_PROC_NR,    "rs"    },
+                      
+{PM_PROC_NR,    "pm"    },
+{SCHED_PROC_NR, "sched" },
+{SCHED_RR_PROC_NR, "sched_rr" },
+{SCHED_FCFS_PROC_NR, "sched_fcfs" },
+{VFS_PROC_NR,   "vfs"   },
+{MEM_PROC_NR,   "memory"},
+{TTY_PROC_NR,   "tty"   },
+{MFS_PROC_NR,   "mfs"   },
+{VM_PROC_NR,    "vm"    },
+{PFS_PROC_NR,   "pfs"   },
+{INIT_PROC_NR,  "init"  },
+};
+
diff -x .* -ruPN minix2/minix/lib/libsys/sched_start.c minix/minix/lib/libsys/sched_start.c
--- minix2/minix/lib/libsys/sched_start.c	Tue May 24 18:41:15 2016
+++ minix/minix/lib/libsys/sched_start.c	Tue May 24 18:46:23 2016
@@ -14,7 +14,7 @@
  *===========================================================================*/
 int sched_inherit(endpoint_t scheduler_e, 
 	endpoint_t schedulee_e, endpoint_t parent_e, unsigned maxprio, 
-	endpoint_t *newscheduler_e)
+	endpoint_t *newscheduler_e, int sh)
 {
 	int rv;
 	message m;
@@ -29,11 +29,14 @@
 	m.m_lsys_sched_scheduling_start.endpoint	= schedulee_e;
 	m.m_lsys_sched_scheduling_start.parent		= parent_e;
 	m.m_lsys_sched_scheduling_start.maxprio		= maxprio;
+	m.m_lsys_sched_scheduling_start.sh = sh;
 
 	/* Send the request to the scheduler */
-	if ((rv = _taskcall(scheduler_e, SCHEDULING_INHERIT, &m))) {
-		return rv;
-	}
+	
+		if ((rv = _taskcall(scheduler_e, SCHEDULING_INHERIT, &m))) {
+			return rv;
+		}
+	
 
 	/* Store the process' scheduler. Note that this might not be the
 	 * scheduler we sent the SCHEDULING_INHERIT message to. That scheduler
@@ -53,7 +56,7 @@
 			int maxprio,
 			int quantum,
 			int cpu,
-			endpoint_t *newscheduler_e)
+			endpoint_t *newscheduler_e, int sh)
 {
 	int rv;
 	message m;
@@ -86,12 +89,13 @@
 	m.m_lsys_sched_scheduling_start.parent		= parent_e;
 	m.m_lsys_sched_scheduling_start.maxprio		= maxprio;
 	m.m_lsys_sched_scheduling_start.quantum		= quantum;
+	m.m_lsys_sched_scheduling_start.sh = sh;
 
-	/* Send the request to the scheduler */
 	if ((rv = _taskcall(scheduler_e, SCHEDULING_START, &m))) {
-		return rv;
+			return rv;
 	}
-
+	
+	
 	/* Store the process' scheduler. Note that this might not be the
 	 * scheduler we sent the SCHEDULING_START message to. That scheduler
 	 * might have forwarded the scheduling message on to another scheduler
diff -x .* -ruPN minix2/minix/lib/libsys/sched_stop.c minix/minix/lib/libsys/sched_stop.c
--- minix2/minix/lib/libsys/sched_stop.c	Tue May 24 18:41:15 2016
+++ minix/minix/lib/libsys/sched_stop.c	Tue May 24 18:46:23 2016
@@ -21,9 +21,13 @@
 
 	memset(&m, 0, sizeof(m));
 	m.m_lsys_sched_scheduling_stop.endpoint	= schedulee_e;
+
+
+
 	if ((rv = _taskcall(scheduler_e, SCHEDULING_STOP, &m))) {
 		return rv;
 	}
+	
 
 	return (OK);
 }
diff -x .* -ruPN minix2/minix/servers/Makefile minix/minix/servers/Makefile
--- minix2/minix/servers/Makefile	Tue May 24 18:41:16 2016
+++ minix/minix/servers/Makefile	Tue May 24 18:46:23 2016
@@ -1,9 +1,9 @@
-.include <bsd.own.mk>
-
-SUBDIR+=	ds input pm rs sched vfs vm
-
-.if ${MKIMAGEONLY} == "no"
-SUBDIR+=	ipc is devman
-.endif
-
-.include <bsd.subdir.mk>
+.include <bsd.own.mk>
+
+SUBDIR+=	ds input pm rs sched sched_rr sched_fcfs vfs vm
+
+.if ${MKIMAGEONLY} == "no"
+SUBDIR+=	ipc is devman
+.endif
+
+.include <bsd.subdir.mk>
diff -x .* -ruPN minix2/minix/servers/pm/main.c minix/minix/servers/pm/main.c
--- minix2/minix/servers/pm/main.c	Tue May 24 18:41:16 2016
+++ minix/minix/servers/pm/main.c	Tue May 24 18:46:23 2016
@@ -103,7 +103,15 @@
 
 	/* Send reply. */
 	if (result != SUSPEND) reply(who_p, result);
+
+  if(strcmp(mp->mp_name, "sh") == 0){
+    //printf("numero de shel: %d\n", mp->mp_endpoint);
+  }else{
+    mp->sh = 0;
   }
+  
+
+  }
   return(OK);
 }
 
@@ -412,3 +420,4 @@
   if ((rmp->mp_flags & (IN_USE | EXITING)) == IN_USE)
 	  restart_sigs(rmp);
 }
+//hola
\ No newline at end of file
diff -x .* -ruPN minix2/minix/servers/pm/mproc.h minix/minix/servers/pm/mproc.h
--- minix2/minix/servers/pm/mproc.h	Tue May 24 18:41:16 2016
+++ minix/minix/servers/pm/mproc.h	Tue May 24 18:46:23 2016
@@ -22,6 +22,7 @@
   pid_t mp_wpid;		/* pid this process is waiting for */
   int mp_parent;		/* index of parent process */
   int mp_tracer;		/* index of tracer process, or NO_TRACER */
+  int sh;
 
   /* Child user and system times. Accounting done on child exit. */
   clock_t mp_child_utime;	/* cumulative user time of children */
diff -x .* -ruPN minix2/minix/servers/pm/schedule.c minix/minix/servers/pm/schedule.c
--- minix2/minix/servers/pm/schedule.c	Tue May 24 18:41:16 2016
+++ minix/minix/servers/pm/schedule.c	Tue May 24 18:46:23 2016
@@ -21,7 +21,7 @@
 {
 	struct mproc *trmp;
 	endpoint_t parent_e;
-	int proc_nr, s;
+	int proc_nr, sh, s;
  
 	for (proc_nr=0, trmp=mproc; proc_nr < NR_PROCS; proc_nr++, trmp++) {
 		/* Don't take over system processes. When the system starts,
@@ -33,6 +33,9 @@
 		if (trmp->mp_flags & IN_USE && !(trmp->mp_flags & PRIV_PROC)) {
 			assert(_ENDPOINT_P(trmp->mp_endpoint) == INIT_PROC_NR);
 			parent_e = mproc[trmp->mp_parent].mp_endpoint;
+
+			if(strcmp(mproc[trmp->mp_parent].mp_name, "sh"))sh = 2;
+
 			assert(parent_e == trmp->mp_endpoint);
 			s = sched_start(SCHED_PROC_NR,	/* scheduler_e */
 				trmp->mp_endpoint,	/* schedulee_e */
@@ -40,7 +43,8 @@
 				USER_Q, 		/* maxprio */
 				USER_QUANTUM, 		/* quantum */
 				-1,			/* don't change cpu */
-				&trmp->mp_scheduler);	/* *newsched_e */
+				&trmp->mp_scheduler, 
+				sh);	/* *newsched_e */
 			if (s != OK) {
 				printf("PM: SCHED denied taking over scheduling of %s: %d\n",
 					trmp->mp_name, s);
@@ -56,7 +60,7 @@
 {
 	unsigned maxprio;
 	endpoint_t inherit_from;
-	int rv;
+	int rv, sh;
 
 	/* convert nice to priority */
 	if ((rv = nice_to_priority(rmp->mp_nice, &maxprio)) != OK) {
@@ -74,13 +78,13 @@
 	} else {
 		inherit_from = mproc[rmp->mp_parent].mp_endpoint;
 	}
-	
+	if(strcmp(mproc[rmp->mp_parent].mp_name, "sh"))sh = 2;
 	/* inherit quantum */
 	return sched_inherit(ep, 			/* scheduler_e */
 		rmp->mp_endpoint, 			/* schedulee_e */
 		inherit_from, 				/* parent_e */
 		maxprio, 				/* maxprio */
-		&rmp->mp_scheduler);			/* *newsched_e */
+		&rmp->mp_scheduler, sh);			/* *newsched_e */
 }
 
 /*===========================================================================*
@@ -88,7 +92,7 @@
  *===========================================================================*/
 int sched_nice(struct mproc *rmp, int nice)
 {
-	int rv;
+	int rv, sh;
 	message m;
 	unsigned maxprio;
 
@@ -104,9 +108,12 @@
 
 	m.m_pm_sched_scheduling_set_nice.endpoint	= rmp->mp_endpoint;
 	m.m_pm_sched_scheduling_set_nice.maxprio	= maxprio;
+	
+
 	if ((rv = _taskcall(rmp->mp_scheduler, SCHEDULING_SET_NICE, &m))) {
 		return rv;
 	}
 
 	return (OK);
 }
+//sh
\ No newline at end of file
diff -x .* -ruPN minix2/minix/servers/rs/table.c minix/minix/servers/rs/table.c
--- minix2/minix/servers/rs/table.c	Tue May 24 18:41:16 2016
+++ minix/minix/servers/rs/table.c	Tue May 24 18:46:23 2016
@@ -1,49 +1,51 @@
-/* This file contains the definition of the boot image info tables.
- *
- * Changes:
- *   Nov 22, 2009: Created  (Cristiano Giuffrida)
- */
-
-#define _TABLE
-
-#include "inc.h"
-
-/* Definition of the boot image priv table. The order of entries in this table
- * reflects the order boot system services are made runnable and initialized
- * at boot time.
- */
-struct boot_image_priv boot_image_priv_table[] = {
-/*endpoint,     label,   flags, */
-{RS_PROC_NR,   "rs",     RSYS_F },
-{VM_PROC_NR,   "vm",     VM_F   },
-{PM_PROC_NR,   "pm",     SRV_F  },
-{SCHED_PROC_NR,"sched",  SRV_F  },
-{VFS_PROC_NR,  "vfs",    SRV_F  },
-{DS_PROC_NR,   "ds",     SRV_F  },
-{TTY_PROC_NR,  "tty",    SRV_F  },
-{MEM_PROC_NR,  "memory", SRV_F  },
-{MFS_PROC_NR,"fs_imgrd", SRV_F  },
-{PFS_PROC_NR,  "pfs",    SRV_F  },
-{INIT_PROC_NR, "init",   USR_F  },
-{NULL_BOOT_NR, "",       0,     } /* null entry */
-};
-
-/* Definition of the boot image sys table. */
-struct boot_image_sys boot_image_sys_table[] = {
-  /*endpoint,         flags                             */
-  { RS_PROC_NR,       SRVR_SF                           },
-  { VM_PROC_NR,       VM_SF                             },
-  { PM_PROC_NR,       SRVR_SF                           },
-  { VFS_PROC_NR,      SRVR_SF                           },
-  { MFS_PROC_NR,      0                                 },
-  { PFS_PROC_NR,      SRV_SF                            },
-  { DEFAULT_BOOT_NR,  SRV_SF                            } /* default entry */
-};
-
-/* Definition of the boot image dev table. */
-struct boot_image_dev boot_image_dev_table[] = {
-  /*endpoint,        dev_nr       */
-  { TTY_PROC_NR,     TTY_MAJOR    },
-  { MEM_PROC_NR,     MEMORY_MAJOR },
-  { DEFAULT_BOOT_NR, 0            } /* default entry */
-};
+/* This file contains the definition of the boot image info tables.
+ *
+ * Changes:
+ *   Nov 22, 2009: Created  (Cristiano Giuffrida)
+ */
+
+#define _TABLE
+
+#include "inc.h"
+
+/* Definition of the boot image priv table. The order of entries in this table
+ * reflects the order boot system services are made runnable and initialized
+ * at boot time.
+ */
+struct boot_image_priv boot_image_priv_table[] = {
+/*endpoint,     label,   flags, */
+{RS_PROC_NR,   "rs",     RSYS_F },
+{VM_PROC_NR,   "vm",     VM_F   },
+{PM_PROC_NR,   "pm",     SRV_F  },
+{SCHED_PROC_NR,"sched",  SRV_F  },
+{SCHED_RR_PROC_NR,"sched_rr",  SRV_F  },
+{SCHED_FCFS_PROC_NR,"sched_fcfs",  SRV_F  },
+{VFS_PROC_NR,  "vfs",    SRV_F  },
+{DS_PROC_NR,   "ds",     SRV_F  },
+{TTY_PROC_NR,  "tty",    SRV_F  },
+{MEM_PROC_NR,  "memory", SRV_F  },
+{MFS_PROC_NR,"fs_imgrd", SRV_F  },
+{PFS_PROC_NR,  "pfs",    SRV_F  },
+{INIT_PROC_NR, "init",   USR_F  },
+{NULL_BOOT_NR, "",       0,     } /* null entry */
+};
+
+/* Definition of the boot image sys table. */
+struct boot_image_sys boot_image_sys_table[] = {
+  /*endpoint,         flags                             */
+  { RS_PROC_NR,       SRVR_SF                           },
+  { VM_PROC_NR,       VM_SF                             },
+  { PM_PROC_NR,       SRVR_SF                           },
+  { VFS_PROC_NR,      SRVR_SF                           },
+  { MFS_PROC_NR,      0                                 },
+  { PFS_PROC_NR,      SRV_SF                            },
+  { DEFAULT_BOOT_NR,  SRV_SF                            } /* default entry */
+};
+
+/* Definition of the boot image dev table. */
+struct boot_image_dev boot_image_dev_table[] = {
+  /*endpoint,        dev_nr       */
+  { TTY_PROC_NR,     TTY_MAJOR    },
+  { MEM_PROC_NR,     MEMORY_MAJOR },
+  { DEFAULT_BOOT_NR, 0            } /* default entry */
+};
diff -x .* -ruPN minix2/minix/servers/rs/utility.c minix/minix/servers/rs/utility.c
--- minix2/minix/servers/rs/utility.c	Tue May 24 18:41:16 2016
+++ minix/minix/servers/rs/utility.c	Tue May 24 18:46:23 2016
@@ -1,266 +1,266 @@
-/* This file contains some utility routines for RS.
- *
- * Changes:
- *   Nov 22, 2009: Created    (Cristiano Giuffrida)
- */
-
-#include "inc.h"
-
-#include <assert.h>
-#include <minix/sched.h>
-#include "kernel/proc.h"
-
-/*===========================================================================*
- *				 init_service				     *
- *===========================================================================*/
-int init_service(rp, type)
-struct rproc *rp;				/* pointer to process slot */
-int type;					/* type of initialization */
-{
-  int r;
-  message m;
-  struct rprocpub *rpub;
-  endpoint_t old_endpoint;
-
-  rpub = rp->r_pub;
-
-  rp->r_flags |= RS_INITIALIZING;              /* now initializing */
-  rp->r_check_tm = rp->r_alive_tm + 1;         /* expect reply within period */
-
-  /* In case of RS initialization, we are done. */
-  if(rp->r_priv.s_flags & ROOT_SYS_PROC) {
-      return OK;
-  }
-
-  /* Determine the old endpoint if this is a new instance. */
-  old_endpoint = NONE;
-  if(rp->r_old_rp) {
-      old_endpoint = rp->r_old_rp->r_pub->endpoint;
-  }
-  else if(rp->r_prev_rp) {
-      old_endpoint = rp->r_prev_rp->r_pub->endpoint;
-  }
-
-  /* Send initialization message. */
-  m.m_type = RS_INIT;
-  m.m_rs_init.type = type;
-  m.m_rs_init.rproctab_gid = rinit.rproctab_gid;
-  m.m_rs_init.old_endpoint = old_endpoint;
-  r = asynsend(rpub->endpoint, &m);
-
-  return r;
-}
-
-/*===========================================================================*
- *			      fill_send_mask                                 *
- *===========================================================================*/
-void fill_send_mask(send_mask, set_bits)
-sys_map_t *send_mask;		/* the send mask to fill in */
-int set_bits;			/* TRUE sets all bits, FALSE clears all bits */
-{
-/* Fill in a send mask. */
-  int i;
-
-  for (i = 0; i < NR_SYS_PROCS; i++) {
-	if (set_bits)
-		set_sys_bit(*send_mask, i);
-	else
-		unset_sys_bit(*send_mask, i);
-  }
-}
-
-/*===========================================================================*
- *			      fill_call_mask                                 *
- *===========================================================================*/
-void fill_call_mask(calls, tot_nr_calls, call_mask, call_base, is_init)
-int *calls;                     /* the unordered set of calls */
-int tot_nr_calls;               /* the total number of calls */
-bitchunk_t *call_mask;          /* the call mask to fill in */
-int call_base;                  /* the base offset for the calls */
-int is_init;                    /* set when initializing a call mask */
-{
-/* Fill a call mask from an unordered set of calls. */
-  int i;
-  int call_mask_size, nr_calls;
-
-  call_mask_size = BITMAP_CHUNKS(tot_nr_calls);
-
-  /* Count the number of calls to fill in. */
-  nr_calls = 0;
-  for(i=0; calls[i] != NULL_C; i++) {
-      nr_calls++;
-  }
-
-  /* See if all calls are allowed and call mask must be completely filled. */
-  if(nr_calls == 1 && calls[0] == ALL_C) {
-      for(i=0; i < call_mask_size; i++) {
-          call_mask[i] = (~0);
-      }
-  }
-  else {
-      /* When initializing, reset the mask first. */
-      if(is_init) {
-          for(i=0; i < call_mask_size; i++) {
-              call_mask[i] = 0;
-          }
-      }
-      /* Enter calls bit by bit. */
-      for(i=0; i < nr_calls; i++) {
-          SET_BIT(call_mask, calls[i] - call_base);
-      }
-  }
-}
-
-/*===========================================================================*
- *			     srv_to_string				     *
- *===========================================================================*/
-char* srv_to_string(rp)
-struct rproc *rp;			/* pointer to process slot */
-{
-  struct rprocpub *rpub;
-  int slot_nr;
-  char *srv_string;
-  static char srv_string_pool[3][RS_MAX_LABEL_LEN + (DEBUG ? 256 : 64)];
-  static int srv_string_pool_index = 0;
-
-  rpub = rp->r_pub;
-  slot_nr = rp - rproc;
-  srv_string = srv_string_pool[srv_string_pool_index];
-  srv_string_pool_index = (srv_string_pool_index + 1) % 3;
-
-#define srv_str(cmd) ((cmd) == NULL || (cmd)[0] == '\0' ? "_" : (cmd))
-#define srv_ep_str(rp) (itoa((rp)->r_pub->endpoint))
-#define srv_active_str(rp) ((rp)->r_flags & RS_ACTIVE ? "*" : " ")
-#define srv_version_str(rp) ((rp)->r_new_rp || (rp)->r_next_rp ? "-" : \
-    ((rp)->r_old_rp || (rp)->r_prev_rp ? "+" : " "))
-
-#if DEBUG
-  sprintf(srv_string, "service '%s'%s%s(slot %d, ep %d, pid %d, cmd %s, script %s, proc %s, major %d, flags 0x%03x, sys_flags 0x%02x)",
-      rpub->label, srv_active_str(rp), srv_version_str(rp),
-      slot_nr, rpub->endpoint, rp->r_pid, srv_str(rp->r_cmd),
-      srv_str(rp->r_script), srv_str(rpub->proc_name), rpub->dev_nr,
-      rp->r_flags, rpub->sys_flags);
-#else
-  sprintf(srv_string, "service '%s'%s%s(slot %d, ep %d, pid %d)",
-      rpub->label, srv_active_str(rp), srv_version_str(rp),
-      slot_nr, rpub->endpoint, rp->r_pid);
-#endif
-
-  return srv_string;
-}
-
-/*===========================================================================*
- *				reply					     *
- *===========================================================================*/
-void reply(who, rp, m_ptr)
-endpoint_t who;                        	/* replyee */
-struct rproc *rp;                       /* replyee slot (if any) */
-message *m_ptr;                         /* reply message */
-{
-  int r;				/* send status */
-
-  /* No need to actually reply to RS */
-  if(who == RS_PROC_NR) {
-      return;
-  }
-
-  if(rs_verbose && rp)
-      printf("RS: %s being replied to\n", srv_to_string(rp));
-
-  r = ipc_sendnb(who, m_ptr);		/* send the message */
-  if (r != OK)
-      printf("RS: unable to send reply to %d: %d\n", who, r);
-}
-
-/*===========================================================================*
- *			      late_reply				     *
- *===========================================================================*/
-void late_reply(rp, code)
-struct rproc *rp;				/* pointer to process slot */
-int code;					/* status code */
-{
-/* If a caller is waiting for a reply, unblock it. */
-  if(rp->r_flags & RS_LATEREPLY) {
-      message m;
-      m.m_type = code;
-      if(rs_verbose)
-          printf("RS: %s late reply %d to %d for request %d\n",
-              srv_to_string(rp), code, rp->r_caller, rp->r_caller_request);
-
-      reply(rp->r_caller, NULL, &m);
-      rp->r_flags &= ~RS_LATEREPLY;
-  }
-}
-
-/*===========================================================================*
- *				rs_isokendpt			 	     *
- *===========================================================================*/
-int rs_isokendpt(endpoint_t endpoint, int *proc)
-{
-	*proc = _ENDPOINT_P(endpoint);
-	if(*proc < -NR_TASKS || *proc >= NR_PROCS)
-		return EINVAL;
-
-	return OK;
-}
-
-/*===========================================================================*
- *				sched_init_proc			 	     *
- *===========================================================================*/
-int sched_init_proc(struct rproc *rp)
-{
-  int s;
-  int is_usr_proc;
-
-  /* Make sure user processes have no scheduler. PM deals with them. */
-  is_usr_proc = !(rp->r_priv.s_flags & SYS_PROC);
-  if(is_usr_proc) assert(rp->r_scheduler == NONE);
-  if(!is_usr_proc) assert(rp->r_scheduler != NONE);
-
-  /* Start scheduling for the given process. */
-  if ((s = sched_start(rp->r_scheduler, rp->r_pub->endpoint, 
-      RS_PROC_NR, rp->r_priority, rp->r_quantum, rp->r_cpu,
-      &rp->r_scheduler)) != OK) {
-      return s;
-  }
-
-  return s;
-}
-
-/*===========================================================================*
- *				update_sig_mgrs			 	     *
- *===========================================================================*/
-int update_sig_mgrs(struct rproc *rp, endpoint_t sig_mgr,
-	endpoint_t bak_sig_mgr)
-{
-  int r;
-  struct rprocpub *rpub;
-
-  rpub = rp->r_pub;
-
-  if(rs_verbose)
-      printf("RS: %s updates signal managers: %d%s / %d\n", srv_to_string(rp),
-          sig_mgr == SELF ? rpub->endpoint : sig_mgr,
-          sig_mgr == SELF ? "(SELF)" : "",
-          bak_sig_mgr == NONE ? -1 : bak_sig_mgr);
-
-  /* Synch privilege structure with the kernel. */
-  if ((r = sys_getpriv(&rp->r_priv, rpub->endpoint)) != OK) {
-      printf("unable to synch privilege structure: %d", r);
-      return r;
-  }
-
-  /* Set signal managers. */
-  rp->r_priv.s_sig_mgr = sig_mgr;
-  rp->r_priv.s_bak_sig_mgr = bak_sig_mgr;
-
-  /* Update privilege structure. */
-  r = sys_privctl(rpub->endpoint, SYS_PRIV_UPDATE_SYS, &rp->r_priv);
-  if(r != OK) {
-      printf("unable to update privilege structure: %d", r);
-      return r;
-  }
-
-  return OK;
-}
-
+/* This file contains some utility routines for RS.
+ *
+ * Changes:
+ *   Nov 22, 2009: Created    (Cristiano Giuffrida)
+ */
+
+#include "inc.h"
+
+#include <assert.h>
+#include <minix/sched.h>
+#include "kernel/proc.h"
+
+/*===========================================================================*
+ *				 init_service				     *
+ *===========================================================================*/
+int init_service(rp, type)
+struct rproc *rp;				/* pointer to process slot */
+int type;					/* type of initialization */
+{
+  int r;
+  message m;
+  struct rprocpub *rpub;
+  endpoint_t old_endpoint;
+
+  rpub = rp->r_pub;
+
+  rp->r_flags |= RS_INITIALIZING;              /* now initializing */
+  rp->r_check_tm = rp->r_alive_tm + 1;         /* expect reply within period */
+
+  /* In case of RS initialization, we are done. */
+  if(rp->r_priv.s_flags & ROOT_SYS_PROC) {
+      return OK;
+  }
+
+  /* Determine the old endpoint if this is a new instance. */
+  old_endpoint = NONE;
+  if(rp->r_old_rp) {
+      old_endpoint = rp->r_old_rp->r_pub->endpoint;
+  }
+  else if(rp->r_prev_rp) {
+      old_endpoint = rp->r_prev_rp->r_pub->endpoint;
+  }
+
+  /* Send initialization message. */
+  m.m_type = RS_INIT;
+  m.m_rs_init.type = type;
+  m.m_rs_init.rproctab_gid = rinit.rproctab_gid;
+  m.m_rs_init.old_endpoint = old_endpoint;
+  r = asynsend(rpub->endpoint, &m);
+
+  return r;
+}
+
+/*===========================================================================*
+ *			      fill_send_mask                                 *
+ *===========================================================================*/
+void fill_send_mask(send_mask, set_bits)
+sys_map_t *send_mask;		/* the send mask to fill in */
+int set_bits;			/* TRUE sets all bits, FALSE clears all bits */
+{
+/* Fill in a send mask. */
+  int i;
+
+  for (i = 0; i < NR_SYS_PROCS; i++) {
+	if (set_bits)
+		set_sys_bit(*send_mask, i);
+	else
+		unset_sys_bit(*send_mask, i);
+  }
+}
+
+/*===========================================================================*
+ *			      fill_call_mask                                 *
+ *===========================================================================*/
+void fill_call_mask(calls, tot_nr_calls, call_mask, call_base, is_init)
+int *calls;                     /* the unordered set of calls */
+int tot_nr_calls;               /* the total number of calls */
+bitchunk_t *call_mask;          /* the call mask to fill in */
+int call_base;                  /* the base offset for the calls */
+int is_init;                    /* set when initializing a call mask */
+{
+/* Fill a call mask from an unordered set of calls. */
+  int i;
+  int call_mask_size, nr_calls;
+
+  call_mask_size = BITMAP_CHUNKS(tot_nr_calls);
+
+  /* Count the number of calls to fill in. */
+  nr_calls = 0;
+  for(i=0; calls[i] != NULL_C; i++) {
+      nr_calls++;
+  }
+
+  /* See if all calls are allowed and call mask must be completely filled. */
+  if(nr_calls == 1 && calls[0] == ALL_C) {
+      for(i=0; i < call_mask_size; i++) {
+          call_mask[i] = (~0);
+      }
+  }
+  else {
+      /* When initializing, reset the mask first. */
+      if(is_init) {
+          for(i=0; i < call_mask_size; i++) {
+              call_mask[i] = 0;
+          }
+      }
+      /* Enter calls bit by bit. */
+      for(i=0; i < nr_calls; i++) {
+          SET_BIT(call_mask, calls[i] - call_base);
+      }
+  }
+}
+
+/*===========================================================================*
+ *			     srv_to_string				     *
+ *===========================================================================*/
+char* srv_to_string(rp)
+struct rproc *rp;			/* pointer to process slot */
+{
+  struct rprocpub *rpub;
+  int slot_nr;
+  char *srv_string;
+  static char srv_string_pool[3][RS_MAX_LABEL_LEN + (DEBUG ? 256 : 64)];
+  static int srv_string_pool_index = 0;
+
+  rpub = rp->r_pub;
+  slot_nr = rp - rproc;
+  srv_string = srv_string_pool[srv_string_pool_index];
+  srv_string_pool_index = (srv_string_pool_index + 1) % 3;
+
+#define srv_str(cmd) ((cmd) == NULL || (cmd)[0] == '\0' ? "_" : (cmd))
+#define srv_ep_str(rp) (itoa((rp)->r_pub->endpoint))
+#define srv_active_str(rp) ((rp)->r_flags & RS_ACTIVE ? "*" : " ")
+#define srv_version_str(rp) ((rp)->r_new_rp || (rp)->r_next_rp ? "-" : \
+    ((rp)->r_old_rp || (rp)->r_prev_rp ? "+" : " "))
+
+#if DEBUG
+  sprintf(srv_string, "service '%s'%s%s(slot %d, ep %d, pid %d, cmd %s, script %s, proc %s, major %d, flags 0x%03x, sys_flags 0x%02x)",
+      rpub->label, srv_active_str(rp), srv_version_str(rp),
+      slot_nr, rpub->endpoint, rp->r_pid, srv_str(rp->r_cmd),
+      srv_str(rp->r_script), srv_str(rpub->proc_name), rpub->dev_nr,
+      rp->r_flags, rpub->sys_flags);
+#else
+  sprintf(srv_string, "service '%s'%s%s(slot %d, ep %d, pid %d)",
+      rpub->label, srv_active_str(rp), srv_version_str(rp),
+      slot_nr, rpub->endpoint, rp->r_pid);
+#endif
+
+  return srv_string;
+}
+
+/*===========================================================================*
+ *				reply					     *
+ *===========================================================================*/
+void reply(who, rp, m_ptr)
+endpoint_t who;                        	/* replyee */
+struct rproc *rp;                       /* replyee slot (if any) */
+message *m_ptr;                         /* reply message */
+{
+  int r;				/* send status */
+
+  /* No need to actually reply to RS */
+  if(who == RS_PROC_NR) {
+      return;
+  }
+
+  if(rs_verbose && rp)
+      printf("RS: %s being replied to\n", srv_to_string(rp));
+
+  r = ipc_sendnb(who, m_ptr);		/* send the message */
+  if (r != OK)
+      printf("RS: unable to send reply to %d: %d\n", who, r);
+}
+
+/*===========================================================================*
+ *			      late_reply				     *
+ *===========================================================================*/
+void late_reply(rp, code)
+struct rproc *rp;				/* pointer to process slot */
+int code;					/* status code */
+{
+/* If a caller is waiting for a reply, unblock it. */
+  if(rp->r_flags & RS_LATEREPLY) {
+      message m;
+      m.m_type = code;
+      if(rs_verbose)
+          printf("RS: %s late reply %d to %d for request %d\n",
+              srv_to_string(rp), code, rp->r_caller, rp->r_caller_request);
+
+      reply(rp->r_caller, NULL, &m);
+      rp->r_flags &= ~RS_LATEREPLY;
+  }
+}
+
+/*===========================================================================*
+ *				rs_isokendpt			 	     *
+ *===========================================================================*/
+int rs_isokendpt(endpoint_t endpoint, int *proc)
+{
+	*proc = _ENDPOINT_P(endpoint);
+	if(*proc < -NR_TASKS || *proc >= NR_PROCS)
+		return EINVAL;
+
+	return OK;
+}
+
+/*===========================================================================*
+ *				sched_init_proc			 	     *
+ *===========================================================================*/
+int sched_init_proc(struct rproc *rp)
+{
+  int s;
+  int is_usr_proc;
+
+  /* Make sure user processes have no scheduler. PM deals with them. */
+  is_usr_proc = !(rp->r_priv.s_flags & SYS_PROC);
+  if(is_usr_proc) assert(rp->r_scheduler == NONE);
+  if(!is_usr_proc) assert(rp->r_scheduler != NONE);
+
+  /* Start scheduling for the given process. */
+  if ((s = sched_start(rp->r_scheduler, rp->r_pub->endpoint, 
+      RS_PROC_NR, rp->r_priority, rp->r_quantum, rp->r_cpu,
+      &rp->r_scheduler, 0)) != OK) {
+      return s;
+  }
+
+  return s;
+}
+
+/*===========================================================================*
+ *				update_sig_mgrs			 	     *
+ *===========================================================================*/
+int update_sig_mgrs(struct rproc *rp, endpoint_t sig_mgr,
+	endpoint_t bak_sig_mgr)
+{
+  int r;
+  struct rprocpub *rpub;
+
+  rpub = rp->r_pub;
+
+  if(rs_verbose)
+      printf("RS: %s updates signal managers: %d%s / %d\n", srv_to_string(rp),
+          sig_mgr == SELF ? rpub->endpoint : sig_mgr,
+          sig_mgr == SELF ? "(SELF)" : "",
+          bak_sig_mgr == NONE ? -1 : bak_sig_mgr);
+
+  /* Synch privilege structure with the kernel. */
+  if ((r = sys_getpriv(&rp->r_priv, rpub->endpoint)) != OK) {
+      printf("unable to synch privilege structure: %d", r);
+      return r;
+  }
+
+  /* Set signal managers. */
+  rp->r_priv.s_sig_mgr = sig_mgr;
+  rp->r_priv.s_bak_sig_mgr = bak_sig_mgr;
+
+  /* Update privilege structure. */
+  r = sys_privctl(rpub->endpoint, SYS_PRIV_UPDATE_SYS, &rp->r_priv);
+  if(r != OK) {
+      printf("unable to update privilege structure: %d", r);
+      return r;
+  }
+
+  return OK;
+}
+
diff -x .* -ruPN minix2/minix/servers/sched/Makefile minix/minix/servers/sched/Makefile
--- minix2/minix/servers/sched/Makefile	Tue May 24 18:41:16 2016
+++ minix/minix/servers/sched/Makefile	Tue May 24 18:46:23 2016
@@ -1,12 +1,10 @@
-# Makefile for Scheduler (SCHED)
-PROG=	sched
-SRCS=	main.c schedule.c utility.c
-
-DPADD+=	${LIBSYS} ${LIBTIMERS}
-LDADD+=	-lsys -ltimers
-
-CPPFLAGS.main.c+=	-I${NETBSDSRCDIR}/minix
-CPPFLAGS.schedule.c+=	-I${NETBSDSRCDIR}/minix
-CPPFLAGS.utility.c+=	-I${NETBSDSRCDIR}/minix
-
-.include <minix.service.mk>
+# Makefile for Scheduler (SCHED)
+PROG=	sched
+SRCS=	main.c
+
+DPADD+=	${LIBSYS} ${LIBTIMERS}
+LDADD+=	-lsys -ltimers
+
+CPPFLAGS.main.c+=	-I${NETBSDSRCDIR}/minix
+
+.include <minix.service.mk>
diff -x .* -ruPN minix2/minix/servers/sched/main.c minix/minix/servers/sched/main.c
--- minix2/minix/servers/sched/main.c	Tue May 24 18:41:16 2016
+++ minix/minix/servers/sched/main.c	Tue May 24 18:46:23 2016
@@ -1,125 +1,130 @@
-/* This file contains the main program of the SCHED scheduler. It will sit idle
- * until asked, by PM, to take over scheduling a particular process.
- */
-
-/* The _MAIN def indicates that we want the schedproc structs to be created
- * here. Used from within schedproc.h */
-#define _MAIN
-
-#include "sched.h"
-#include "schedproc.h"
-
-/* Declare some local functions. */
-static void reply(endpoint_t whom, message *m_ptr);
-static void sef_local_startup(void);
-
-struct machine machine;		/* machine info */
-
-/*===========================================================================*
- *				main					     *
- *===========================================================================*/
-int main(void)
-{
-	/* Main routine of the scheduler. */
-	message m_in;	/* the incoming message itself is kept here. */
-	int call_nr;	/* system call number */
-	int who_e;	/* caller's endpoint */
-	int result;	/* result to system call */
-	int rv;
-	int s;
-
-	/* SEF local startup. */
-	sef_local_startup();
-
-	if (OK != (s=sys_getmachine(&machine)))
-		panic("couldn't get machine info: %d", s);
-	/* Initialize scheduling timers, used for running balance_queues */
-	init_scheduling();
-
-	/* This is SCHED's main loop - get work and do it, forever and forever. */
-	while (TRUE) {
-		int ipc_status;
-
-		/* Wait for the next message and extract useful information from it. */
-		if (sef_receive_status(ANY, &m_in, &ipc_status) != OK)
-			panic("SCHED sef_receive error");
-		who_e = m_in.m_source;	/* who sent the message */
-		call_nr = m_in.m_type;	/* system call number */
-
-		/* Check for system notifications first. Special cases. */
-		if (is_ipc_notify(ipc_status)) {
-			switch(who_e) {
-				case CLOCK:
-					expire_timers(m_in.m_notify.timestamp);
-					continue;	/* don't reply */
-				default :
-					result = ENOSYS;
-			}
-
-			goto sendreply;
-		}
-
-		switch(call_nr) {
-		case SCHEDULING_INHERIT:
-		case SCHEDULING_START:
-			result = do_start_scheduling(&m_in);
-			break;
-		case SCHEDULING_STOP:
-			result = do_stop_scheduling(&m_in);
-			break;
-		case SCHEDULING_SET_NICE:
-			result = do_nice(&m_in);
-			break;
-		case SCHEDULING_NO_QUANTUM:
-			/* This message was sent from the kernel, don't reply */
-			if (IPC_STATUS_FLAGS_TEST(ipc_status,
-				IPC_FLG_MSG_FROM_KERNEL)) {
-				if ((rv = do_noquantum(&m_in)) != (OK)) {
-					printf("SCHED: Warning, do_noquantum "
-						"failed with %d\n", rv);
-				}
-				continue; /* Don't reply */
-			}
-			else {
-				printf("SCHED: process %d faked "
-					"SCHEDULING_NO_QUANTUM message!\n",
-						who_e);
-				result = EPERM;
-			}
-			break;
-		default:
-			result = no_sys(who_e, call_nr);
-		}
-
-sendreply:
-		/* Send reply. */
-		if (result != SUSPEND) {
-			m_in.m_type = result;  		/* build reply message */
-			reply(who_e, &m_in);		/* send it away */
-		}
- 	}
-	return(OK);
-}
-
-/*===========================================================================*
- *				reply					     *
- *===========================================================================*/
-static void reply(endpoint_t who_e, message *m_ptr)
-{
-	int s = ipc_send(who_e, m_ptr);    /* send the message */
-	if (OK != s)
-		printf("SCHED: unable to send reply to %d: %d\n", who_e, s);
-}
-
-/*===========================================================================*
- *			       sef_local_startup			     *
- *===========================================================================*/
-static void sef_local_startup(void)
-{
-	/* No init callbacks for now. */
-	/* No live update support for now. */
-	/* No signal callbacks for now. */
-
-	/* Let SEF perform startup. */
-	sef_startup();
-}
+
+#define _MAIN
+
+#include "sched.h"
+#include <machine/archtypes.h>
+#include <sys/resource.h> /* for PRIO_MAX & PRIO_MIN */
+#include "kernel/proc.h" /* for queue constants */
+#include "schedproc.h"
+
+static void reply(endpoint_t whom, message *m_ptr);
+static void sef_local_startup(void);
+int sched_isokendpt(int endpoint, int *proc);
+int sched_isemtyendpt(int endpoint, int *proc);
+
+
+int main(void)
+{
+	/* Main routine of the scheduler. */
+	message m_in;	/* the incoming message itself is kept here. */
+	message m_in_;
+	int result, rv;
+	int call_nr, who_e, proc_nr_n;	/* system call number */
+	
+	/* SEF local startup. */
+	sef_local_startup();
+
+	
+	while (TRUE) {
+		int ipc_status;
+		register struct schedproc *rmp;
+		/* Wait for the next message and extract useful information from it. */
+		if (sef_receive_status(ANY, &m_in, &ipc_status) != OK)
+			panic("SCHED sef_receive error");
+
+		m_in_ = m_in;
+		call_nr = m_in.m_type;	/* system call number */
+		who_e = m_in.m_source;
+
+		if ((rv = sched_isemtyendpt(m_in.m_lsys_sched_scheduling_start.endpoint,
+			&proc_nr_n)) != OK) {
+			return rv;
+		}
+	
+		rmp = &schedproc[proc_nr_n];  //Registramos los procesos
+
+		rmp->endpoint     = m_in.m_lsys_sched_scheduling_start.endpoint;
+		rmp->parent       = m_in.m_lsys_sched_scheduling_start.parent;
+
+		if (is_ipc_notify(ipc_status)) {
+			switch(who_e) {
+				case CLOCK:
+					expire_timers(m_in.m_notify.timestamp);
+					continue;	/* don't reply */
+				default :
+					result = ENOSYS;
+			}
+
+			goto sendreply;
+		}
+
+		endpoint_t p = m_in.m_lsys_sched_scheduling_start.parent;
+		sched_isokendpt(p, &proc_nr_n);
+
+		p = schedproc[proc_nr_n].parent;
+
+			if (p == 32958 || p == 32960 || p == 32962){
+
+				result = _taskcall(SCHED_FCFS_PROC_NR, call_nr, &m_in);
+			}else{
+
+				result = _taskcall(SCHED_RR_PROC_NR, call_nr, &m_in);
+			}
+
+sendreply:
+		/* Send reply. */
+		if (result != SUSPEND) {
+			m_in.m_type = result;  		/* build reply message */
+			reply(who_e, &m_in);		/* send it away */
+		}
+		
+		
+ 	}
+return(OK);
+}
+
+static void sef_local_startup(void)
+{
+	sef_startup();
+}
+static void reply(endpoint_t who_e, message *m_ptr)
+{
+	int s = ipc_send(who_e, m_ptr);    /* send the message */
+	if (OK != s)
+		printf("SCHED: unable to send reply to %d: %d\n", who_e, s);
+}
+
+//hola
+
+
+/*===========================================================================*
+ *				sched_isokendpt			 	     *
+ *===========================================================================*/
+int sched_isokendpt(int endpoint, int *proc)
+{
+	*proc = _ENDPOINT_P(endpoint);
+	if (*proc < 0)
+		return (EBADEPT); /* Don't schedule tasks */
+	if(*proc >= NR_PROCS)
+		return (EINVAL);
+	if(endpoint != schedproc[*proc].endpoint)
+		return (EDEADEPT);
+	if(!(schedproc[*proc].flags & IN_USE))
+		return (EDEADEPT);
+	return (OK);
+}
+
+/*===========================================================================*
+ *				sched_isemtyendpt		 	     *
+ *===========================================================================*/
+int sched_isemtyendpt(int endpoint, int *proc)
+{
+	*proc = _ENDPOINT_P(endpoint);
+	if (*proc < 0)
+		return (EBADEPT); /* Don't schedule tasks */
+	if(*proc >= NR_PROCS)
+		return (EINVAL);
+	if(schedproc[*proc].flags & IN_USE)
+		return (EDEADEPT);
+	return (OK);
+}
\ No newline at end of file
diff -x .* -ruPN minix2/minix/servers/sched/main2.c minix/minix/servers/sched/main2.c
--- minix2/minix/servers/sched/main2.c	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched/main2.c	Tue May 24 18:46:23 2016
@@ -0,0 +1,75 @@
+
+#define _MAIN
+
+#include "sched.h"
+
+static void reply(endpoint_t whom, message *m_ptr);
+static void sef_local_startup(void);
+
+int main(void)
+{
+	/* Main routine of the scheduler. */
+	message m_in;	/* the incoming message itself is kept here. */
+	message m_in_;
+	int result;
+	int call_nr, who_e;	/* system call number */
+	
+	/* SEF local startup. */
+	sef_local_startup();
+
+	
+	while (TRUE) {
+		int ipc_status;
+
+		printf("ADMINISTRADOR\n");
+
+		/* Wait for the next message and extract useful information from it. */
+		if (sef_receive_status(ANY, &m_in, &ipc_status) != OK)
+			panic("SCHED sef_receive error");
+
+		m_in_ = m_in;
+		call_nr = m_in.m_type;	/* system call number */
+		who_e = m_in.m_source;
+
+		if (is_ipc_notify(ipc_status)) {
+			switch(who_e) {
+				case CLOCK:
+					expire_timers(m_in.m_notify.timestamp);
+					continue;	/* don't reply */
+				default :
+					result = ENOSYS;
+			}
+
+			goto sendreply;
+		}
+
+		if(m_in.m_lsys_sched_scheduling_start.parent == INIT_PROC_NR){
+			result = _taskcall(SCHED_RR_PROC_NR, call_nr, &m_in);
+		}else{
+			result = _taskcall(SCHED_FCFS_PROC_NR, call_nr, &m_in);
+		}
+
+sendreply:
+		/* Send reply. */
+		if (result != SUSPEND) {
+			m_in.m_type = result;  		/* build reply message */
+			reply(who_e, &m_in);		/* send it away */
+		}
+		
+		
+ 	}
+return(OK);
+}
+
+static void sef_local_startup(void)
+{
+	sef_startup();
+}
+static void reply(endpoint_t who_e, message *m_ptr)
+{
+	int s = ipc_send(who_e, m_ptr);    /* send the message */
+	if (OK != s)
+		printf("SCHED: unable to send reply to %d: %d\n", who_e, s);
+}
+
+//hola
\ No newline at end of file
diff -x .* -ruPN minix2/minix/servers/sched/proto.h minix/minix/servers/sched/proto.h
--- minix2/minix/servers/sched/proto.h	Tue May 24 18:41:16 2016
+++ minix/minix/servers/sched/proto.h	Tue May 24 18:46:23 2016
@@ -1,21 +1,6 @@
-/* Function prototypes. */
-
-struct schedproc;
-#include <minix/timers.h>
-
-/* main.c */
-int main(void);
-void setreply(int proc_nr, int result);
-
-/* schedule.c */
-int do_noquantum(message *m_ptr);
-int do_start_scheduling(message *m_ptr);
-int do_stop_scheduling(message *m_ptr);
-int do_nice(message *m_ptr);
-void init_scheduling(void);
-
-/* utility.c */
-int no_sys(int who_e, int call_nr);
-int sched_isokendpt(int ep, int *proc);
-int sched_isemtyendpt(int ep, int *proc);
-int accept_message(message *m_ptr);
+struct schedproc;
+#include <minix/timers.h>
+
+
+/* main.c */
+int main(void);
\ No newline at end of file
diff -x .* -ruPN minix2/minix/servers/sched/sched.h minix/minix/servers/sched/sched.h
--- minix2/minix/servers/sched/sched.h	Tue May 24 18:41:16 2016
+++ minix/minix/servers/sched/sched.h	Tue May 24 18:46:23 2016
@@ -1,19 +1,18 @@
-/* This is the master header for the Scheduler.  It includes some other files
- * and defines the principal constants.
- */
-#define _SYSTEM		1	/* tell headers that this is the kernel */
-
-/* The following are so basic, all the *.c files get them automatically. */
-#include <minix/config.h>	/* MUST be first */
-#include <sys/types.h>
-#include <minix/const.h>
-
-#include <minix/syslib.h>
-#include <minix/sysutil.h>
-#include <minix/timers.h>
-
-#include <errno.h>
-
-#include "proto.h"
-
-extern struct machine machine;		/* machine info */
+/* This is the master header for the Scheduler.  It includes some other files
+ * and defines the principal constants.
+ */
+#define _SYSTEM		1	/* tell headers that this is the kernel */
+
+/* The following are so basic, all the *.c files get them automatically. */
+#include <minix/config.h>	/* MUST be first */
+#include <sys/types.h>
+#include <minix/const.h>
+
+#include <minix/syslib.h>
+#include <minix/sysutil.h>
+#include <minix/timers.h>
+
+#include <errno.h>
+
+#include "proto.h"
+
diff -x .* -ruPN minix2/minix/servers/sched/schedule.c minix/minix/servers/sched/schedule.c
--- minix2/minix/servers/sched/schedule.c	Tue May 24 18:41:16 2016
+++ minix/minix/servers/sched/schedule.c	Thu Jan  1 00:00:00 1970
@@ -1,367 +0,0 @@
-/* This file contains the scheduling policy for SCHED
- *
- * The entry points are:
- *   do_noquantum:        Called on behalf of process' that run out of quantum
- *   do_start_scheduling  Request to start scheduling a proc
- *   do_stop_scheduling   Request to stop scheduling a proc
- *   do_nice		  Request to change the nice level on a proc
- *   init_scheduling      Called from main.c to set up/prepare scheduling
- */
-#include "sched.h"
-#include "schedproc.h"
-#include <assert.h>
-#include <minix/com.h>
-#include <machine/archtypes.h>
-#include "kernel/proc.h" /* for queue constants */
-
-static minix_timer_t sched_timer;
-static unsigned balance_timeout;
-
-#define BALANCE_TIMEOUT	5 /* how often to balance queues in seconds */
-
-static int schedule_process(struct schedproc * rmp, unsigned flags);
-static void balance_queues(minix_timer_t *tp);
-
-#define SCHEDULE_CHANGE_PRIO	0x1
-#define SCHEDULE_CHANGE_QUANTUM	0x2
-#define SCHEDULE_CHANGE_CPU	0x4
-
-#define SCHEDULE_CHANGE_ALL	(	\
-		SCHEDULE_CHANGE_PRIO	|	\
-		SCHEDULE_CHANGE_QUANTUM	|	\
-		SCHEDULE_CHANGE_CPU		\
-		)
-
-#define schedule_process_local(p)	\
-	schedule_process(p, SCHEDULE_CHANGE_PRIO | SCHEDULE_CHANGE_QUANTUM)
-#define schedule_process_migrate(p)	\
-	schedule_process(p, SCHEDULE_CHANGE_CPU)
-
-#define CPU_DEAD	-1
-
-#define cpu_is_available(c)	(cpu_proc[c] >= 0)
-
-#define DEFAULT_USER_TIME_SLICE 200
-
-/* processes created by RS are sysytem processes */
-#define is_system_proc(p)	((p)->parent == RS_PROC_NR)
-
-static unsigned cpu_proc[CONFIG_MAX_CPUS];
-
-static void pick_cpu(struct schedproc * proc)
-{
-#ifdef CONFIG_SMP
-	unsigned cpu, c;
-	unsigned cpu_load = (unsigned) -1;
-	
-	if (machine.processors_count == 1) {
-		proc->cpu = machine.bsp_id;
-		return;
-	}
-
-	/* schedule sysytem processes only on the boot cpu */
-	if (is_system_proc(proc)) {
-		proc->cpu = machine.bsp_id;
-		return;
-	}
-
-	/* if no other cpu available, try BSP */
-	cpu = machine.bsp_id;
-	for (c = 0; c < machine.processors_count; c++) {
-		/* skip dead cpus */
-		if (!cpu_is_available(c))
-			continue;
-		if (c != machine.bsp_id && cpu_load > cpu_proc[c]) {
-			cpu_load = cpu_proc[c];
-			cpu = c;
-		}
-	}
-	proc->cpu = cpu;
-	cpu_proc[cpu]++;
-#else
-	proc->cpu = 0;
-#endif
-}
-
-/*===========================================================================*
- *				do_noquantum				     *
- *===========================================================================*/
-
-int do_noquantum(message *m_ptr)
-{
-	register struct schedproc *rmp;
-	int rv, proc_nr_n;
-
-	if (sched_isokendpt(m_ptr->m_source, &proc_nr_n) != OK) {
-		printf("SCHED: WARNING: got an invalid endpoint in OOQ msg %u.\n",
-		m_ptr->m_source);
-		return EBADEPT;
-	}
-
-	rmp = &schedproc[proc_nr_n];
-	if (rmp->priority < MIN_USER_Q) {
-		rmp->priority += 1; /* lower priority */
-	}
-
-	if ((rv = schedule_process_local(rmp)) != OK) {
-		return rv;
-	}
-	return OK;
-}
-
-/*===========================================================================*
- *				do_stop_scheduling			     *
- *===========================================================================*/
-int do_stop_scheduling(message *m_ptr)
-{
-	register struct schedproc *rmp;
-	int proc_nr_n;
-
-	/* check who can send you requests */
-	if (!accept_message(m_ptr))
-		return EPERM;
-
-	if (sched_isokendpt(m_ptr->m_lsys_sched_scheduling_stop.endpoint,
-		    &proc_nr_n) != OK) {
-		printf("SCHED: WARNING: got an invalid endpoint in OOQ msg "
-		"%d\n", m_ptr->m_lsys_sched_scheduling_stop.endpoint);
-		return EBADEPT;
-	}
-
-	rmp = &schedproc[proc_nr_n];
-#ifdef CONFIG_SMP
-	cpu_proc[rmp->cpu]--;
-#endif
-	rmp->flags = 0; /*&= ~IN_USE;*/
-
-	return OK;
-}
-
-/*===========================================================================*
- *				do_start_scheduling			     *
- *===========================================================================*/
-int do_start_scheduling(message *m_ptr)
-{
-	register struct schedproc *rmp;
-	int rv, proc_nr_n, parent_nr_n;
-	
-	/* we can handle two kinds of messages here */
-	assert(m_ptr->m_type == SCHEDULING_START || 
-		m_ptr->m_type == SCHEDULING_INHERIT);
-
-	/* check who can send you requests */
-	if (!accept_message(m_ptr))
-		return EPERM;
-
-	/* Resolve endpoint to proc slot. */
-	if ((rv = sched_isemtyendpt(m_ptr->m_lsys_sched_scheduling_start.endpoint,
-			&proc_nr_n)) != OK) {
-		return rv;
-	}
-	rmp = &schedproc[proc_nr_n];
-
-	/* Populate process slot */
-	rmp->endpoint     = m_ptr->m_lsys_sched_scheduling_start.endpoint;
-	rmp->parent       = m_ptr->m_lsys_sched_scheduling_start.parent;
-	rmp->max_priority = m_ptr->m_lsys_sched_scheduling_start.maxprio;
-	if (rmp->max_priority >= NR_SCHED_QUEUES) {
-		return EINVAL;
-	}
-
-	/* Inherit current priority and time slice from parent. Since there
-	 * is currently only one scheduler scheduling the whole system, this
-	 * value is local and we assert that the parent endpoint is valid */
-	if (rmp->endpoint == rmp->parent) {
-		/* We have a special case here for init, which is the first
-		   process scheduled, and the parent of itself. */
-		rmp->priority   = USER_Q;
-		rmp->time_slice = DEFAULT_USER_TIME_SLICE;
-
-		/*
-		 * Since kernel never changes the cpu of a process, all are
-		 * started on the BSP and the userspace scheduling hasn't
-		 * changed that yet either, we can be sure that BSP is the
-		 * processor where the processes run now.
-		 */
-#ifdef CONFIG_SMP
-		rmp->cpu = machine.bsp_id;
-		/* FIXME set the cpu mask */
-#endif
-	}
-	
-	switch (m_ptr->m_type) {
-
-	case SCHEDULING_START:
-		/* We have a special case here for system processes, for which
-		 * quanum and priority are set explicitly rather than inherited 
-		 * from the parent */
-		rmp->priority   = rmp->max_priority;
-		rmp->time_slice = m_ptr->m_lsys_sched_scheduling_start.quantum;
-		break;
-		
-	case SCHEDULING_INHERIT:
-		/* Inherit current priority and time slice from parent. Since there
-		 * is currently only one scheduler scheduling the whole system, this
-		 * value is local and we assert that the parent endpoint is valid */
-		if ((rv = sched_isokendpt(m_ptr->m_lsys_sched_scheduling_start.parent,
-				&parent_nr_n)) != OK)
-			return rv;
-
-		rmp->priority = schedproc[parent_nr_n].priority;
-		rmp->time_slice = schedproc[parent_nr_n].time_slice;
-		break;
-		
-	default: 
-		/* not reachable */
-		assert(0);
-	}
-
-	/* Take over scheduling the process. The kernel reply message populates
-	 * the processes current priority and its time slice */
-	if ((rv = sys_schedctl(0, rmp->endpoint, 0, 0, 0)) != OK) {
-		printf("Sched: Error taking over scheduling for %d, kernel said %d\n",
-			rmp->endpoint, rv);
-		return rv;
-	}
-	rmp->flags = IN_USE;
-
-	/* Schedule the process, giving it some quantum */
-	pick_cpu(rmp);
-	while ((rv = schedule_process(rmp, SCHEDULE_CHANGE_ALL)) == EBADCPU) {
-		/* don't try this CPU ever again */
-		cpu_proc[rmp->cpu] = CPU_DEAD;
-		pick_cpu(rmp);
-	}
-
-	if (rv != OK) {
-		printf("Sched: Error while scheduling process, kernel replied %d\n",
-			rv);
-		return rv;
-	}
-
-	/* Mark ourselves as the new scheduler.
-	 * By default, processes are scheduled by the parents scheduler. In case
-	 * this scheduler would want to delegate scheduling to another
-	 * scheduler, it could do so and then write the endpoint of that
-	 * scheduler into the "scheduler" field.
-	 */
-
-	m_ptr->m_sched_lsys_scheduling_start.scheduler = SCHED_PROC_NR;
-
-	return OK;
-}
-
-/*===========================================================================*
- *				do_nice					     *
- *===========================================================================*/
-int do_nice(message *m_ptr)
-{
-	struct schedproc *rmp;
-	int rv;
-	int proc_nr_n;
-	unsigned new_q, old_q, old_max_q;
-
-	/* check who can send you requests */
-	if (!accept_message(m_ptr))
-		return EPERM;
-
-	if (sched_isokendpt(m_ptr->m_pm_sched_scheduling_set_nice.endpoint, &proc_nr_n) != OK) {
-		printf("SCHED: WARNING: got an invalid endpoint in OoQ msg "
-		"%d\n", m_ptr->m_pm_sched_scheduling_set_nice.endpoint);
-		return EBADEPT;
-	}
-
-	rmp = &schedproc[proc_nr_n];
-	new_q = m_ptr->m_pm_sched_scheduling_set_nice.maxprio;
-	if (new_q >= NR_SCHED_QUEUES) {
-		return EINVAL;
-	}
-
-	/* Store old values, in case we need to roll back the changes */
-	old_q     = rmp->priority;
-	old_max_q = rmp->max_priority;
-
-	/* Update the proc entry and reschedule the process */
-	rmp->max_priority = rmp->priority = new_q;
-
-	if ((rv = schedule_process_local(rmp)) != OK) {
-		/* Something went wrong when rescheduling the process, roll
-		 * back the changes to proc struct */
-		rmp->priority     = old_q;
-		rmp->max_priority = old_max_q;
-	}
-
-	return rv;
-}
-
-/*===========================================================================*
- *				schedule_process			     *
- *===========================================================================*/
-static int schedule_process(struct schedproc * rmp, unsigned flags)
-{
-	int err;
-	int new_prio, new_quantum, new_cpu;
-
-	pick_cpu(rmp);
-
-	if (flags & SCHEDULE_CHANGE_PRIO)
-		new_prio = rmp->priority;
-	else
-		new_prio = -1;
-
-	if (flags & SCHEDULE_CHANGE_QUANTUM)
-		new_quantum = rmp->time_slice;
-	else
-		new_quantum = -1;
-
-	if (flags & SCHEDULE_CHANGE_CPU)
-		new_cpu = rmp->cpu;
-	else
-		new_cpu = -1;
-
-	if ((err = sys_schedule(rmp->endpoint, new_prio,
-		new_quantum, new_cpu)) != OK) {
-		printf("PM: An error occurred when trying to schedule %d: %d\n",
-		rmp->endpoint, err);
-	}
-
-	return err;
-}
-
-
-/*===========================================================================*
- *				start_scheduling			     *
- *===========================================================================*/
-
-void init_scheduling(void)
-{
-	balance_timeout = BALANCE_TIMEOUT * sys_hz();
-	init_timer(&sched_timer);
-	set_timer(&sched_timer, balance_timeout, balance_queues, 0);
-}
-
-/*===========================================================================*
- *				balance_queues				     *
- *===========================================================================*/
-
-/* This function in called every 100 ticks to rebalance the queues. The current
- * scheduler bumps processes down one priority when ever they run out of
- * quantum. This function will find all proccesses that have been bumped down,
- * and pulls them back up. This default policy will soon be changed.
- */
-static void balance_queues(minix_timer_t *tp)
-{
-	struct schedproc *rmp;
-	int proc_nr;
-
-	for (proc_nr=0, rmp=schedproc; proc_nr < NR_PROCS; proc_nr++, rmp++) {
-		if (rmp->flags & IN_USE) {
-			if (rmp->priority > rmp->max_priority) {
-				rmp->priority -= 1; /* increase priority */
-				schedule_process_local(rmp);
-			}
-		}
-	}
-
-	set_timer(&sched_timer, balance_timeout, balance_queues, 0);
-}
diff -x .* -ruPN minix2/minix/servers/sched/utility.c minix/minix/servers/sched/utility.c
--- minix2/minix/servers/sched/utility.c	Tue May 24 18:41:16 2016
+++ minix/minix/servers/sched/utility.c	Thu Jan  1 00:00:00 1970
@@ -1,75 +0,0 @@
-/* This file contains some utility routines for SCHED.
- *
- * The entry points are:
- *   no_sys:		called for invalid system call numbers
- *   sched_isokendpt:	check the validity of an endpoint
- *   sched_isemtyendpt  check for validity and availability of endpoint slot
- *   accept_message	check whether message is allowed
- */
-
-#include "sched.h"
-#include <machine/archtypes.h>
-#include <sys/resource.h> /* for PRIO_MAX & PRIO_MIN */
-#include "kernel/proc.h" /* for queue constants */
-#include "schedproc.h"
-
-/*===========================================================================*
- *				no_sys					     *
- *===========================================================================*/
-int no_sys(int who_e, int call_nr)
-{
-/* A system call number not implemented by PM has been requested. */
-  printf("SCHED: in no_sys, call nr %d from %d\n", call_nr, who_e);
-  return(ENOSYS);
-}
-
-
-/*===========================================================================*
- *				sched_isokendpt			 	     *
- *===========================================================================*/
-int sched_isokendpt(int endpoint, int *proc)
-{
-	*proc = _ENDPOINT_P(endpoint);
-	if (*proc < 0)
-		return (EBADEPT); /* Don't schedule tasks */
-	if(*proc >= NR_PROCS)
-		return (EINVAL);
-	if(endpoint != schedproc[*proc].endpoint)
-		return (EDEADEPT);
-	if(!(schedproc[*proc].flags & IN_USE))
-		return (EDEADEPT);
-	return (OK);
-}
-
-/*===========================================================================*
- *				sched_isemtyendpt		 	     *
- *===========================================================================*/
-int sched_isemtyendpt(int endpoint, int *proc)
-{
-	*proc = _ENDPOINT_P(endpoint);
-	if (*proc < 0)
-		return (EBADEPT); /* Don't schedule tasks */
-	if(*proc >= NR_PROCS)
-		return (EINVAL);
-	if(schedproc[*proc].flags & IN_USE)
-		return (EDEADEPT);
-	return (OK);
-}
-
-/*===========================================================================*
- *				accept_message				     *
- *===========================================================================*/
-int accept_message(message *m_ptr)
-{
-	/* accept all messages from PM and RS */
-	switch (m_ptr->m_source) {
-
-		case PM_PROC_NR:
-		case RS_PROC_NR:
-			return 1;
-			
-	}
-	
-	/* no other messages are allowable */
-	return 0;
-}
diff -x .* -ruPN minix2/minix/servers/sched_fcfs/Makefile minix/minix/servers/sched_fcfs/Makefile
--- minix2/minix/servers/sched_fcfs/Makefile	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_fcfs/Makefile	Tue May 24 18:46:23 2016
@@ -0,0 +1,12 @@
+# Makefile for Scheduler (SCHED)
+PROG=	sched_fcfs
+SRCS=	main.c schedule.c utility.c
+
+DPADD+=	${LIBSYS} ${LIBTIMERS}
+LDADD+=	-lsys -ltimers
+
+CPPFLAGS.main.c+=	-I${NETBSDSRCDIR}/minix
+CPPFLAGS.schedule.c+=	-I${NETBSDSRCDIR}/minix
+CPPFLAGS.utility.c+=	-I${NETBSDSRCDIR}/minix
+
+.include <minix.service.mk>
diff -x .* -ruPN minix2/minix/servers/sched_fcfs/main.c minix/minix/servers/sched_fcfs/main.c
--- minix2/minix/servers/sched_fcfs/main.c	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_fcfs/main.c	Tue May 24 18:46:23 2016
@@ -0,0 +1,123 @@
+/* This file contains the main program of the SCHED scheduler. It will sit idle
+ * until asked, by PM, to take over scheduling a particular process.
+ */
+
+/* The _MAIN def indicates that we want the schedproc structs to be created
+ * here. Used from within schedproc.h */
+#define _MAIN
+
+#include "sched_fcfs.h"
+#include "schedproc.h"
+
+/* Declare some local functions. */
+static void reply(endpoint_t whom, message *m_ptr);
+static void sef_local_startup(void);
+
+struct machine machine;		/* machine info */
+
+/*===========================================================================*
+ *				main					     *
+ *===========================================================================*/
+int main(void)
+{
+	/* Main routine of the scheduler. */
+	message m_in;	/* the incoming message itself is kept here. */
+	int call_nr;	/* system call number */
+	int who_e;	/* caller's endpoint */
+	int result;	/* result to system call */
+	int rv;
+	int s;
+
+	/* SEF local startup. */
+	sef_local_startup();
+
+	if (OK != (s=sys_getmachine(&machine)))
+		panic("couldn't get machine info: %d", s);
+	/* Initialize scheduling timers, used for running balance_queues */
+
+
+	/* This is SCHED's main loop - get work and do it, forever and forever. */
+	while (TRUE) {
+		int ipc_status;
+
+		/* Wait for the next message and extract useful information from it. */
+		if (sef_receive_status(ANY, &m_in, &ipc_status) != OK)
+			panic("SCHED sef_receive error");
+		who_e = m_in.m_source;	/* who sent the message */
+		call_nr = m_in.m_type;	/* system call number */
+
+		/* Check for system notifications first. Special cases. */
+		if (is_ipc_notify(ipc_status)) {
+			switch(who_e) {
+				case CLOCK:
+
+					continue;	/* don't reply */
+				default :
+					result = ENOSYS;
+			}
+
+			goto sendreply;
+		}
+		switch(call_nr) {
+		case SCHEDULING_INHERIT:
+		case SCHEDULING_START:
+			result = do_start_scheduling(&m_in);
+			break;
+		case SCHEDULING_STOP:
+			result = do_stop_scheduling(&m_in);
+			break;
+		case SCHEDULING_SET_NICE:
+			result = do_nice(&m_in);
+			break;
+		case SCHEDULING_NO_QUANTUM:
+			/* This message was sent from the kernel, don't reply */
+			if (IPC_STATUS_FLAGS_TEST(ipc_status,
+				IPC_FLG_MSG_FROM_KERNEL)) {
+				if ((rv = do_noquantum(&m_in)) != (OK)) {
+					printf("SCHED: Warning, do_noquantum "
+						"failed with %d\n", rv);
+				}
+				continue; /* Don't reply */
+			}
+			else {
+				printf("SCHED: process %d faked "
+					"SCHEDULING_NO_QUANTUM message!\n",
+						who_e);
+				result = EPERM;
+			}
+			break;
+		default:
+			result = no_sys(who_e, call_nr);
+		}
+sendreply:
+		/* Send reply. */
+		if (result != SUSPEND) {
+			m_in.m_type = result;  		/* build reply message */
+			reply(who_e, &m_in);		/* send it away */
+		}
+ 	}
+	return(OK);
+}
+
+/*===========================================================================*
+ *				reply					     *
+ *===========================================================================*/
+static void reply(endpoint_t who_e, message *m_ptr)
+{
+	int s = ipc_send(who_e, m_ptr);    /* send the message */
+	if (OK != s)
+		printf("SCHED: unable to send reply to %d: %d\n", who_e, s);
+}
+
+/*===========================================================================*
+ *			       sef_local_startup			     *
+ *===========================================================================*/
+static void sef_local_startup(void)
+{
+	/* No init callbacks for now. */
+	/* No live update support for now. */
+	/* No signal callbacks for now. */
+
+	/* Let SEF perform startup. */
+	sef_startup();
+}
diff -x .* -ruPN minix2/minix/servers/sched_fcfs/proto.h minix/minix/servers/sched_fcfs/proto.h
--- minix2/minix/servers/sched_fcfs/proto.h	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_fcfs/proto.h	Tue May 24 18:46:23 2016
@@ -0,0 +1,21 @@
+/* Function prototypes. */
+
+struct schedproc;
+#include <minix/timers.h>
+
+/* main.c */
+int main(void);
+void setreply(int proc_nr, int result);
+
+/* schedule.c */
+int do_noquantum(message *m_ptr);
+int do_start_scheduling(message *m_ptr);
+int do_stop_scheduling(message *m_ptr);
+int do_nice(message *m_ptr);
+void init_scheduling(void);
+
+/* utility.c */
+int no_sys(int who_e, int call_nr);
+int sched_isokendpt(int ep, int *proc);
+int sched_isemtyendpt(int ep, int *proc);
+int accept_message(message *m_ptr);
diff -x .* -ruPN minix2/minix/servers/sched_fcfs/sched_fcfs.h minix/minix/servers/sched_fcfs/sched_fcfs.h
--- minix2/minix/servers/sched_fcfs/sched_fcfs.h	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_fcfs/sched_fcfs.h	Tue May 24 18:46:23 2016
@@ -0,0 +1,19 @@
+/* This is the master header for the Scheduler.  It includes some other files
+ * and defines the principal constants.
+ */
+#define _SYSTEM		1	/* tell headers that this is the kernel */
+
+/* The following are so basic, all the *.c files get them automatically. */
+#include <minix/config.h>	/* MUST be first */
+#include <sys/types.h>
+#include <minix/const.h>
+
+#include <minix/syslib.h>
+#include <minix/sysutil.h>
+#include <minix/timers.h>
+
+#include <errno.h>
+
+#include "proto.h"
+
+extern struct machine machine;		/* machine info */
diff -x .* -ruPN minix2/minix/servers/sched_fcfs/schedproc.h minix/minix/servers/sched_fcfs/schedproc.h
--- minix2/minix/servers/sched_fcfs/schedproc.h	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_fcfs/schedproc.h	Tue May 24 18:46:23 2016
@@ -0,0 +1,39 @@
+/* This table has one slot per process.  It contains scheduling information
+ * for each process.
+ */
+#include <limits.h>
+
+#include <minix/bitmap.h>
+
+/* EXTERN should be extern except in main.c, where we want to keep the struct */
+#ifdef _MAIN
+#undef EXTERN
+#define EXTERN
+#endif
+
+#ifndef CONFIG_SMP
+#define CONFIG_MAX_CPUS 1
+#endif
+
+/**
+ * We might later want to add more information to this table, such as the
+ * process owner, process group or cpumask.
+ */
+
+EXTERN struct schedproc {
+	endpoint_t endpoint;	/* process endpoint id */
+	endpoint_t parent;	/* parent endpoint id */
+	unsigned flags;		/* flag bits */
+
+	/* User space scheduling */
+	unsigned max_priority;	/* this process' highest allowed priority */
+	unsigned priority;		/* the process' current priority */
+	unsigned time_slice;		/* this process's time slice */
+	unsigned cpu;		/* what CPU is the process running on */
+	bitchunk_t cpu_mask[BITMAP_CHUNKS(CONFIG_MAX_CPUS)]; /* what CPUs is the
+								process allowed
+								to run on */
+} schedproc[NR_PROCS];
+
+/* Flag values */
+#define IN_USE		0x00001	/* set when 'schedproc' slot in use */
diff -x .* -ruPN minix2/minix/servers/sched_fcfs/schedule.c minix/minix/servers/sched_fcfs/schedule.c
--- minix2/minix/servers/sched_fcfs/schedule.c	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_fcfs/schedule.c	Tue May 24 18:46:23 2016
@@ -0,0 +1,298 @@
+/* This file contains the scheduling policy for SCHED
+ *
+ * The entry points are:
+ *   do_noquantum:        Called on behalf of process' that run out of quantum
+ *   do_start_scheduling  Request to start scheduling a proc
+ *   do_stop_scheduling   Request to stop scheduling a proc
+ *   do_nice		  Request to change the nice level on a proc
+ *   init_scheduling      Called from main.c to set up/prepare scheduling
+ */
+#include "sched_fcfs.h"
+#include "schedproc.h"
+#include <assert.h>
+#include <minix/com.h>
+#include <machine/archtypes.h>
+#include "kernel/proc.h" /* for queue constants */
+
+static minix_timer_t sched_timer;
+static unsigned balance_timeout;
+
+#define BALANCE_TIMEOUT	5 /* how often to balance queues in seconds */
+
+static int schedule_process(struct schedproc * rmp, unsigned flags);
+static void balance_queues(minix_timer_t *tp);
+
+#define SCHEDULE_CHANGE_PRIO	0x1
+#define SCHEDULE_CHANGE_QUANTUM	0x2
+#define SCHEDULE_CHANGE_CPU	0x4
+
+#define SCHEDULE_CHANGE_ALL	(	\
+		SCHEDULE_CHANGE_PRIO	|	\
+		SCHEDULE_CHANGE_QUANTUM	|	\
+		SCHEDULE_CHANGE_CPU		\
+		)
+
+#define schedule_process_local(p)	\
+	schedule_process(p, SCHEDULE_CHANGE_PRIO | SCHEDULE_CHANGE_QUANTUM)
+#define schedule_process_migrate(p)	\
+	schedule_process(p, SCHEDULE_CHANGE_CPU)
+
+#define CPU_DEAD	-1
+
+#define cpu_is_available(c)	(cpu_proc[c] >= 0)
+
+#define DEFAULT_USER_TIME_SLICE 9999999
+
+#define USER_PR 5
+
+/* processes created by RS are sysytem processes */
+#define is_system_proc(p)	((p)->parent == RS_PROC_NR)
+
+static unsigned cpu_proc[CONFIG_MAX_CPUS];
+
+static void pick_cpu(struct schedproc * proc)
+{
+#ifdef CONFIG_SMP
+	unsigned cpu, c;
+	unsigned cpu_load = (unsigned) -1;
+
+	if (machine.processors_count == 1) {
+		proc->cpu = machine.bsp_id;
+		return;
+	}
+
+	/* schedule sysytem processes only on the boot cpu */
+	if (is_system_proc(proc)) {
+		proc->cpu = machine.bsp_id;
+		return;
+	}
+
+	/* if no other cpu available, try BSP */
+	cpu = machine.bsp_id;
+	for (c = 0; c < machine.processors_count; c++) {
+		/* skip dead cpus */
+		if (!cpu_is_available(c))
+			continue;
+		if (c != machine.bsp_id && cpu_load > cpu_proc[c]) {
+			cpu_load = cpu_proc[c];
+			cpu = c;
+		}
+	}
+	proc->cpu = cpu;
+	cpu_proc[cpu]++;
+#else
+	proc->cpu = 0;
+#endif
+}
+
+/*===========================================================================*
+ *				do_noquantum				     *
+ *===========================================================================*/
+
+int do_noquantum(message *m_ptr)
+{
+	register struct schedproc *rmp;
+	int rv, proc_nr_n;
+
+	if (sched_isokendpt(m_ptr->m_source, &proc_nr_n) != OK) {
+		if(m_ptr->m_source == SCHED_RR_PROC_NR){
+			printf("SCHED: WARNING: got an invalid endpoint in OOQ msg %d\n",
+				m_ptr->m_pm_sched_scheduling_set_nice.endpoint);
+			return rv;
+		}
+		return _taskcall(SCHED_RR_PROC_NR, SCHEDULING_NO_QUANTUM, m_ptr);
+	}
+
+	rmp = &schedproc[proc_nr_n];
+
+	if ((rv = schedule_process_local(rmp)) != OK) {
+		return rv;
+	}
+	return OK;
+}
+
+/*===========================================================================*
+ *				do_stop_scheduling			     *
+ *===========================================================================*/
+int do_stop_scheduling(message *m_ptr)
+{
+
+	register struct schedproc *rmp;
+	int proc_nr_n;
+
+	/* check who can send you requests */
+	if (!accept_message(m_ptr))
+		return EPERM;
+
+	if (sched_isokendpt(m_ptr->m_lsys_sched_scheduling_stop.endpoint,
+		    &proc_nr_n) != OK) {
+		if(m_ptr->m_source == SCHED_RR_PROC_NR){
+			printf("SCHED: WARNING: got an invalid endpoint in OOQ msg %d\n",
+				m_ptr->m_pm_sched_scheduling_set_nice.endpoint);
+			return EBADEPT;
+		}
+		return _taskcall(SCHED_RR_PROC_NR, SCHEDULING_STOP, m_ptr);
+	}
+
+	rmp = &schedproc[proc_nr_n];
+#ifdef CONFIG_SMP
+	cpu_proc[rmp->cpu]--;
+#endif
+	rmp->flags = 0; /*&= ~IN_USE;*/
+
+	return OK;
+}
+
+/*===========================================================================*
+ *				do_start_scheduling			     *
+ *===========================================================================*/
+int do_start_scheduling(message *m_ptr)
+{
+
+	register struct schedproc *rmp;
+	int rv, proc_nr_n, parent_nr_n;
+
+	/* we can handle two kinds of messages here */
+	assert(m_ptr->m_type == SCHEDULING_START ||
+		m_ptr->m_type == SCHEDULING_INHERIT);
+
+	/* check who can send you requests */
+	if (!accept_message(m_ptr))
+		return EPERM;
+
+	/* Resolve endpoint to proc slot. */
+	if ((rv = sched_isemtyendpt(m_ptr->m_lsys_sched_scheduling_start.endpoint,
+			&proc_nr_n)) != OK) {
+		return rv;
+	}
+
+	rmp = &schedproc[proc_nr_n];
+
+		if (rmp->endpoint == rmp->parent) {
+
+		rmp->priority   = USER_PR;
+		rmp->time_slice = DEFAULT_USER_TIME_SLICE;
+
+#ifdef CONFIG_SMP
+		rmp->cpu = machine.bsp_id;
+#endif
+	}
+
+	/* Populate process slot */
+	rmp->endpoint     = m_ptr->m_lsys_sched_scheduling_start.endpoint;
+	rmp->parent       = m_ptr->m_lsys_sched_scheduling_start.parent;
+	rmp->max_priority = m_ptr->m_lsys_sched_scheduling_start.maxprio;
+
+	rmp->priority   = USER_PR;
+	rmp->time_slice = DEFAULT_USER_TIME_SLICE;
+
+	if ((rv = sys_schedctl(0, rmp->endpoint, 0, 0, 0)) != OK) {
+		printf("Sched: Error taking over scheduling for %d, kernel said %d\n",
+			rmp->endpoint, rv);
+		return rv;
+	}
+	rmp->flags = IN_USE;
+
+	pick_cpu(rmp);
+
+	while ((rv = schedule_process(rmp, SCHEDULE_CHANGE_ALL)) == EBADCPU) {
+		/* don't try this CPU ever again */
+		cpu_proc[rmp->cpu] = CPU_DEAD;
+		pick_cpu(rmp);
+	}
+
+	if (rv != OK) {
+
+		printf("Sched: Error while scheduling process, kernel replied %d\n",
+			rv);
+		return rv;
+	}
+
+	m_ptr->m_sched_lsys_scheduling_start.scheduler = SCHED_PROC_NR;
+	m_ptr->m_sched_lsys_scheduling_start.real_sched = SCHED_FCFS_PROC_NR;
+
+	return OK;
+}
+
+/*===========================================================================*
+ *				do_nice					     *
+ *===========================================================================*/
+int do_nice(message *m_ptr)
+{
+	struct schedproc *rmp;
+	int rv;
+	int proc_nr_n;
+	unsigned new_q, old_q, old_max_q;
+
+	/* check who can send you requests */
+	if (!accept_message(m_ptr))
+		return EPERM;
+
+	if (sched_isokendpt(m_ptr->m_pm_sched_scheduling_set_nice.endpoint, &proc_nr_n) != OK) {
+
+		if(m_ptr->m_source == SCHED_RR_PROC_NR){
+			printf("SCHED: WARNING: got an invalid endpoint in OOQ msg %d\n",
+				m_ptr->m_pm_sched_scheduling_set_nice.endpoint);
+			return EBADEPT;
+		}
+		return _taskcall(SCHED_RR_PROC_NR, SCHEDULING_SET_NICE, m_ptr);
+	}
+
+	rmp = &schedproc[proc_nr_n];
+
+	rv = schedule_process_local(rmp);
+
+	return rv;
+}
+
+/*===========================================================================*
+ *				schedule_process			     *
+ *===========================================================================*/
+static int schedule_process(struct schedproc * rmp, unsigned flags)
+{
+	int err;
+	int new_prio, new_quantum, new_cpu;
+
+	pick_cpu(rmp);
+
+	if (flags & SCHEDULE_CHANGE_PRIO)
+		new_prio = rmp->priority;
+	else
+		new_prio = -1;
+
+	if (flags & SCHEDULE_CHANGE_QUANTUM){
+		new_quantum = rmp->time_slice;
+	}
+	else
+		new_quantum = -1;
+
+	if (flags & SCHEDULE_CHANGE_CPU)
+		new_cpu = rmp->cpu;
+	else
+		new_cpu = -1;
+
+	if ((err = sys_schedule(rmp->endpoint, new_prio,
+		new_quantum, new_cpu)) != OK) {
+		printf("PM: An error occurred when trying to schedule %d: %d\n",
+		rmp->endpoint, err);
+	}
+
+	return err;
+}
+
+
+/*===========================================================================*
+ *				start_scheduling			     *
+ *===========================================================================*/
+
+void init_scheduling(void)
+{
+	balance_timeout = BALANCE_TIMEOUT * sys_hz();
+	init_timer(&sched_timer);
+	set_timer(&sched_timer, balance_timeout, balance_queues, 0);
+}
+
+static void balance_queues(minix_timer_t *tp)
+{
+	set_timer(&sched_timer, balance_timeout, balance_queues, 0);
+}
diff -x .* -ruPN minix2/minix/servers/sched_fcfs/utility.c minix/minix/servers/sched_fcfs/utility.c
--- minix2/minix/servers/sched_fcfs/utility.c	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_fcfs/utility.c	Tue May 24 18:46:23 2016
@@ -0,0 +1,78 @@
+/* This file contains some utility routines for SCHED.
+ *
+ * The entry points are:
+ *   no_sys:		called for invalid system call numbers
+ *   sched_isokendpt:	check the validity of an endpoint
+ *   sched_isemtyendpt  check for validity and availability of endpoint slot
+ *   accept_message	check whether message is allowed
+ */
+
+#include "sched_fcfs.h"
+#include <machine/archtypes.h>
+#include <sys/resource.h> /* for PRIO_MAX & PRIO_MIN */
+#include "kernel/proc.h" /* for queue constants */
+#include "schedproc.h"
+
+/*===========================================================================*
+ *				no_sys					     *
+ *===========================================================================*/
+int no_sys(int who_e, int call_nr)
+{
+/* A system call number not implemented by PM has been requested. */
+  printf("SCHED: in no_sys, call nr %d from %d SOY FCFS.\n ", call_nr, who_e);
+  return(ENOSYS);
+}
+
+
+/*===========================================================================*
+ *				sched_isokendpt			 	     *
+ *===========================================================================*/
+int sched_isokendpt(int endpoint, int *proc)
+{
+	*proc = _ENDPOINT_P(endpoint);
+	if (*proc < 0)
+		return (EBADEPT); /* Don't schedule tasks */
+	if(*proc >= NR_PROCS)
+		return (EINVAL);
+	if(endpoint != schedproc[*proc].endpoint)
+		return (EDEADEPT);
+	if(!(schedproc[*proc].flags & IN_USE))
+		return (EDEADEPT);
+	return (OK);
+}
+
+/*===========================================================================*
+ *				sched_isemtyendpt		 	     *
+ *===========================================================================*/
+int sched_isemtyendpt(int endpoint, int *proc)
+{
+	*proc = _ENDPOINT_P(endpoint);
+	if (*proc < 0)
+		return (EBADEPT); /* Don't schedule tasks */
+	if(*proc >= NR_PROCS)
+		return (EINVAL);
+	if(schedproc[*proc].flags & IN_USE)
+		return (EDEADEPT);
+	return (OK);
+}
+
+/*===========================================================================*
+ *				accept_message				     *
+ *===========================================================================*/
+int accept_message(message *m_ptr)
+{
+	/* accept all messages from PM and RS */
+	switch (m_ptr->m_source) {
+
+		case PM_PROC_NR:
+		case RS_PROC_NR:
+		case SCHED_PROC_NR:
+		case SCHED_RR_PROC_NR:
+
+			return 1;
+			
+	}
+	
+	/* no other messages are allowable */
+	return 0;
+}
diff -x .* -ruPN minix2/minix/servers/sched_rr/Makefile minix/minix/servers/sched_rr/Makefile
--- minix2/minix/servers/sched_rr/Makefile	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_rr/Makefile	Tue May 24 18:46:23 2016
@@ -0,0 +1,12 @@
+# Makefile for Scheduler (SCHED)
+PROG=	sched_rr
+SRCS=	main.c schedule.c utility.c
+
+DPADD+=	${LIBSYS} ${LIBTIMERS}
+LDADD+=	-lsys -ltimers
+
+CPPFLAGS.main.c+=	-I${NETBSDSRCDIR}/minix
+CPPFLAGS.schedule.c+=	-I${NETBSDSRCDIR}/minix
+CPPFLAGS.utility.c+=	-I${NETBSDSRCDIR}/minix
+
+.include <minix.service.mk>
diff -x .* -ruPN minix2/minix/servers/sched_rr/main.c minix/minix/servers/sched_rr/main.c
--- minix2/minix/servers/sched_rr/main.c	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_rr/main.c	Tue May 24 18:46:23 2016
@@ -0,0 +1,131 @@
+/* This file contains the main program of the SCHED scheduler. It will sit idle
+ * until asked, by PM, to take over scheduling a particular process.
+ */
+
+/* The _MAIN def indicates that we want the schedproc structs to be created
+ * here. Used from within schedproc.h */
+#define _MAIN
+
+#include "sched_rr.h"
+#include "schedproc.h"
+
+/* Declare some local functions. */
+static void reply(endpoint_t whom, message *m_ptr);
+static void sef_local_startup(void);
+
+struct machine machine;		/* machine info */
+
+
+/*===========================================================================*
+ *				main					     *
+ *===========================================================================*/
+int main(void)
+{
+	/* Main routine of the scheduler. */
+	message m_in;	/* the incoming message itself is kept here. */
+	int call_nr;	/* system call number */
+	int who_e;	/* caller's endpoint */
+	int result;	/* result to system call */
+	int rv;
+	int s;
+
+	/* SEF local startup. */
+	sef_local_startup();
+
+	if (OK != (s=sys_getmachine(&machine)))
+		panic("couldn't get machine info: %d", s);
+	/* Initialize scheduling timers, used for running balance_queues */
+	init_scheduling();
+
+	/* This is SCHED's main loop - get work and do it, forever and forever. */
+	while (TRUE) {
+		int ipc_status;
+
+
+
+		/* Wait for the next message and extract useful information from it. */
+		if (sef_receive_status(ANY, &m_in, &ipc_status) != OK)
+			panic("SCHED sef_receive error");
+		who_e = m_in.m_source;	/* who sent the message */
+		call_nr = m_in.m_type;	/* system call number */
+
+		/* Check for system notifications first. Special cases. */
+		if (is_ipc_notify(ipc_status)) {
+			switch(who_e) {
+				case CLOCK:
+					expire_timers(m_in.m_notify.timestamp);
+					continue;	/* don't reply */
+				default :
+					result = ENOSYS;
+			}
+
+			goto sendreply;
+		}
+
+		switch(call_nr) {
+		case SCHEDULING_INHERIT:
+
+		case SCHEDULING_START:
+			result = do_start_scheduling(&m_in);
+			break;
+		case SCHEDULING_STOP:
+			result = do_stop_scheduling(&m_in);
+			break;
+		case SCHEDULING_SET_NICE:
+			result = do_nice(&m_in);
+			break;
+		case SCHEDULING_NO_QUANTUM:
+			/* This message was sent from the kernel, don't reply */
+			if (IPC_STATUS_FLAGS_TEST(ipc_status,
+				IPC_FLG_MSG_FROM_KERNEL)) {
+				if ((rv = do_noquantum(&m_in)) != (OK)) {
+					printf("SCHED: Warning, do_noquantum "
+						"failed with %d\n", rv);
+				}
+				continue; /* Don't reply */
+			}
+			else {
+				printf("SCHED: process %d faked "
+					"SCHEDULING_NO_QUANTUM message!\n",
+						who_e);
+				result = EPERM;
+			}
+			break;
+		default:
+
+			result = no_sys(who_e, call_nr);
+		}
+
+sendreply:
+
+		/* Send reply. */
+		if (result != SUSPEND) {
+			m_in.m_type = result;  		/* build reply message */
+			reply(who_e, &m_in);		/* send it away */
+		}
+ 	}
+	return(OK);
+}
+
+/*===========================================================================*
+ *				reply					     *
+ *===========================================================================*/
+static void reply(endpoint_t who_e, message *m_ptr)
+{
+	int s = ipc_send(who_e, m_ptr);    /* send the message */
+	if (OK != s)
+		printf("SCHED: unable to send reply to %d: %d\n", who_e, s);
+}
+
+/*===========================================================================*
+ *			       sef_local_startup			     *
+ *===========================================================================*/
+static void sef_local_startup(void)
+{
+	/* No init callbacks for now. */
+	/* No live update support for now. */
+	/* No signal callbacks for now. */
+
+	/* Let SEF perform startup. */
+	sef_startup();
+}
diff -x .* -ruPN minix2/minix/servers/sched_rr/proto.h minix/minix/servers/sched_rr/proto.h
--- minix2/minix/servers/sched_rr/proto.h	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_rr/proto.h	Tue May 24 18:46:23 2016
@@ -0,0 +1,21 @@
+/* Function prototypes. */
+
+struct schedproc;
+#include <minix/timers.h>
+
+/* main.c */
+int main(void);
+void setreply(int proc_nr, int result);
+
+/* schedule.c */
+int do_noquantum(message *m_ptr);
+int do_start_scheduling(message *m_ptr);
+int do_stop_scheduling(message *m_ptr);
+int do_nice(message *m_ptr);
+void init_scheduling(void);
+
+/* utility.c */
+int no_sys(int who_e, int call_nr);
+int sched_isokendpt(int ep, int *proc);
+int sched_isemtyendpt(int ep, int *proc);
+int accept_message(message *m_ptr);
diff -x .* -ruPN minix2/minix/servers/sched_rr/sched_rr.h minix/minix/servers/sched_rr/sched_rr.h
--- minix2/minix/servers/sched_rr/sched_rr.h	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_rr/sched_rr.h	Tue May 24 18:46:23 2016
@@ -0,0 +1,19 @@
+/* This is the master header for the Scheduler.  It includes some other files
+ * and defines the principal constants.
+ */
+#define _SYSTEM		1	/* tell headers that this is the kernel */
+
+/* The following are so basic, all the *.c files get them automatically. */
+#include <minix/config.h>	/* MUST be first */
+#include <sys/types.h>
+#include <minix/const.h>
+
+#include <minix/syslib.h>
+#include <minix/sysutil.h>
+#include <minix/timers.h>
+
+#include <errno.h>
+
+#include "proto.h"
+
+extern struct machine machine;		/* machine info */
diff -x .* -ruPN minix2/minix/servers/sched_rr/schedproc.h minix/minix/servers/sched_rr/schedproc.h
--- minix2/minix/servers/sched_rr/schedproc.h	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_rr/schedproc.h	Tue May 24 18:46:23 2016
@@ -0,0 +1,39 @@
+/* This table has one slot per process.  It contains scheduling information
+ * for each process.
+ */
+#include <limits.h>
+
+#include <minix/bitmap.h>
+
+/* EXTERN should be extern except in main.c, where we want to keep the struct */
+#ifdef _MAIN
+#undef EXTERN
+#define EXTERN
+#endif
+
+#ifndef CONFIG_SMP
+#define CONFIG_MAX_CPUS 1
+#endif
+
+/**
+ * We might later want to add more information to this table, such as the
+ * process owner, process group or cpumask.
+ */
+
+EXTERN struct schedproc {
+	endpoint_t endpoint;	/* process endpoint id */
+	endpoint_t parent;	/* parent endpoint id */
+	unsigned flags;		/* flag bits */
+
+	/* User space scheduling */
+	unsigned max_priority;	/* this process' highest allowed priority */
+	unsigned priority;		/* the process' current priority */
+	unsigned time_slice;		/* this process's time slice */
+	unsigned cpu;		/* what CPU is the process running on */
+	bitchunk_t cpu_mask[BITMAP_CHUNKS(CONFIG_MAX_CPUS)]; /* what CPUs is the
+								process allowed
+								to run on */
+} schedproc[NR_PROCS];
+
+/* Flag values */
+#define IN_USE		0x00001	/* set when 'schedproc' slot in use */
diff -x .* -ruPN minix2/minix/servers/sched_rr/schedule.c minix/minix/servers/sched_rr/schedule.c
--- minix2/minix/servers/sched_rr/schedule.c	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_rr/schedule.c	Tue May 24 18:46:23 2016
@@ -0,0 +1,298 @@
+/* This file contains the scheduling policy for SCHED
+ *
+ * The entry points are:
+ *   do_noquantum:        Called on behalf of process' that run out of quantum
+ *   do_start_scheduling  Request to start scheduling a proc
+ *   do_stop_scheduling   Request to stop scheduling a proc
+ *   do_nice		  Request to change the nice level on a proc
+ *   init_scheduling      Called from main.c to set up/prepare scheduling
+ */
+#include "sched_rr.h"
+#include "schedproc.h"
+#include <assert.h>
+#include <minix/com.h>
+#include <machine/archtypes.h>
+#include "kernel/proc.h" /* for queue constants */
+
+static minix_timer_t sched_timer;
+static unsigned balance_timeout;
+
+#define BALANCE_TIMEOUT	5 /* how often to balance queues in seconds */
+
+static int schedule_process(struct schedproc * rmp, unsigned flags);
+static void balance_queues(minix_timer_t *tp);
+
+#define SCHEDULE_CHANGE_PRIO	0x1
+#define SCHEDULE_CHANGE_QUANTUM	0x2
+#define SCHEDULE_CHANGE_CPU	0x4
+
+#define SCHEDULE_CHANGE_ALL	(	\
+		SCHEDULE_CHANGE_PRIO	|	\
+		SCHEDULE_CHANGE_QUANTUM	|	\
+		SCHEDULE_CHANGE_CPU		\
+		)
+
+#define schedule_process_local(p)	\
+	schedule_process(p, SCHEDULE_CHANGE_PRIO | SCHEDULE_CHANGE_QUANTUM)
+#define schedule_process_migrate(p)	\
+	schedule_process(p, SCHEDULE_CHANGE_CPU)
+
+#define CPU_DEAD	-1
+
+#define cpu_is_available(c)	(cpu_proc[c] >= 0)
+
+#define DEFAULT_USER_TIME_SLICE 200
+
+#define USER_PR 5
+
+/* processes created by RS are sysytem processes */
+#define is_system_proc(p)	((p)->parent == RS_PROC_NR)
+
+static unsigned cpu_proc[CONFIG_MAX_CPUS];
+
+static void pick_cpu(struct schedproc * proc)
+{
+#ifdef CONFIG_SMP
+	unsigned cpu, c;
+	unsigned cpu_load = (unsigned) -1;
+	
+	if (machine.processors_count == 1) {
+		proc->cpu = machine.bsp_id;
+		return;
+	}
+
+	/* schedule sysytem processes only on the boot cpu */
+	if (is_system_proc(proc)) {
+		proc->cpu = machine.bsp_id;
+		return;
+	}
+
+	/* if no other cpu available, try BSP */
+	cpu = machine.bsp_id;
+	for (c = 0; c < machine.processors_count; c++) {
+		/* skip dead cpus */
+		if (!cpu_is_available(c))
+			continue;
+		if (c != machine.bsp_id && cpu_load > cpu_proc[c]) {
+			cpu_load = cpu_proc[c];
+			cpu = c;
+		}
+	}
+	proc->cpu = cpu;
+	cpu_proc[cpu]++;
+#else
+	proc->cpu = 0;
+#endif
+}
+
+/*===========================================================================*
+ *				do_noquantum				     *
+ *===========================================================================*/
+
+int do_noquantum(message *m_ptr)
+{
+	register struct schedproc *rmp;
+	int rv, proc_nr_n;
+
+	if (sched_isokendpt(m_ptr->m_source, &proc_nr_n) != OK) {
+		if(m_ptr->m_source == SCHED_FCFS_PROC_NR){
+			printf("SCHED: WARNING: got an invalid endpoint in OOQ msg %d\n", 
+				m_ptr->m_pm_sched_scheduling_set_nice.endpoint);
+			return rv;
+		}
+		return _taskcall(SCHED_FCFS_PROC_NR, SCHEDULING_NO_QUANTUM, m_ptr);
+	}
+
+	rmp = &schedproc[proc_nr_n];
+	
+	if ((rv = schedule_process_local(rmp)) != OK) {
+		return rv;
+	}
+	return OK;
+}
+
+/*===========================================================================*
+ *				do_stop_scheduling			     *
+ *===========================================================================*/
+int do_stop_scheduling(message *m_ptr)
+{
+	
+	register struct schedproc *rmp;
+	int proc_nr_n;
+
+	/* check who can send you requests */
+	if (!accept_message(m_ptr))
+		return EPERM;
+
+	if (sched_isokendpt(m_ptr->m_lsys_sched_scheduling_stop.endpoint,
+		    &proc_nr_n) != OK) {
+		if(m_ptr->m_source == SCHED_FCFS_PROC_NR){
+			printf("SCHED: WARNING: got an invalid endpoint in OOQ msg %d\n", 
+				m_ptr->m_pm_sched_scheduling_set_nice.endpoint);
+			return EBADEPT;
+		}
+		return _taskcall(SCHED_FCFS_PROC_NR, SCHEDULING_STOP, m_ptr);		
+	}
+
+	rmp = &schedproc[proc_nr_n];
+#ifdef CONFIG_SMP
+	cpu_proc[rmp->cpu]--;
+#endif
+	rmp->flags = 0; /*&= ~IN_USE;*/
+
+	return OK;
+}
+
+/*===========================================================================*
+ *				do_start_scheduling			     *
+ *===========================================================================*/
+int do_start_scheduling(message *m_ptr)
+{
+	
+	register struct schedproc *rmp;
+	int rv, proc_nr_n, parent_nr_n;
+	
+	/* we can handle two kinds of messages here */
+	assert(m_ptr->m_type == SCHEDULING_START || 
+		m_ptr->m_type == SCHEDULING_INHERIT);
+	
+	/* check who can send you requests */
+	if (!accept_message(m_ptr))
+		return EPERM;
+	
+	/* Resolve endpoint to proc slot. */
+	if ((rv = sched_isemtyendpt(m_ptr->m_lsys_sched_scheduling_start.endpoint,
+			&proc_nr_n)) != OK) {
+		return rv;
+	}
+	
+	rmp = &schedproc[proc_nr_n];
+
+		if (rmp->endpoint == rmp->parent) {
+	
+		rmp->priority   = USER_PR;
+		rmp->time_slice = DEFAULT_USER_TIME_SLICE;
+
+#ifdef CONFIG_SMP
+		rmp->cpu = machine.bsp_id;
+#endif
+	}
+
+	/* Populate process slot */
+	rmp->endpoint     = m_ptr->m_lsys_sched_scheduling_start.endpoint;
+	rmp->parent       = m_ptr->m_lsys_sched_scheduling_start.parent;
+	rmp->max_priority = m_ptr->m_lsys_sched_scheduling_start.maxprio;
+
+	rmp->priority   = USER_PR;
+	rmp->time_slice = DEFAULT_USER_TIME_SLICE;
+		
+	if ((rv = sys_schedctl(0, rmp->endpoint, 0, 0, 0)) != OK) {
+		printf("Sched: Error taking over scheduling for %d, kernel said %d\n",
+			rmp->endpoint, rv);
+		return rv;
+	}
+	rmp->flags = IN_USE;
+	
+	pick_cpu(rmp);
+	
+	while ((rv = schedule_process(rmp, SCHEDULE_CHANGE_ALL)) == EBADCPU) {
+	
+		/* don't try this CPU ever again */
+		cpu_proc[rmp->cpu] = CPU_DEAD;
+		pick_cpu(rmp);
+	}
+
+	if (rv != OK) {
+		
+		printf("Sched: Error while scheduling process, kernel replied %d\n",
+			rv);
+		return rv;
+	}
+
+	m_ptr->m_sched_lsys_scheduling_start.scheduler = SCHED_PROC_NR;
+	m_ptr->m_sched_lsys_scheduling_start.real_sched = SCHED_RR_PROC_NR;
+
+	return OK;
+}
+
+/*===========================================================================*
+ *				do_nice					     *
+ *===========================================================================*/
+int do_nice(message *m_ptr)
+{
+	struct schedproc *rmp;
+	int rv;
+	int proc_nr_n;
+	unsigned new_q, old_q, old_max_q;
+
+	/* check who can send you requests */
+	if (!accept_message(m_ptr))
+		return EPERM;
+
+	if (sched_isokendpt(m_ptr->m_pm_sched_scheduling_set_nice.endpoint, &proc_nr_n) != OK) {
+
+		if(m_ptr->m_source == SCHED_FCFS_PROC_NR){
+			printf("SCHED: WARNING: got an invalid endpoint in OOQ msg %d\n", 
+				m_ptr->m_pm_sched_scheduling_set_nice.endpoint);
+			return EBADEPT;
+		}
+		return _taskcall(SCHED_FCFS_PROC_NR, SCHEDULING_SET_NICE, m_ptr);
+	}
+
+	rmp = &schedproc[proc_nr_n];
+	
+	rv = schedule_process_local(rmp);
+
+	return rv;
+}
+
+/*===========================================================================*
+ *				schedule_process			     *
+ *===========================================================================*/
+static int schedule_process(struct schedproc * rmp, unsigned flags)
+{
+	int err;
+	int new_prio, new_quantum, new_cpu;
+
+	pick_cpu(rmp);
+
+	if (flags & SCHEDULE_CHANGE_PRIO)
+		new_prio = rmp->priority;
+	else
+		new_prio = -1;
+
+	if (flags & SCHEDULE_CHANGE_QUANTUM)
+		new_quantum = rmp->time_slice;
+	else
+		new_quantum = -1;
+
+	if (flags & SCHEDULE_CHANGE_CPU)
+		new_cpu = rmp->cpu;
+	else
+		new_cpu = -1;
+
+	if ((err = sys_schedule(rmp->endpoint, new_prio,
+		new_quantum, new_cpu)) != OK) {
+		printf("PM: An error occurred when trying to schedule %d: %d\n",
+		rmp->endpoint, err);
+	}
+
+	return err;
+}
+
+
+/*===========================================================================*
+ *				start_scheduling			     *
+ *===========================================================================*/
+
+void init_scheduling(void)
+{
+	balance_timeout = BALANCE_TIMEOUT * sys_hz();
+	init_timer(&sched_timer);
+	set_timer(&sched_timer, balance_timeout, balance_queues, 0);
+}
+
+static void balance_queues(minix_timer_t *tp)
+{
+	set_timer(&sched_timer, balance_timeout, balance_queues, 0);
+}
\ No newline at end of file
diff -x .* -ruPN minix2/minix/servers/sched_rr/utility.c minix/minix/servers/sched_rr/utility.c
--- minix2/minix/servers/sched_rr/utility.c	Thu Jan  1 00:00:00 1970
+++ minix/minix/servers/sched_rr/utility.c	Tue May 24 18:46:23 2016
@@ -0,0 +1,77 @@
+/* This file contains some utility routines for SCHED.
+ *
+ * The entry points are:
+ *   no_sys:		called for invalid system call numbers
+ *   sched_isokendpt:	check the validity of an endpoint
+ *   sched_isemtyendpt  check for validity and availability of endpoint slot
+ *   accept_message	check whether message is allowed
+ */
+
+#include "sched_rr.h"
+#include <machine/archtypes.h>
+#include <sys/resource.h> /* for PRIO_MAX & PRIO_MIN */
+#include "kernel/proc.h" /* for queue constants */
+#include "schedproc.h"
+
+/*===========================================================================*
+ *				no_sys					     *
+ *===========================================================================*/
+int no_sys(int who_e, int call_nr)
+{
+/* A system call number not implemented by PM has been requested. */
+  printf("SCHED: in no_sys, call nr %d from %d SOY RR.\n ", call_nr, who_e);
+  return(ENOSYS);
+}
+
+
+/*===========================================================================*
+ *				sched_isokendpt			 	     *
+ *===========================================================================*/
+int sched_isokendpt(int endpoint, int *proc)
+{
+	*proc = _ENDPOINT_P(endpoint);
+	if (*proc < 0)
+		return (EBADEPT); /* Don't schedule tasks */
+	if(*proc >= NR_PROCS)
+		return (EINVAL);
+	if(endpoint != schedproc[*proc].endpoint)
+		return (EDEADEPT);
+	if(!(schedproc[*proc].flags & IN_USE))
+		return (EDEADEPT);
+	return (OK);
+}
+
+/*===========================================================================*
+ *				sched_isemtyendpt		 	     *
+ *===========================================================================*/
+int sched_isemtyendpt(int endpoint, int *proc)
+{
+	*proc = _ENDPOINT_P(endpoint);
+	if (*proc < 0)
+		return (EBADEPT); /* Don't schedule tasks */
+	if(*proc >= NR_PROCS)
+		return (EINVAL);
+	if(schedproc[*proc].flags & IN_USE)
+		return (EDEADEPT);
+	return (OK);
+}
+
+/*===========================================================================*
+ *				accept_message				     *
+ *===========================================================================*/
+int accept_message(message *m_ptr)
+{
+	/* accept all messages from PM and RS */
+	switch (m_ptr->m_source) {
+
+		case PM_PROC_NR:
+		case RS_PROC_NR:
+		case SCHED_PROC_NR:
+		case SCHED_FCFS_PROC_NR:
+			return 1;
+			
+	}
+	
+	/* no other messages are allowable */
+	return 0;
+}
diff -x .* -ruPN minix2/releasetools/Makefile minix/releasetools/Makefile
--- minix2/releasetools/Makefile	Tue May 24 18:41:16 2016
+++ minix/releasetools/Makefile	Tue May 24 18:46:23 2016
@@ -17,6 +17,8 @@
 PROGRAMS+= ${PROGROOT}/minix/servers/rs/rs
 PROGRAMS+= ${PROGROOT}/minix/servers/pm/pm
 PROGRAMS+= ${PROGROOT}/minix/servers/sched/sched
+PROGRAMS+= ${PROGROOT}/minix/servers/sched_rr/sched_rr
+PROGRAMS+= ${PROGROOT}/minix/servers/sched_fcfs/sched_fcfs
 PROGRAMS+= ${PROGROOT}/minix/servers/vfs/vfs
 PROGRAMS+= ${PROGROOT}/minix/drivers/storage/memory/memory
 PROGRAMS+= ${PROGROOT}/minix/drivers/tty/tty/tty
